# LeetCode 717 - 1-bit and 2-bit Characters (解題說明)

## 題目簡述
給定一個只包含 0 與 1 的陣列 `bits`，其中：
  - `a` 用單一位元 `0` 表示（1-bit 字元），
  - `b` 用兩位元 `10` 或 `11` 表示（2-bit 字元）。
陣列 `bits` 一定「以 0 結尾」。請判斷原始字串的最後一個字元是否為 `a`（1-bit 字元）。

## 思路（繁體中文）
觀察到 `a` 與 `b` 的第一個位元一定不同：
- `a` 的第一個位元是 `0`；
- `b` 的第一個位元是 `1`（並且是兩位元長）。

因此，我們可以從左到右解析 `bits`：
- 當遇到 `0` 時，表示當前字元是 `a`，前進一位（i += 1）；
- 當遇到 `1` 時，表示當前字元是 `b`，前進兩位（i += 2）。

重複直到剩餘的位元數 <= 1。若最後剩下一位（i == n - 1），則最後一個字元必為 `a`；否則若剛好解析完全部位元（i == n），表示最後字元為 `b`。

## 範例
- 輸入: [1, 0, 0] -> 解析為 [b, a]，最後一個字元為 a，回傳 true
- 輸入: [1, 1, 1, 0] -> 解析為 [b, b]，最後一個字元為 b，回傳 false

## 時間與空間複雜度
- 時間複雜度: O(n)，n 為 bits 長度（只需一次線性掃描）。
- 空間複雜度: O(1)，只使用常數輔助變數。

## 實作要點
- 點擊 `Program.cs` 的 `IsOneBitCharacter` 方法，該方法從左向右跳過字元，根據 `bits[i]` 判斷跳過一位或兩位，最後回傳 `i == n - 1`。

## 解題說明（兩種常見解法）

### 解法一：左到右線性掃描（IsOneBitCharacter）

#### 核心思路
從陣列起始處開始逐步解析每個字元，利用字元編碼的特性：
- 若當前位元為 `0`，表示這是一個 1-bit 字元，前進 1 位
- 若當前位元為 `1`，表示這是一個 2-bit 字元的開頭，前進 2 位

持續解析直到剩餘位元數 ≤ 1，最後檢查索引位置：
- 若 `i == n - 1`：表示最後一個位元是獨立的，為 1-bit 字元，回傳 `true`
- 若 `i == n`：表示最後一個字元是 2-bit 字元的一部分，回傳 `false`

#### 演算法步驟
```
1. 初始化索引 i = 0，n = bits.Length
2. 當 i < n - 1 時：
   - 若 bits[i] == 0，則 i += 1（跳過 1-bit 字元）
   - 若 bits[i] == 1，則 i += 2（跳過 2-bit 字元）
3. 回傳 i == n - 1
```

#### 詳細範例推導

**範例 1: bits = [1, 0, 0]**
```
初始: i = 0, n = 3
步驟 1: bits[0] = 1 → 這是 2-bit 字元 (10)，i += 2 → i = 2
步驟 2: i = 2 < n - 1 = 2 為假，迴圈結束
結果: i = 2 == n - 1 → true（最後的 bits[2] = 0 是獨立的 1-bit 字元）
解析結果: [10] [0] → [b, a]
```

**範例 2: bits = [1, 1, 1, 0]**
```
初始: i = 0, n = 4
步驟 1: bits[0] = 1 → 這是 2-bit 字元 (11)，i += 2 → i = 2
步驟 2: bits[2] = 1 → 這是 2-bit 字元 (10)，i += 2 → i = 4
步驟 3: i = 4 < n - 1 = 3 為假，迴圈結束
結果: i = 4 ≠ n - 1 → false（最後的 0 與前面的 1 組成 2-bit 字元）
解析結果: [11] [10] → [b, b]
```

**範例 3: bits = [0]**
```
初始: i = 0, n = 1
步驟 1: i = 0 < n - 1 = 0 為假，迴圈不執行
結果: i = 0 == n - 1 → true（單一 0 就是 1-bit 字元）
```

**範例 4: bits = [1, 0]**
```
初始: i = 0, n = 2
步驟 1: bits[0] = 1 → 這是 2-bit 字元 (10)，i += 2 → i = 2
步驟 2: i = 2 < n - 1 = 1 為假，迴圈結束
結果: i = 2 ≠ n - 1 → false（整個陣列就是一個 2-bit 字元）
解析結果: [10] → [b]
```

#### 複雜度分析
- **時間複雜度**: O(n)，最多遍歷整個陣列一次
- **空間複雜度**: O(1)，只使用常數額外空間

---

### 解法二：從尾端計數連續 1（IsOneBitCharacter_CountTrailingOnes）

#### 核心思路
觀察最後一個 `0` 之前連續 `1` 的數量，利用數學規律判斷：
- 若連續 `1` 的個數為**偶數**：最後的 `0` 是獨立的 1-bit 字元
- 若連續 `1` 的個數為**奇數**：最後的 `1` 會與最後的 `0` 組成 2-bit 字元 `10`

**為什麼這個規律成立？**
- 每個 2-bit 字元都以 `1` 開頭，佔用 2 個位元
- 若有偶數個連續 `1`，它們可以兩兩配對成 2-bit 字元（`11` 或前面的 `10`），最後的 `0` 保持獨立
- 若有奇數個連續 `1`，前面的 `1` 配對後，剩下最後一個 `1` 必須與尾部的 `0` 組成 `10`

#### 演算法步驟
```
1. 初始化 countOnes = 0
2. 從索引 n - 2 開始向前掃描（倒數第二個位元）
3. 當 i ≥ 0 且 bits[i] == 1 時：
   - countOnes++
   - i--
4. 回傳 countOnes % 2 == 0
```

#### 詳細範例推導

**範例 1: bits = [1, 0, 0]**
```
初始: n = 3, countOnes = 0
步驟 1: i = n - 2 = 1，bits[1] = 0 ≠ 1，迴圈結束
結果: countOnes = 0（偶數）→ true
說明: 最後的 0 前沒有連續的 1，所以最後的 0 是獨立的 1-bit 字元
解析結果: [10] [0] → [b, a]
```

**範例 2: bits = [1, 1, 1, 0]**
```
初始: n = 4, countOnes = 0
步驟 1: i = 2，bits[2] = 1 → countOnes = 1，i = 1
步驟 2: i = 1，bits[1] = 1 → countOnes = 2，i = 0
步驟 3: i = 0，bits[0] = 1 → countOnes = 3，i = -1
步驟 4: i = -1 < 0，迴圈結束
結果: countOnes = 3（奇數）→ false
說明: 有 3 個連續的 1，前兩個配對成 [11]，最後一個 1 與尾部 0 組成 [10]
解析結果: [11] [10] → [b, b]
```

**範例 3: bits = [1, 1, 0]**
```
初始: n = 3, countOnes = 0
步驟 1: i = 1，bits[1] = 1 → countOnes = 1，i = 0
步驟 2: i = 0，bits[0] = 1 → countOnes = 2，i = -1
結果: countOnes = 2（偶數）→ true
說明: 有 2 個連續的 1，配對成 [11]，最後的 0 是獨立的
解析結果: [11] [0] → [b, a]
```

**範例 4: bits = [0, 0, 0]**
```
初始: n = 3, countOnes = 0
步驟 1: i = 1，bits[1] = 0 ≠ 1，迴圈結束
結果: countOnes = 0（偶數）→ true
說明: 沒有連續的 1，所有都是 1-bit 字元
解析結果: [0] [0] [0] → [a, a, a]
```

**範例 5: bits = [1, 1, 1, 1, 0]**
```
初始: n = 5, countOnes = 0
步驟 1~4: 從 i = 3 往前掃描，bits[3,2,1,0] 都是 1
結果: countOnes = 4（偶數）→ true
說明: 4 個連續的 1 可以配對成 [11][11]，最後的 0 是獨立的
解析結果: [11] [11] [0] → [b, b, a]
```

#### 複雜度分析
- **時間複雜度**: O(n)，最壞情況下掃描到陣列開頭
- **空間複雜度**: O(1)，只使用常數額外空間

---

### 兩種解法比較

| 比較項目 | 解法一：左到右線性掃描 | 解法二：尾端計數連續 1 |
|---------|---------------------|---------------------|
| **核心策略** | 模擬解析過程，從頭到尾依序解碼 | 數學推理，只關注尾部特徵 |
| **掃描方向** | 從左到右（正向） | 從右到左（反向） |
| **思維方式** | 直觀、模擬實際解析流程 | 抽象、利用數學規律 |
| **程式碼可讀性** | ★★★★★ 非常直觀易懂 | ★★★☆☆ 需要理解背後數學邏輯 |
| **時間複雜度** | O(n) | O(n) 最壞情況 |
| **平均效能** | 始終掃描整個陣列 | 可能提前結束（遇到 0 就停止） |
| **最佳情況** | O(n) | O(1)（例如 `[0, 0, ..., 0]`） |
| **最壞情況** | O(n) | O(n)（例如 `[1, 1, ..., 1, 0]`） |
| **空間複雜度** | O(1) | O(1) |
| **適用場景** | 一般情況、面試首選 | 陣列尾部有大量 0 時效能較佳 |
| **優點** | 邏輯清晰、易於理解和驗證 | 某些情況下可提前結束掃描 |
| **缺點** | 必須完整掃描陣列 | 需要額外理解數學證明 |
| **面試推薦度** | ★★★★★ | ★★★☆☆ |

#### 效能比較實例

```
輸入: [0, 0, 0, 0, 0]
解法一: 掃描 5 次
解法二: 掃描 1 次（i = 3 時就遇到 0 停止）
→ 解法二較優

輸入: [1, 1, 1, 1, 0]
解法一: 掃描 2 次（i: 0→2→4）
解法二: 掃描 4 次（從 i = 3 到 i = 0）
→ 解法一較優

輸入: [1, 0, 1, 0, 0]
解法一: 掃描 3 次（i: 0→2→4）
解法二: 掃描 1 次（i = 3 時就遇到 0 停止）
→ 解法二較優
```

#### 建議使用時機

- **首選解法一（左到右線性掃描）**：
  - 面試場合（邏輯清晰，容易解釋）
  - 程式碼可讀性優先
  - 一般性應用場景

- **考慮解法二（尾端計數連續 1）**：
  - 陣列尾部有大量 0 的特殊情況
  - 追求極致效能優化
  - 展示數學推理能力

## 範例

- [1, 0, 0] -> 解析為 [10, 0] -> 最後為 1-bit -> true
- [1, 1, 1, 0] -> 解析為 [11, 10] -> 最後為 2-bit -> false

## 測試資料

程式中 `Program.cs` 範例測資如下：

- `new int[] { 1, 0, 0 }`     => true  // 解析為 [b, a]，最後為 a
- `new int[] { 1, 1, 1, 0 }` => false // 解析為 [b, b]，最後為 b
- `new int[] { 0 }`          => true  // 單一 0
- `new int[] { 1, 0 }`       => false // 解析為 [b]

其他值得驗證的邊界案例：

- `new int[] { 0, 0, 0 }`    => true  // 多個連續 0
- `new int[] { 1, 1, 0 }`    => true  // [11, 0]
- `new int[] { 1, 1, 1, 1, 0 }` => false // 多個 1，奇數或偶數的差別
- 最短與最長的情況（根據題目限制，例如 1 位元或多位元）

## 示範
執行 `Program.Main`，程式會輸出多個測資的驗證結果（請參考 `Program.cs` 的輸出）。

## 作者註記
此版本以繁體中文註釋及說明為主，並在 `Program.cs` 中加入了 XML 文件注釋與內部邏輯註解，以利閱讀與維護。
