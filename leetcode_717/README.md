# LeetCode 717 - 1-bit and 2-bit Characters (解題說明)

## 題目簡述
給定一個只包含 0 與 1 的陣列 `bits`，其中：
  - `a` 用單一位元 `0` 表示（1-bit 字元），
  - `b` 用兩位元 `10` 或 `11` 表示（2-bit 字元）。
陣列 `bits` 一定「以 0 結尾」。請判斷原始字串的最後一個字元是否為 `a`（1-bit 字元）。

## 思路（繁體中文）
觀察到 `a` 與 `b` 的第一個位元一定不同：
- `a` 的第一個位元是 `0`；
- `b` 的第一個位元是 `1`（並且是兩位元長）。

因此，我們可以從左到右解析 `bits`：
- 當遇到 `0` 時，表示當前字元是 `a`，前進一位（i += 1）；
- 當遇到 `1` 時，表示當前字元是 `b`，前進兩位（i += 2）。

重複直到剩餘的位元數 <= 1。若最後剩下一位（i == n - 1），則最後一個字元必為 `a`；否則若剛好解析完全部位元（i == n），表示最後字元為 `b`。

## 範例
- 輸入: [1, 0, 0] -> 解析為 [b, a]，最後一個字元為 a，回傳 true
- 輸入: [1, 1, 1, 0] -> 解析為 [b, b]，最後一個字元為 b，回傳 false

## 時間與空間複雜度
- 時間複雜度: O(n)，n 為 bits 長度（只需一次線性掃描）。
- 空間複雜度: O(1)，只使用常數輔助變數。

## 實作要點
- 點擊 `Program.cs` 的 `IsOneBitCharacter` 方法，該方法從左向右跳過字元，根據 `bits[i]` 判斷跳過一位或兩位，最後回傳 `i == n - 1`。

## 解題說明（兩種常見解法）


1. 左到右解析（線性掃描）

  - 從陣列起始處開始解析，當 `bits[i] == 0` 時表示 1-bit 字元，前進一位（i += 1）；當 `bits[i] == 1` 時表示 2-bit 字元，前進兩位（i += 2）。
  - 直到 `i >= n - 1` 為止：如果 `i == n - 1`，最後一個字元是 1-bit，否則為 2-bit。
  - 此方法直觀且在實務上最常使用，時間複雜度 O(n)、空間複雜度 O(1)。


2. 從尾端計數連續 1（計算尾端 1 的數量）

  - 題目保證 `bits` 以 `0` 結尾，若倒數第二個位元之後連續的 1 的數量為偶數，代表最後一個 `0` 是獨立的 1-bit 字元，否則最後一個字元被前面的 `1` 與 `0` 組成為 2-bit 字元。
  - 此解法也是 O(n) 時間、O(1) 空間，但在某些情況下只需掃描尾部，常見於推理與數學證明。

## 範例

- [1, 0, 0] -> 解析為 [10, 0] -> 最後為 1-bit -> true
- [1, 1, 1, 0] -> 解析為 [11, 10] -> 最後為 2-bit -> false

## 測試資料

程式中 `Program.cs` 範例測資如下：

- `new int[] { 1, 0, 0 }`     => true  // 解析為 [b, a]，最後為 a
- `new int[] { 1, 1, 1, 0 }` => false // 解析為 [b, b]，最後為 b
- `new int[] { 0 }`          => true  // 單一 0
- `new int[] { 1, 0 }`       => false // 解析為 [b]

其他值得驗證的邊界案例：

- `new int[] { 0, 0, 0 }`    => true  // 多個連續 0
- `new int[] { 1, 1, 0 }`    => true  // [11, 0]
- `new int[] { 1, 1, 1, 1, 0 }` => false // 多個 1，奇數或偶數的差別
- 最短與最長的情況（根據題目限制，例如 1 位元或多位元）

## 示範
執行 `Program.Main`，程式會輸出多個測資的驗證結果（請參考 `Program.cs` 的輸出）。

## 作者註記
此版本以繁體中文註釋及說明為主，並在 `Program.cs` 中加入了 XML 文件注釋與內部邏輯註解，以利閱讀與維護。
