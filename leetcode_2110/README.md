# LeetCode 2110: 股票平滑下跌階段的數目

這是 LeetCode 第 2110 題的 C# 解決方案，使用動態規劃方法來計算股票價格陣列中所有平滑下跌階段的總數。

## 題目描述

給定一個整數陣列 `prices`，表示股票每日的價格歷史，其中 `prices[i]` 為第 `i` 天的價格。

一個**平滑下跌階段**定義為一個或多個連續天數組成的期間，且從第二天起每一天的價格都比前一天低恰好 1（期間的第一天不受此規則限制）。

**目標：** 回傳所有平滑下跌階段的總數。

### 範例

**範例 1:**

```text
輸入: prices = [3,2,1,4]
輸出: 7
解釋: 共有 7 個平滑下跌階段:
- 長度為 1 的階段: [3], [2], [1], [4]
- 長度為 2 的階段: [3,2], [2,1]
- 長度為 3 的階段: [3,2,1]
```

**範例 2:**

```text
輸入: prices = [8,6,7,7]
輸出: 4
解釋: 共有 4 個平滑下跌階段:
- 長度為 1 的階段: [8], [6], [7], [7]
```

**範例 3:**

```text
輸入: prices = [1]
輸出: 1
解釋: 只有 1 個平滑下跌階段: [1]
```

### 限制條件

- `1 <= prices.length <= 10^5`
- `1 <= prices[i] <= 10^5`

## 解題概念與出發點

### 問題分析

為了避免重複計算或遺漏，我們需要系統化地統計所有可能的平滑下跌階段。關鍵觀察點是：

1. **子問題重疊性**：以每一天為結尾的平滑下跌階段數量與前一天存在關聯
2. **無後效性**：當前天的計算結果只依賴於前一天的狀態
3. **最優子結構**：總數等於以每一天為結尾的階段數量之和

這些特性使得**動態規劃**成為最合適的解決方案。

### 核心思想

與其直接枚舉所有可能的子陣列（時間複雜度 O(n²)），我們可以透過統計**以每一天為結尾的平滑下跌階段數目**，然後將這些數目相加得到總數。

關鍵洞察：

- 如果第 `i` 天的價格比第 `i-1` 天恰好少 1，那麼所有以第 `i-1` 天結尾的平滑下跌階段都可以延伸到第 `i` 天
- 如果不滿足上述條件，則第 `i` 天只能單獨成為一個新的階段起點

## 解法詳解

### 方法：動態規劃（空間優化）

#### 狀態定義

定義 `dp[i]` 為以第 `i` 天為結尾的平滑下跌階段數目。

#### 狀態轉移方程

$$
dp[i] = \begin{cases}
1 & \text{if } i = 0 \\
1 & \text{if } i > 0 \text{ and } prices[i] \neq prices[i-1] - 1 \\
dp[i-1] + 1 & \text{if } i > 0 \text{ and } prices[i] = prices[i-1] - 1
\end{cases}
$$

**解釋：**

1. **初始狀態** (`i = 0`)：第一天本身就是一個平滑下跌階段，所以 `dp[0] = 1`

2. **無法延續** (`prices[i] ≠ prices[i-1] - 1`)：
   - 當前天價格不符合"恰好少 1"的條件
   - 無法與前一天組成連續下跌
   - 只能單獨作為新階段，所以 `dp[i] = 1`

3. **可以延續** (`prices[i] = prices[i-1] - 1`)：
   - 當前天可以與前一天組成連續下跌
   - 除了當前天本身（1 個階段），還可以將所有以第 `i-1` 天結尾的階段延伸過來
   - 所以 `dp[i] = dp[i-1] + 1`
   - 簡單說明：`dp[i-1]` 是能夠延伸到今天的舊階段數量，`+1` 代表只有今天這一天的單日階段。
     例如 `prices = [3,2,1]` 時，`dp` 會是 `[1,2,3]`，代表：
     - i=0: [3]
     - i=1: [2], [3,2]
     - i=2: [1], [2,1], [3,2,1]

#### 範例推導

以 `prices = [3, 2, 1, 4]` 為例：

| i | prices[i] | 價格關係 | dp[i] | 累計總數 res | 說明 |
|---|-----------|---------|-------|-------------|------|
| 0 | 3 | 初始 | 1 | 1 | [3] |
| 1 | 2 | 3-1=2 ✓ | 2 | 3 | [2], [3,2] |
| 2 | 1 | 2-1=1 ✓ | 3 | 6 | [1], [2,1], [3,2,1] |
| 3 | 4 | 1-1≠4 ✗ | 1 | 7 | [4] |

最終答案：7

#### 空間優化

由於 `dp[i]` 只依賴於 `dp[i-1]`，我們不需要維護完整的 `dp` 陣列，只需用一個變數 `prev` 來記錄前一個狀態即可，將空間複雜度從 O(n) 優化到 O(1)。

#### 複雜度分析

- **時間複雜度**：O(n)，其中 n 為陣列長度，只需遍歷一次陣列
- **空間複雜度**：O(1)，只使用常數個變數

#### 實作細節

> [!IMPORTANT]
> 考慮到數據範圍（`prices.length` 最大可達 10⁵），結果可能超過 32 位元整數上限（約 2.1 × 10⁹）。
>
> 最壞情況下（連續下降 10⁵ 天），總數約為 n(n+1)/2 ≈ 5 × 10⁹，因此必須使用 `long` 型別來儲存結果。

## 執行結果

執行程式後的輸出：

```text
測試案例 1: [3, 2, 1, 4]
結果: 7
預期: 7

測試案例 2: [8, 6, 7, 7]
結果: 4
預期: 4

測試案例 3: [1]
結果: 1
預期: 1
```

## 如何使用

### 環境需求

- .NET 10.0 或更高版本
- C# 14

### 編譯與執行

```bash
# 編譯專案
dotnet build

# 執行程式
dotnet run --project leetcode_2110/leetcode_2110.csproj
```

### 程式碼結構

```text
leetcode_2110/
├── leetcode_2110.sln           # 解決方案檔
├── README.md                    # 本文件
└── leetcode_2110/
    ├── leetcode_2110.csproj    # 專案檔
    └── Program.cs               # 主程式（包含解法）
```

## 相關資源

- [LeetCode 原題（英文）](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/)
- [LeetCode 原題（中文）](https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/)

## 標籤

`動態規劃` `陣列` `數學` `滑動窗口`
