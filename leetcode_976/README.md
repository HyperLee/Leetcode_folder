# LeetCode 976: Largest Perimeter Triangle

[![.NET](https://img.shields.io/badge/.NET-8.0-512BD4?style=flat-square)](https://dotnet.microsoft.com/)
[![License](https://img.shields.io/badge/license-MIT-blue?style=flat-square)](LICENSE)

一個 C# 解決方案，用於解決 LeetCode 第 976 題「三角形的最大周長」問題。

## 問題描述

給定一個整數數組 `nums`，返回由這三個長度組成的非零面積三角形的最長周長。如果不可能形成任何非零面積的三角形，則返回 0。

### 範例

**範例 1：**

```text
輸入: nums = [2,1,2]
輸出: 5
說明: 可以用邊長為 2, 1, 2 的三個數形成三角形，周長為 5。
```

**範例 2：**

```text
輸入: nums = [1,2,1]
輸出: 0
說明: 1 + 1 = 2 ≤ 2，不滿足三角不等式，無法形成三角形。
```

**範例 3：**

```text
輸入: nums = [3,2,3,4]
輸出: 10
說明: 可以用邊長為 3, 3, 4 的三個數形成三角形，周長為 10。
```

## 三角形基礎知識

### 三角形周長計算公式

三角形的周長是三個邊長的總和：

```text
周長 = 邊長1 + 邊長2 + 邊長3
```

### 三角不等式

要形成一個非零面積的三角形，三個邊長必須滿足**三角不等式**：

- 邊長1 + 邊長2 > 邊長3
- 邊長1 + 邊長3 > 邊長2  
- 邊長2 + 邊長3 > 邊長1

> [!IMPORTANT]
> 只有當三個邊長同時滿足所有三角不等式條件時，才能形成一個有效的三角形。

### 關鍵觀察

對於排序後的三個邊長 `a ≤ b ≤ c`：

- 由於 `a ≤ b ≤ c`，條件 `a + c > b` 和 `b + c > a` 自動滿足
- 只需檢查 `a + b > c` 是否成立

## 演算法解析

本專案實現了7種不同的解法，展示了多種演算法思維和優化策略。

### 🏆 方法1：排序 + 貪心策略（推薦解法）

**解題思路：**

1. **排序優化**：將數組按升序排序，利用排序後的性質簡化三角不等式檢查
2. **貪心策略**：從最大的三個數開始檢查，確保找到最大周長
3. **高效檢查**：對於排序後的數組，只需檢查最小兩邊之和是否大於最大邊
4. **早期返回**：一旦找到滿足條件的三邊組合，立即返回結果

```csharp
public int LargestPerimeter(int[] nums)
{
    Array.Sort(nums);
    for (int i = nums.Length - 1; i >= 2; i--)
    {
        if (nums[i - 2] + nums[i - 1] > nums[i])
        {
            return nums[i - 2] + nums[i - 1] + nums[i];
        }
    }
    return 0;
}
```

**複雜度分析：**

- **時間複雜度**: O(n log n) - 主要來自排序
- **空間複雜度**: O(1) - 只使用常數額外空間

### 📚 方法2：暴力解法

**解題思路：**
三重嵌套迴圈遍歷所有可能的三邊組合，檢查完整的三角不等式。

```csharp
public int LargestPerimeterBruteForce(int[] nums)
{
    int maxPerimeter = 0;
    for (int i = 0; i < nums.Length - 2; i++)
    {
        for (int j = i + 1; j < nums.Length - 1; j++)
        {
            for (int k = j + 1; k < nums.Length; k++)
            {
                int a = nums[i], b = nums[j], c = nums[k];
                if (a + b > c && a + c > b && b + c > a)
                {
                    maxPerimeter = Math.Max(maxPerimeter, a + b + c);
                }
            }
        }
    }
    return maxPerimeter;
}
```

**複雜度分析：**

- **時間複雜度**: O(n³) - 三重嵌套迴圈
- **空間複雜度**: O(1) - 只使用常數額外空間

### ⚡ 方法3：優化的暴力解法

**解題思路：**
先降序排序，優先檢查大數值組合，加入早期終止機制。

**複雜度分析：**

- **時間複雜度**: O(n³) - 最壞情況，平均情況更好
- **空間複雜度**: O(1) - 只使用常數額外空間

### 🎯 方法4：兩指針法（簡化版）

**解題思路：**
本質上等同於方法1，展示兩指針思維在此問題上的應用。

**複雜度分析：**

- **時間複雜度**: O(n log n) - 等同於方法1
- **空間複雜度**: O(1) - 只使用常數額外空間

### 🛡️ 方法5：不修改原數組

**解題思路：**
創建原數組的副本進行排序，保護原始資料不被修改。

```csharp
public int LargestPerimeterImmutable(int[] nums)
{
    int[] sortedNums = new int[nums.Length];
    Array.Copy(nums, sortedNums, nums.Length);
    Array.Sort(sortedNums);
    // ... 使用與方法1相同的邏輯
}
```

**複雜度分析：**

- **時間複雜度**: O(n log n) - 主要來自排序
- **空間複雜度**: O(n) - 需要額外數組空間

### 🎓 方法6：遞歸解法

**解題思路：**
將問題分解為子問題，使用遞歸思維解決，主要作為學術展示。

**複雜度分析：**

- **時間複雜度**: O(n³) - 最壞情況
- **空間複雜度**: O(n) - 遞歸呼叫堆疊

### 🔍 方法7：真正的兩指針實現

**解題思路：**
對每個可能的最大邊，使用雙指針掃描所有可能的另外兩邊，完整展示兩指針技術。

**複雜度分析：**

- **時間複雜度**: O(n²) - 雙重迴圈
- **空間複雜度**: O(1) - 只使用常數額外空間

## 解法比較總結

| 方法 | 時間複雜度 | 空間複雜度 | 優點 | 缺點 | 適用場景 |
|------|------------|------------|------|------|----------|
| 方法1 | O(n log n) | O(1) | 🏆 效率最高，程式碼簡潔 | 修改原數組 | **面試首選** |
| 方法2 | O(n³) | O(1) | 邏輯直觀，不需排序 | 效率低 | 小數據量，學習用途 |
| 方法3 | O(n³) | O(1) | 有早期終止優化 | 最壞情況仍是O(n³) | 平均性能要求 |
| 方法4 | O(n log n) | O(1) | 展示兩指針思維 | 實際等同方法1 | 演算法展示 |
| 方法5 | O(n log n) | O(n) | 保護原數據 | 額外空間開銷 | **需保護原數組時** |
| 方法6 | O(n³) | O(n) | 展示遞歸思維 | 效率低，空間開銷大 | 學術研究 |
| 方法7 | O(n²) | O(1) | 完整兩指針實現 | 實現複雜 | **演算法理解展示** |

### 演算法正確性證明

**定理**：對於排序後的數組，從最大的三個數開始檢查能保證找到最大周長。

**證明**：

1. 假設存在滿足三角不等式的三元組 `(a, b, c)` 其中 `a ≤ b ≤ c`
2. 對於任何更大的有效三元組 `(a', b', c')` 其中 `c' ≥ c`
3. 由於我們按降序檢查，會先遇到 `(a', b', c')`
4. 因此第一個找到的有效三元組必然具有最大周長

## 測試案例

程式包含以下測試案例：

| 測試案例 | 輸入 | 預期輸出 | 說明 |
|---------|------|---------|------|
| 1 | `[2, 1, 2]` | `5` | 正常情況，能形成三角形 |
| 2 | `[1, 2, 1]` | `0` | 無法形成三角形（1+1 ≤ 2） |
| 3 | `[3, 2, 3, 4]` | `10` | 多個可能三角形，選擇最大周長 |
| 4 | `[1, 1, 10]` | `0` | 邊界情況，剛好不滿足不等式 |
| 5 | `[3, 6, 2, 3]` | `8` | 較大數組的情況 |

## 執行方式

### 前置需求

- [.NET 8.0](https://dotnet.microsoft.com/download/dotnet/8.0) 或更高版本

### 建置和執行

```bash
# 克隆專案
git clone <repository-url>
cd leetcode_976

# 建置專案
dotnet build

# 執行程式
dotnet run
```

### 執行結果範例

程式會自動測試所有7種解法的正確性：

```text
🏁 LeetCode 976: 三角形的最大周長 - 多種解法比較
================================================================================

📋 測試案例 1: [2, 1, 2]
預期結果: 5
--------------------------------------------------
方法1 (排序+貪心): 5 ✅
方法2 (暴力解法): 5 ✅
方法3 (優化暴力): 5 ✅
方法4 (兩指針法): 5 ✅
方法5 (不修改原數組): 5 ✅
原數組是否改變: [2, 1, 2] ✅ 未改變
方法6 (遞歸解法): 5 ✅
方法7 (真兩指針): 5 ✅

📋 測試案例 2: [1, 2, 1]
預期結果: 0
--------------------------------------------------
方法1 (排序+貪心): 0 ✅
方法2 (暴力解法): 0 ✅
方法3 (優化暴力): 0 ✅
方法4 (兩指針法): 0 ✅
方法5 (不修改原數組): 0 ✅
原數組是否改變: [1, 2, 1] ✅ 未改變
方法6 (遞歸解法): 0 ✅
方法7 (真兩指針): 0 ✅

================================================================================
📊 解法比較總結:
方法1 (排序+貪心): 時間 O(n log n), 空間 O(1) - 🏆 推薦
方法2 (暴力解法): 時間 O(n³), 空間 O(1) - 適合小數據
方法3 (優化暴力): 時間 O(n³), 空間 O(1) - 平均性能較好
方法4 (兩指針法): 時間 O(n log n), 空間 O(1) - 等同方法1
方法5 (不修改原數組): 時間 O(n log n), 空間 O(n) - 保護原數據
方法6 (遞歸解法): 時間 O(n³), 空間 O(n) - 學習用途
方法7 (真兩指針): 時間 O(n²), 空間 O(1) - 完整掃描所有組合
```

## 核心概念

### 貪心演算法

這個解法採用貪心策略：

- **選擇標準**：總是選擇當前可能的最大周長
- **最優子結構**：局部最優解導向全域最優解
- **證明**：由於我們按降序檢查，第一個找到的有效三角形必然是最大周長

### 數學原理

1. **三角不等式的幾何意義**：三角形任意兩邊之和必須大於第三邊
2. **排序的作用**：簡化條件檢查，將三個不等式減少為一個
3. **周長最大化**：在滿足三角不等式的前提下，選擇邊長總和最大的組合

## 學習價值

### 💡 為什麼實現多種解法？

1. **面試準備**：展示對問題的深度理解和多種思維方式
2. **演算法比較**：直觀了解不同方法的時間空間權衡
3. **程式碼質量**：學習在不同約束條件下的最佳實踐
4. **效能分析**：實際測試驗證理論複雜度分析

### 🎯 實際應用場景

- **方法1**：生產環境的標準解法
- **方法2**：原型開發或數據量很小時
- **方法5**：函數式程式設計或需要保持資料不變性
- **方法7**：需要展示演算法深度理解時

### 📚 延伸學習

這個專案展示了以下重要概念：

- **貪心演算法**：局部最優解導向全域最優解
- **排序優化**：利用有序性簡化複雜判斷
- **時空複雜度權衡**：不同方法的效能特徵
- **程式碼可讀性 vs 效能**：在清晰度和速度間的平衡

## 相關題目

- [LeetCode 611: Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/)
- [LeetCode 812: Largest Triangle Area](https://leetcode.com/problems/largest-triangle-area/)
- [LeetCode 15: 3Sum](https://leetcode.com/problems/3sum/) - 類似的三重元素問題
- [LeetCode 16: 3Sum Closest](https://leetcode.com/problems/3sum-closest/) - 三元素最佳化問題

## 參考資料

- [LeetCode 976 原題](https://leetcode.com/problems/largest-perimeter-triangle/)
- [三角不等式 - 維基百科](https://zh.wikipedia.org/wiki/三角不等式)
- [貪心演算法 - 維基百科](https://zh.wikipedia.org/wiki/貪心演算法)
- [演算法複雜度分析](https://zh.wikipedia.org/wiki/算法复杂度)
- [.NET 官方文件](https://docs.microsoft.com/zh-tw/dotnet/)
