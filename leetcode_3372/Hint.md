<!-- filepath: d:\Leetcode_folder\Leetcode_folder\leetcode_3372\Hint.md -->

# LeetCode 3372 題繁體中文翻譯

---

## 3372. 連接兩棵樹後最大化目標節點的數量 I

有兩棵無向樹，分別包含 `n` 和 `m` 個節點，其節點標籤分別在區間 `[0, n - 1]` 和 `[0, m - 1]` 之內，且互不重複。

給定兩個長度分別為 `n - 1` 和 `m - 1` 的二維整數陣列 `edges1` 和 `edges2`，其中 `edges1[i] = [ai, bi]` 表示第一棵樹中的節點 `ai` 和 `bi` 之間有一條邊；`edges2[i] = [ui, vi]` 表示第二棵樹中的節點 `ui` 和 `vi` 之間有一條邊。你還會得到一個整數 `k`。

若從節點 `u` 到節點 `v` 的路徑邊數小於或等於 `k`，則稱節點 `u` 是節點 `v` 的 **目標節點 (target)**。請注意，節點永遠是自己的目標節點。

請你回傳一個長度為 `n` 的整數陣列 `answer`，其中 `answer[i]` 表示如果你可以從第一棵樹中的某個節點與第二棵樹中的某個節點連接一條邊，則節點 `i` 最多可以擁有多少個目標節點（來自兩棵樹的節點），使得從這些目標節點到節點 `i` 的邊數不超過 `k`。

> 每個查詢是獨立的，也就是說你在計算某個 `i` 的結果時新增了一條邊，在計算下一個節點時，必須先移除這條新增的邊。

---

## 題目重點

- 你有 **兩棵樹 Tree1 和 Tree2**。
- 對於 **Tree1 中的每個節點 `i`**，你可以「**任意選擇**」一個 Tree1 的節點 `a` 和 Tree2 的節點 `b`，然後在 `a` 和 `b` 之間新增一條邊（這樣兩棵樹就會連成一棵新的大樹）。
- 接著你要問：

> 如果我這樣接好後，從整棵「新大樹」中，有多少個節點「離 `i` 的距離小於等於 `k`」？（這些就是 `i` 的「目標節點 targets」）

- 你要找出「最佳連線方式（挑選哪個 a 和 b）」，使得 **`i` 能達到最多的目標節點數量**。
- 這樣的操作要對 Tree1 中的每個節點 `i` 各做一次，然後把每個 `i` 的最大結果放進 `answer[i]`。

---

## 範例說明

假設：

- Tree1 有 3 個節點：`0, 1, 2`，且邊是 `[[0,1],[1,2]]`（線性結構）
- Tree2 有 2 個節點：`0,1`，且邊是 `[[0,1]]`
- `k = 2`

---

### Tree1 的節點 `0`

- 連接 Tree1 的節點 `0` 和 Tree2 的節點 `0` → 新的大樹形成
- 計算：從「整棵大樹」中，**有幾個節點到節點 `0` 的距離 ≤ 2？**

可能結果如下：

- 連接 `0`（Tree1）到 `0`（Tree2） → 你可能可以從 Tree1 的 `0,1,2` 和 Tree2 的 `0` 都走到 `0`，總共 4 個節點。
- 你可以試試不同的連接方式（例如 Tree1 的 `1` 和 Tree2 的 `1`），來找到最佳方案。

最後把最大結果存到 `answer[0]`

---

### 重點觀念整理

- 對 Tree1 的每個節點 `i`：你可以自由選擇一個連接點 `(a from Tree1, b from Tree2)`
- 接一條邊後，計算 **有幾個節點距離 `i` ≤ k**
- 把這個最大值存進 `answer[i]`

---

## 具體範例

```text
Tree1（節點 0~2）：
  0
  |
  1
  |
  2

edges1 = [[0, 1], [1, 2]]

Tree2（節點 0~1）：
  0
  |
  1

edges2 = [[0, 1]]

k = 2
```

---

對於 Tree1 的每個節點 `i`（0, 1, 2），
嘗試「選一個 Tree1 的節點 `a` 和 Tree2 的節點 `b`」，連一條邊，
接著計算「整棵大樹裡，有幾個節點距離 `i` ≤ 2」。

---

### 第一步：Tree1 的節點 i = 0

#### 連接方式：Tree1 的 0 接到 Tree2 的 0

整棵新樹變成：

```text
  2
  |
  1
  |
  0(Tree1) - 0(Tree2)
                 |
                 1(Tree2)
```

#### 計算距離節點 0(Tree1) ≤ 2 的節點有哪些？

- 到自己：距離 0
- 到 Tree1 的 1：距離 1
- 到 Tree1 的 2：距離 2
- 到 Tree2 的 0：距離 1
- 到 Tree2 的 1：距離 2

總共：5 個節點
→ 所以 `answer[0] = 5`

---

### 第二步：Tree1 的節點 i = 1

#### 連接方式：Tree1 的 1 接到 Tree2 的 0

新樹變成：

```text
      2
      |
      1(Tree1) - 0(Tree2)
     /
   0(Tree1)      |
                 1(Tree2)
```

- 自己：距離 0
- 到 0(Tree1)：距離 1
- 到 2(Tree1)：距離 1
- 到 0(Tree2)：距離 1
- 到 1(Tree2)：距離 2

→ 總共還是 5 個節點
→ `answer[1] = 5`

---

### 第三步：Tree1 的節點 i = 2

#### 連接方式：Tree1 的 2 接到 Tree2 的 0

```text
0(Tree1)
    |
   1
    |
   2(Tree1) - 0(Tree2)
                   |
                 1(Tree2)
```

- 自己：距離 0
- 到 1(Tree1)：距離 1
- 到 0(Tree1)：距離 2
- 到 0(Tree2)：距離 1
- 到 1(Tree2)：距離 2

→ 還是 5 個節點
→ `answer[2] = 5`

---

## 最終答案

```python
answer = [5, 5, 5]
```

---

## 小結

- 對 Tree1 的每個節點，都可以**任選**連接方式（Tree1 節點連到 Tree2 節點）
- 然後看整棵大樹中，有幾個節點「到它的距離 ≤ k」
- 每次都挑「讓目標節點數最多」的連接方式，放入 `answer[i]`

---

如果你想進一步看程式碼或更複雜的例子，我也可以幫你寫一個。你有需要嗎？

