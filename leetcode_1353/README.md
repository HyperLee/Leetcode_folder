# LeetCode 1353 最多可以參加的會議數目

## 題目簡介
給定一個 `events` 陣列，`events[i] = [startDayi, endDayi]`，每個會議 i 從 `startDayi` 開始到 `endDayi` 結束。你可以在 `startDayi <= d <= endDayi` 的任一天參加會議 i，但同一天只能參加一場會議。請回傳你最多可以參加多少場會議。

---

## 方法一：貪心 + 小根堆（PriorityQueue）

### 思路說明
- 先將所有會議依照開始時間排序。
- 用一個小根堆維護所有當前可參加的會議的結束時間。
- 從第 1 天開始，依序處理到所有會議結束的最晚一天：
  - 將所有開始時間 <= 當前天數的會議加入堆中。
  - 移除所有結束時間 < 當前天數的會議（已過期）。
  - 若堆不為空，選擇結束時間最早的會議參加，並將其從堆中移除，計數+1。
- 回傳最多可參加的會議數。

### 優點
- 實作簡單，直觀。
- 適合天數範圍不大時使用。

### 缺點
- 若天數範圍極大，for 迴圈會遍歷所有天，效能會受影響。

---

## 方法二：貪心 + 並查集（Disjoint Set Union, DSU）

### 思路說明
- 先將所有會議依照結束日排序。
- 用一個並查集維護每一天的可用狀態。
- 對每個會議，嘗試從其開始日到結束日中，選擇最早可用的一天參加。
  - 若該天可用，則將該天標記為已用，並將其與下一天合併。
- 回傳最多可參加的會議數。

### 優點
- 查找與分配天數效率極高，適合天數範圍很大時使用。
- 並查集路徑壓縮可保證近乎常數時間查詢。

### 缺點
- 需要額外理解並查集資料結構。
- 程式碼較小根堆略複雜。

---

## 方法比較
| 方法         | 時間複雜度                | 空間複雜度 | 適用場景           |
|--------------|---------------------------|------------|--------------------|
| 小根堆       | O(N log N + D log N)      | O(N)       | 天數範圍不大       |
| 並查集（DSU）| O(N log D)                | O(D)       | 天數範圍很大       |

- N 為會議數，D 為天數範圍。
- 若天數範圍極大，建議使用並查集法。

---

## 為什麼排序依據不同？

- **方法一（小根堆）為什麼依「起始日」排序？**
  - 此法是「逐天」掃描，每天都要知道有哪些會議今天可以開始，因此必須依起始日排序，才能正確將所有「今天開始」的會議加入堆疊。
  - 這樣才能保證每一天都不會漏掉任何可選會議。

- **方法二（並查集）為什麼依「截止日」排序？**
  - 此法是「每個會議」只安排一次，為了讓早結束的會議不被晚結束的會議搶走唯一可用天數，必須優先處理截止日早的會議。
  - 依截止日排序，能保證每個會議都盡量在不影響其他會議的情況下被安排，最大化總參加數。

**總結：**
- 小根堆法是「每天看有哪些新會議可以選」，所以依起始日排序。
- 並查集法是「每個會議盡快安排，優先安排快結束的」，所以依截止日排序。

---

## 並查集（Disjoint Set Union, DSU）簡介

並查集是一種高效支援「合併集合」與「查找集合代表」的資料結構。常用於解決連通性、資源分配等問題。

- **基本操作**：
  - `Find(x)`: 查詢 x 所屬集合的代表元素。
  - `Union(x, y)`: 合併 x 與 y 所屬的集合。
- **優化技巧**：
  - 路徑壓縮（Path Compression）：查找時將節點直接指向根節點，提升查詢效率。
  - 按秩合併（Union by Rank）：合併時將小集合合併到大集合，避免樹過高。

在本題中，並查集用於維護每一天的可用狀態，能高效分配最早可用天數給每場會議。

---

## 參考
- LeetCode 1353: https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/
- 並查集（Disjoint Set Union）Wiki: https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86
