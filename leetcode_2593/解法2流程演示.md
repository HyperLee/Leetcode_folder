# 解法 2：流程演示（FindScore2）

## 概要

- 想法：把陣列切成「嚴格遞減子段」，在每個子段取「坡底（最小值）」，然後往左每隔一個元素取一次，保證不取相鄰元素且取得最大和。
- 時間複雜度：O(n)
- 空間複雜度：O(1)

## 關鍵觀察

1. 嚴格遞減子段的坡底（段尾）一定是該段中可以安全選的一個位置。
2. 選了坡底後，坡底右側（段外）相鄰元素會被標記不可選；坡底左側可以每隔一個位置選（因為不能選相鄰）。
3. 對每個子段採局部貪心：選坡底並往左每隔一個位置累加，整體可達成最優。

> 理由簡述：在嚴格遞減子段 v0 > v1 > ... > vk（vk 為坡底、最小值）中，選 vk 能保證符合「先選最小」的條件，且向左每隔一個位置選能在「不可選相鄰」的限制下取得該段可得的最大和。此觀察可由動態規劃的最優性（dp[i] = max(dp[i-1], dp[i-2] + nums[i])）得到輔助直覺。

## 演算法步驟（實作重點）

1. 使用外層迴圈遍歷陣列，步長為 2（因為選了 i，i+1 不能選）；實際程式碼中使用 `for (int i = 0; i < n; i += 2)`，並在內部用 `while` 尋找坡底，`i` 會在內部被前進。
2. 在每個起點 i0，透過 `while (i + 1 < n && nums[i] > nums[i+1]) ++i;` 找到整段嚴格遞減的坡底 i。
3. 從坡底 i 往回到起點 i0，每隔兩步累加 `nums[j]`：`for (int j = i; j >= i0; j -= 2) res += nums[j];`。

> 注意：實作中會在 `for` 迴圈內改變 `i`（由內部 `while` 前進），雖然可行但可讀性較差，建議改為 `while` 外層以提高可讀性。

## 範例模擬

下面用三個範例逐步模擬 `FindScore2` 的執行流程：

### 範例 1：nums = [2, 1, 3, 4, 5, 2]

```csharp
// 初始
// n = 6, res = 0

// 外層 i = 0
// i0 = 0
// while: nums[0]=2 > nums[1]=1 -> i = 1 （坡底）
// inner: j = 1 -> res += nums[1] = 1
// outer i += 2 -> i = 3

// 外層 i = 3
// i0 = 3
// while: nums[3]=4 > nums[4]=5? false => i = 3（坡底）
// inner: j = 3 -> res += 4 (res = 5)
// outer i += 2 -> i = 5

// 外層 i = 5
// i0 = 5
// while: i+1 out of bounds => 坡底 = 5
// inner: j = 5 -> res += 2 (res = 7)

// 最終 res = 7
```

### 範例 2（整段嚴格遞減）：nums = [5, 4, 3, 2]

```csharp
// 初始
// n = 4, res = 0

// 外層 i = 0
// i0 = 0
// while: 5>4 -> i=1; 4>3 -> i=2; 3>2 -> i=3; i+1 out of bounds -> 停止
// 坡底 i = 3
// inner: j = 3 -> res += 2; j = 1 -> res += 4; j = -1 停止

// 最終 res = 2 + 4 = 6
```

### 範例 3（嚴格遞增）：nums = [1, 2, 3, 4, 5]

```csharp
// 每個元素都被視為單一子段
// 外層 i = 0 -> 選索引 0 (1)
// 外層 i = 2 -> 選索引 2 (3)
// 外層 i = 4 -> 選索引 4 (5)
// 最終 res = 1 + 3 + 5 = 9
```

## 常見陷阱（Gotchas）

- 子段條件為「嚴格遞減」（`nums[i] > nums[i+1]`）：若出現相等的相鄰元素，該相等處會切斷子段。
- 在 `for` 迴圈中修改迴圈變數 `i`（由內部 `while` 增加）雖然可行，但可讀性較差；建議改寫為 `while` 外層。
- 若 `nums` 為 `null`，目前實作沒有檢查；建議在方法開始加入 `if (nums is null) throw new ArgumentNullException(nameof(nums));`。

## 小建議（可讀性與防禦式程式設計）

- 將外層 `for` 改寫為 `while`，讓變動 `i` 的行為更清楚。  
- 加入 `null` 檢查以避免 NullReferenceException。  
- 在方法上加入 XML 文件註解並說明邊界行為（符合專案風格）。

## 總結

此方法把問題化成「嚴格遞減子段」的局部處理：對每段選坡底並向左每隔一個位置累加。整體時間複雜度為 O(n)，空間複雜度為 O(1)。若需要，我可以進一步將實作重構為更可讀的 `while` 版本、加入 null 檢查並補上 XML 註解。

