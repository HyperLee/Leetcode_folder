# LeetCode 2593 - Find Score of an Array After Marking All Elements

> 標記所有元素後陣列的分數

## 題目描述

給定一個由正整數構成的陣列 `nums`。

初始 `score = 0`，對陣列套用下列演算法：

1. 選擇陣列中尚未標記的最小整數；若有多個相同的最小值，選擇索引最小的那個
2. 將該被選中的整數的值加到 `score`
3. 將該元素以及如果存在的相鄰左右兩個元素標記為已標記
4. 重複上述步驟直到所有元素都被標記

返回最終的 `score`。

### 範例

**範例 1：**
```
輸入：nums = [2,1,3,4,5,2]
輸出：7
說明：
- 選擇 1（索引 1），score += 1，標記 [0,1,2]
- 選擇 2（索引 5），score += 2，標記 [4,5]
- 選擇 4（索引 3），score += 4，標記 [3]
- 總分：1 + 2 + 4 = 7
```

**範例 2：**
```
輸入：nums = [2,3,5,1,3,2]
輸出：5
說明：
- 選擇 1（索引 3），score += 1，標記 [2,3,4]
- 選擇 2（索引 0），score += 2，標記 [0,1]
- 選擇 2（索引 5），score += 2，標記 [5]
- 總分：1 + 2 + 2 = 5
```

## 解法

本專案提供兩種不同思路的解法，各有優缺點。

---

## 解法一：模擬標記過程 + 排序

### 核心思路

模擬題目描述的標記過程，透過排序確保按照正確的順序處理元素。

### 演算法步驟

1. **建立輔助陣列**：建立包含元素值與原始索引的二維陣列 `numWithIndex`
   - 每個元素為 `[元素值, 原始索引]`

2. **自訂排序**：對輔助陣列進行排序
   - 優先規則：按元素值升序排序（較小的值優先）
   - 次要規則：當元素值相同時，按索引升序排序（較小的索引優先）

3. **標記追蹤**：使用布林陣列 `marked` 記錄已標記的索引位置

4. **遍歷計算**：按排序順序處理每個元素
   - 若該位置未被標記，則：
     - 將元素值加入分數
     - 標記該位置
     - 標記其左右相鄰位置（若存在）

### 程式碼實現

```csharp
public long FindScore(int[] nums)
{
    long score = 0;
    int n = nums.Length;
    
    // 建立二維陣列，每個元素存儲 [元素值, 原始索引]
    int[][] numWithIndex = new int[n][];
    for (int i = 0; i < n; i++)
    {
        numWithIndex[i] = new int[2];
        numWithIndex[i][0] = nums[i]; // 元素值
        numWithIndex[i][1] = i;        // 原始索引
    }

    // 自訂排序規則
    Array.Sort(numWithIndex, (a, b) =>
    {
        if (a[0] != b[0])
            return a[0] - b[0]; // 按元素值升序
        else
            return a[1] - b[1]; // 按索引升序
    });

    // 使用布林陣列記錄被標記的索引位置
    bool[] marked = new bool[n];
    
    // 依序處理排序後的元素
    for (int i = 0; i < n; i++)
    {
        int num = numWithIndex[i][0];
        int index = numWithIndex[i][1];

        if (!marked[index])
        {
            score += num;
            marked[index] = true;

            // 標記左右相鄰位置
            if (index > 0)
                marked[index - 1] = true;
            if (index < n - 1)
                marked[index + 1] = true;
        }
    }
    
    return score;
}
```

### 複雜度分析

- **時間複雜度**：`O(n log n)`
  - 建立輔助陣列：O(n)
  - 排序操作：O(n log n)
  - 遍歷處理：O(n)
  - 總體由排序主導

- **空間複雜度**：`O(n)`
  - 輔助二維陣列：O(n)
  - 標記陣列：O(n)

### 優點

✅ **邏輯直觀**：完全模擬題目描述的過程，容易理解和實現  
✅ **通用性強**：適用於各種數據分佈，不依賴特定模式  
✅ **易於除錯**：每一步操作都清晰可見，方便追蹤  
✅ **程式碼穩定**：實現較為直接，不易出錯

### 缺點

❌ **排序開銷**：需要 O(n log n) 的排序時間  
❌ **空間使用**：需要額外的二維陣列和標記陣列  
❌ **效能不佳**：對於大型數據集，排序成為性能瓶頸

### 適用場景

- 數據規模不大時（n < 10^4）
- 需要清晰的程式碼邏輯
- 面試時作為第一個想到的解法

---

## 解法二：轉換思維 + 分組循環

### 核心思路

將陣列視為由若干「嚴格遞減子段」組成，利用這個特性一次性處理多個元素，避免排序。

### 關鍵觀察

#### 觀察 1：嚴格遞減子段
將 `nums` 分解為嚴格遞減的子段：
- `[2,1,3,4,5,2]` → `[2,1]` + `[3]` + `[4]` + `[5,2]`
- `[2,3,5,1,3,2]` → `[2]` + `[3]` + `[5,1]` + `[3,2]`

#### 觀察 2：坡底必選
在嚴格遞減子段中，最小值（坡底）一定可以被選擇：
- 它比前一個元素小（或是子段起點）
- 不會大於下一個元素（因為是坡底）
- 若值相同，由於從左到右遍歷，索引最小

#### 觀察 3：間隔選擇
選了坡底元素後：
- 左側每隔一個位置的元素都可以選（不能選相鄰元素）
- 右側相鄰元素不能選（被標記）

### 演算法步驟

1. **步長遍歷**：從左到右以步長 2 遍歷（選了 i，則 i+1 不能選）

2. **尋找坡底**：對於每個起點，持續向右移動找到嚴格遞減子段的坡底
   ```
   while (i + 1 < n && nums[i] > nums[i + 1])
       ++i;
   ```

3. **回溯累加**：從坡底往回（向左）每隔一個位置累加元素值
   ```
   for (int j = i; j >= i0; j -= 2)
       res += nums[j];
   ```

### 圖解範例

以 `[5,4,3,2,1]` 為例：

```
索引:  0  1  2  3  4
數值:  5  4  3  2  1
      ↓  ↓  ↓  ↓  ↓
      嚴格遞減子段
                 ↑
                坡底 (選 1)
         ↑
        選 3
   ↑
  選 5

結果：1 + 3 + 5 = 9
```

### 程式碼實現

```csharp
public long FindScore2(int[] nums)
{
    long res = 0;
    
    // 以步長 2 遍歷（選了 i 後，i+1 不能選）
    for (int i = 0, n = nums.Length; i < n; i += 2)
    {
        int i0 = i; // 記錄當前子段的起點（坡頂）
        
        // 找到嚴格遞減子段的坡底
        while (i + 1 < n && nums[i] > nums[i + 1])
        {
            ++i;
        }
        
        // 從坡底往回到坡頂，每隔一個位置累加元素值
        for (int j = i; j >= i0; j -= 2)
        {
            res += nums[j];
        }
    }
    
    return res;
}
```

### 複雜度分析

- **時間複雜度**：`O(n)`
  - 外層迴圈：每次前進至少 2 步
  - 內層 while：尋找坡底，每個元素最多訪問一次
  - 內層 for：回溯累加，每個元素最多訪問一次
  - 總體：每個元素最多被訪問兩次

- **空間複雜度**：`O(1)`
  - 只使用常數個變數
  - 不需要額外的輔助陣列

### 優點

✅ **高效能**：線性時間複雜度，無需排序  
✅ **省空間**：僅使用常數額外空間  
✅ **一次遍歷**：只需遍歷陣列一次  
✅ **演算法優雅**：利用數學特性巧妙解題

### 缺點

❌ **理解難度**：需要理解「嚴格遞減子段」的概念  
❌ **不直觀**：邏輯跳躍較大，不容易想到  
❌ **除錯困難**：當出現 bug 時，較難追蹤問題  
❌ **面試風險**：若無法清楚解釋思路，可能讓面試官困惑

### 適用場景

- 數據規模很大時（n > 10^5）
- 對時間和空間效率有嚴格要求
- 競賽或需要最優解的場景
- 已經熟悉並能清楚解釋演算法思路

---

## 兩種解法的對比

| 比較項目 | 解法一（排序） | 解法二（分組循環） |
|---------|---------------|------------------|
| **時間複雜度** | O(n log n) | O(n) |
| **空間複雜度** | O(n) | O(1) |
| **理解難度** | ⭐⭐ 簡單 | ⭐⭐⭐⭐ 較難 |
| **實現難度** | ⭐⭐ 簡單 | ⭐⭐⭐ 中等 |
| **程式碼長度** | 較長 | 較短 |
| **除錯難度** | 容易 | 困難 |
| **可讀性** | 高 | 中等 |
| **執行效率** | 中等 | 高 |
| **面試推薦** | ✅ 首選（易解釋） | ⚠️ 進階（需確保能解釋清楚） |

### 效能比較

#### 時間效能
- **小數據集** (n < 1000)：兩種解法差異不大
- **中數據集** (1000 ≤ n < 10000)：解法二略優
- **大數據集** (n ≥ 10000)：解法二明顯優於解法一

#### 空間效能
- **解法一**：需要約 2n 的額外空間（二維陣列 + 標記陣列）
- **解法二**：僅需常數空間

### 選擇建議

#### 選擇解法一的情況：
- 💡 第一次遇到該題目
- 💡 需要快速實現並通過測試
- 💡 程式碼可維護性優先於效能
- 💡 面試場景下，優先展示清晰思路

#### 選擇解法二的情況：
- 🚀 已經理解題目並能清楚解釋演算法
- 🚀 對時間和空間效率有嚴格要求
- 🚀 競賽或 OJ 提交需要最優解
- 🚀 數據規模很大（n > 10^5）

## 使用說明

### 執行環境
- .NET 8.0 或更高版本
- C# 13 特性支援

### 編譯與執行

```bash
# 編譯專案
dotnet build

# 執行程式
dotnet run
```

### 測試案例

程式內建以下測試案例：

1. **基本案例**：`[2,1,3,4,5,2]` → 預期輸出：7
2. **混合案例**：`[2,3,5,1,3,2]` → 預期輸出：5
3. **單一元素**：`[5]` → 預期輸出：5
4. **全部遞減**：`[5,4,3,2,1]` → 預期輸出：6
5. **全部遞增**：`[1,2,3,4,5]` → 預期輸出：9
6. **相同元素**：`[3,3,3,3]` → 預期輸出：6

### 執行結果範例

```
測試案例 1: [2,1,3,4,5,2]
解法一結果: 7
解法二結果: 7
預期結果: 7

測試案例 2: [2,3,5,1,3,2]
解法一結果: 5
解法二結果: 5
預期結果: 5

...
```

## 學習要點

### 解法一教學重點
1. **排序思維**：如何透過排序簡化問題
2. **輔助結構**：使用二維陣列保存額外資訊
3. **狀態追蹤**：利用布林陣列記錄標記狀態
4. **自訂比較器**：實現多條件排序邏輯

### 解法二教學重點
1. **觀察模式**：發現嚴格遞減子段的規律
2. **數學證明**：理解為什麼坡底元素一定可選
3. **一次遍歷**：如何用巧妙的步長避免重複訪問
4. **空間優化**：原地操作不需要額外空間

## 延伸思考

1. **變化 1**：如果改為選擇最大值而不是最小值，演算法如何調整？
2. **變化 2**：如果標記範圍改為左右各 2 個位置，哪種解法更容易修改？
3. **變化 3**：如果需要返回所有被選擇的元素及其順序，該如何實現？
4. **優化思考**：能否結合兩種解法的優點，設計更好的混合演算法？

## 相關題目

- LeetCode 1288: Remove Covered Intervals
- LeetCode 646: Maximum Length of Pair Chain
- LeetCode 435: Non-overlapping Intervals

## 參考資料

- [LeetCode 2593 英文題目](https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/)
- [LeetCode 2593 中文題目](https://leetcode.cn/problems/find-score-of-an-array-after-marking-all-elements/)

---

**提示**：建議先嘗試解法一理解題意，再學習解法二以掌握進階技巧。
