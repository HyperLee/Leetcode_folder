# LeetCode 3719 - 最長平衡子陣列 I

## 題目描述

**難度:** 中等

### 英文描述
You are given an integer array `nums`.

A subarray is called **balanced** if the number of distinct even numbers in the subarray is equal to the number of distinct odd numbers.

Return the length of the longest balanced subarray.

### 繁體中文描述
給定一個整數陣列 `nums`。

若子陣列中**不同的偶數數量**等於**不同的奇數數量**，則稱該子陣列為**平衡**。

回傳最長平衡子陣列的長度。

### 範例

**範例 1:**
```
輸入: nums = [1,2,3,4,5]
輸出: 4
解釋: 最長的平衡子陣列是 [2,3,4,5]。
- 不同的偶數有 2 個: {2, 4}
- 不同的奇數有 2 個: {3, 5}
```

**範例 2:**
```
輸入: nums = [2,4,6,8]
輸出: 0
解釋: 沒有任何平衡的子陣列，因為沒有奇數。
```

**範例 3:**
```
輸入: nums = [1,1,1,3,3,3,2,2]
輸出: 2
解釋: 最長的平衡子陣列是 [1,2] 或 [3,2]。
- 不同的偶數有 1 個: {2}
- 不同的奇數有 1 個: {1} 或 {3}
```

### 限制條件
- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 10^9`

## 解題概念與出發點

### 核心概念

題目的關鍵在於理解「平衡」的定義：
- **不是**計算偶數和奇數的總數量
- **而是**計算不同的偶數種類數和不同的奇數種類數

例如：`[1,1,1,2]` 中
- 不同的奇數: 只有 1 種 (數字 1)
- 不同的偶數: 只有 1 種 (數字 2)
- 即使 1 出現了 3 次，也只算 1 種

### 解題思路

要找最長的平衡子陣列，最直觀的方法是：
1. **枚舉所有可能的子陣列**：使用雙層迴圈遍歷所有區間 `[i, j]`
2. **統計每個子陣列的奇偶數種類**：使用雜湊表 (Dictionary) 記錄出現過的數字
3. **判斷是否平衡**：比較兩個雜湊表的大小 (Count)
4. **更新最大長度**：當找到平衡子陣列時更新答案

### 為什麼使用雜湊表？

- **Dictionary 的 Key 保證唯一性**：自動去重，統計不同數字的種類
- **Count 屬性**：直接獲取不同數字的數量
- **高效查找**：O(1) 時間複雜度

## 演算法詳解

### 暴力法 (Brute Force)

**時間複雜度:** O(n²)  
**空間複雜度:** O(n)

#### 演算法步驟

```
1. 初始化結果變數 len = 0

2. 外層迴圈: 枚舉子陣列的起始位置 i
   - 針對每個 i，建立兩個新的雜湊表:
     * even: 記錄偶數及其出現次數
     * odd: 記錄奇數及其出現次數
   
3. 內層迴圈: 擴展子陣列的結束位置 j (從 i 開始)
   - 判斷 nums[j] 是奇數還是偶數 (使用位元運算 & 1)
   - 將 nums[j] 加入對應的雜湊表
   - 檢查 even.Count == odd.Count
     * 如果相等，更新 len = max(len, j - i + 1)

4. 返回 len
```

#### 關鍵技巧

1. **位元運算判斷奇偶**
   ```csharp
   (nums[j] & 1) == 1  // 奇數
   (nums[j] & 1) == 0  // 偶數
   ```
   優於 `nums[j] % 2`，效能較佳。

2. **雜湊表的重新建立**
   ```csharp
   for(int i = 0; i < nums.Length; i++)
   {
       // 每次固定左端點 i 時，建立新的雜湊表
       Dictionary<int, int> even = new Dictionary<int, int>();
       Dictionary<int, int> odd = new Dictionary<int, int>();
       ...
   }
   ```
   確保每個子陣列的統計結果互不干擾。

3. **動態擴展右端點**
   ```csharp
   for(int j = i; j < nums.Length; j++)
   {
       // 逐步擴展右端點，同時更新雜湊表
   }
   ```
   避免重複計算，提升效率。

## 完整範例演示

### 範例: `nums = [1, 2, 3, 4, 5]`

讓我們逐步追蹤演算法的執行過程：

#### 初始化
- `len = 0`

#### i = 0 (左端點從索引 0 開始)
建立新的 `even` 和 `odd` 字典

| j | nums[j] | odd | even | odd.Count | even.Count | 平衡? | len |
|---|---------|-----|------|-----------|------------|-------|-----|
| 0 | 1 | {1:1} | {} | 1 | 0 | ✗ | 0 |
| 1 | 2 | {1:1} | {2:1} | 1 | 1 | ✓ | 2 |
| 2 | 3 | {1:1, 3:1} | {2:1} | 2 | 1 | ✗ | 2 |
| 3 | 4 | {1:1, 3:1} | {2:1, 4:1} | 2 | 2 | ✓ | 4 |
| 4 | 5 | {1:1, 3:1, 5:1} | {2:1, 4:1} | 3 | 2 | ✗ | 4 |

#### i = 1 (左端點從索引 1 開始)
建立新的 `even` 和 `odd` 字典

| j | nums[j] | odd | even | odd.Count | even.Count | 平衡? | len |
|---|---------|-----|------|-----------|------------|-------|-----|
| 1 | 2 | {} | {2:1} | 0 | 1 | ✗ | 4 |
| 2 | 3 | {3:1} | {2:1} | 1 | 1 | ✓ | 4 |
| 3 | 4 | {3:1} | {2:1, 4:1} | 1 | 2 | ✗ | 4 |
| 4 | 5 | {3:1, 5:1} | {2:1, 4:1} | 2 | 2 | ✓ | 4 |

#### i = 2 (左端點從索引 2 開始)
建立新的 `even` 和 `odd` 字典

| j | nums[j] | odd | even | odd.Count | even.Count | 平衡? | len |
|---|---------|-----|------|-----------|------------|-------|-----|
| 2 | 3 | {3:1} | {} | 1 | 0 | ✗ | 4 |
| 3 | 4 | {3:1} | {4:1} | 1 | 1 | ✓ | 4 |
| 4 | 5 | {3:1, 5:1} | {4:1} | 2 | 1 | ✗ | 4 |

#### i = 3, i = 4
後續的子陣列長度都無法超過已找到的最大值 4。

**最終結果:** `len = 4`

對應的子陣列是 `[2, 3, 4, 5]`：
- 不同的偶數: {2, 4} → 2 種
- 不同的奇數: {3, 5} → 2 種
- 長度: 4

## 專案結構

```
leetcode_3719/
├── leetcode_3719.sln          # 解決方案檔案
├── README.md                   # 本檔案
└── leetcode_3719/
    ├── leetcode_3719.csproj   # 專案檔案
    └── Program.cs             # 主程式碼 (包含解法實作)
```

## 執行方式

### 建構專案
```bash
dotnet build
```

### 執行程式
```bash
dotnet run --project leetcode_3719/leetcode_3719.csproj
```

輸出範例：
```
測試案例 1: [1, 2, 3, 4, 5]
結果: 4

測試案例 2: [2, 4, 6, 8]
結果: 0

測試案例 3: [1, 3, 5, 7, 9]
結果: 0

測試案例 4: [1, 1, 1, 3, 3, 3, 2, 2]
結果: 2

測試案例 5: [4, 5, 6, 7]
結果: 4
```

## 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| **時間複雜度** | O(n²) | 雙層迴圈遍歷所有子陣列 |
| **空間複雜度** | O(n) | 雜湊表最多儲存 n 個不同的數字 |

### 時間複雜度詳解
- 外層迴圈: O(n)
- 內層迴圈: 每次最多執行 O(n) 次
- 雜湊表操作: O(1) (平均情況)
- 總計: O(n) × O(n) = O(n²)

### 空間複雜度詳解
- 兩個雜湊表: 最差情況下各儲存 n/2 個元素
- 總計: O(n)

## 相關題目

- [LeetCode 1. Two Sum](https://leetcode.com/problems/two-sum/) - 使用雜湊表解題
- [LeetCode 560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/) - 子陣列問題
- [LeetCode 525. Contiguous Array](https://leetcode.com/problems/contiguous-array/) - 平衡子陣列概念

## 技術要點

- C# 14 語法特性
- Dictionary 集合操作
- 位元運算最佳化
- 雙指標 / 滑動窗口技巧
- 暴力枚舉優化

## 問題連結

- [LeetCode 英文](https://leetcode.com/problems/longest-balanced-subarray-i/description/?envType=daily-question&envId=2026-02-10)
- [LeetCode 中文](https://leetcode.cn/problems/longest-balanced-subarray-i/description/?envType=daily-question&envId=2026-02-10)

---

**題目編號:** 3719  
**日期:** 2026年2月10日 每日一題
