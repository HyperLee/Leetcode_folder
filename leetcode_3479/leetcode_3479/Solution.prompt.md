
詳細解釋 解法 以及流程

> Copilot: 好的，以下是針對 `NumOfUnplacedFruits` 函式的詳細解法與流程說明：
> 
> ---
> 
> ## 解法核心思路
> 
> 這題目要求將每種水果放入容量足夠的最左邊可用籃子，每個籃子只能用一次，最後統計無法放置的水果種類數量。直接暴力搜尋會超時，因此採用「分塊」優化。
> 
> ### 分塊（Block Decomposition）技巧
> 
> - 將籃子陣列 `baskets` 以分塊方式分組，每塊大小約為 `sqrt(n)`，共 `section` 塊。
> - 每塊維護一個最大值 `maxValues[i]`，代表該塊目前最大可用容量。
> - 對每種水果，先檢查每塊的最大值，若該塊最大值不足則跳過，否則在該塊內線性搜尋最左邊可用籃子。
> 
> ### 流程步驟
> 
> 1. **初始化分塊資訊**
>    - 計算分塊大小 `m = sqrt(n)`，分塊數量 `section = (n + m - 1) / m`。
>    - 建立 `maxValues` 陣列，初始化每塊的最大容量。
> 
> 2. **遍歷每種水果**
>    - 對每個水果數量 `fruit`，依序檢查每個分塊：
>      - 若該塊最大值小於 `fruit`，直接跳過。
>      - 否則在該塊內尋找最左邊可用籃子（容量 >= `fruit` 且尚未被佔用）。
>      - 找到後將該籃子容量設為 0（表示已被佔用），並重新計算該塊最大值。
>      - 若所有分塊都無法放置，則計數器 `count` 加一。
> 
> 3. **回傳結果**
>    - 最後回傳無法放置的水果種類數量。
> 
> ---
> 
> ## 主要優化點
> 
> - **分塊最大值判斷**：先用 `maxValues` 快速排除不可能的分塊，減少不必要的線性搜尋。
> - **只搜尋可能的分塊**：只在最大值足夠的分塊內搜尋，提升效率。
> - **每次放置後即時更新最大值**：確保後續水果判斷正確。
> 
> ---
> 
> ## 流程圖（文字版）
> 
> 1. 初始化分塊資訊
> 2. 對每種水果：
>    - 依序檢查每個分塊
>      - 若最大值不足，跳過
>      - 否則在分塊內找最左邊可用籃子
>        - 找到則佔用並更新最大值
>        - 若所有分塊都無法放置，計數器加一
> 3. 回傳計數器
> 
> ---
> 
> ## 例子說明
> 
> 以範例 `fruits = {2, 3, 5}`，`baskets = {3, 4, 5}`：
> 
> - 2 可放入 3（最左邊可用），3 可放入 4，5 可放入 5，全部都能放置，回傳 0。
> - 若 `baskets = {2, 2, 2}`，則 3、5 都無法放置，回傳 2。
> 
> ---
> 
> ## 時間複雜度分析
> 
> - 分塊大小約為 `sqrt(n)`，每種水果最多搜尋 `sqrt(n)` 個分塊，每塊最多搜尋 `sqrt(n)` 個籃子。
> - 整體複雜度約為 `O(n + m * sqrt(n))`，其中 `m` 為水果種類數量，`n` 為籃子數量。
> 
> ---
> 
> ## 補充
> 
> - 此分塊技巧常用於區間查詢、動態更新等場景，能有效提升效率。
> - 程式碼已依據 C# 12 標準、分塊優化、命名規範、註解完整，易於維護。
> 
> ---
> 
> ```markdown
> - [x] 詳細解釋分塊優化解法與流程
> ```
> 如需更深入的原理圖或效能分析，請告知！
