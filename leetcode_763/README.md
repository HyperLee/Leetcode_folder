# LeetCode 763. Partition Labels

> 將字串劃分為盡可能多的區段，使每個字母最多只出現在一個區段中。

## 題目描述

給定一個只包含小寫英文字母的字串 `s`，將字串劃分為盡可能多的區段，使得**每個字母最多只會出現在一個區段中**。

回傳一個整數串列，表示每個區段的長度。

### 範例

**範例 1：**
```
輸入: s = "ababcbacadefegdehijhklij"
輸出: [9, 7, 8]
說明: 劃分結果為 "ababcbaca", "defegde", "hijhklij"
      每個字母最多只出現在一個區段中。
```

**範例 2：**
```
輸入: s = "eccbbbbdec"
輸出: [10]
說明: 整個字串為一個區段
```

### 限制條件

- `1 <= s.length <= 500`
- `s` 只包含小寫英文字母

---

## 解題思路

### 核心概念

關鍵觀察：**同一個字母的第一次出現和最後一次出現必須在同一個區段內**。

這意味著：
1. 如果我們在位置 `i` 看到字母 `'a'`，而 `'a'` 最後一次出現在位置 `j`
2. 那麼從位置 `i` 到 `j` 的所有字母都必須在同一個區段中
3. 但在這個範圍內可能遇到其他字母，它們的最後出現位置可能更靠後，因此需要延伸區段

### 貪心策略

使用**貪心演算法**尋找每個區段可能的**最小結束位置**：

1. **預處理**：遍歷字串，記錄每個字母最後一次出現的位置
2. **劃分區段**：
   - 維護當前區段的起始位置 `start` 和結束位置 `end`
   - 遍歷過程中，不斷更新 `end` 為目前所遇字母最後出現位置的最大值
   - 當遍歷位置等於 `end` 時，表示當前區段內所有字母都不會再出現，可以結束該區段

### 為什麼這是正確的？

- 每次取的都是**符合要求的最短區段**
- 如果取更短的區段，必然會有字母同時出現在多個區段中
- 因為每個區段都是最短的，所以得到的區段數量是最多的

---

## 演算法步驟

```
步驟 1：建立 lastIndex 陣列，記錄每個字母最後出現的位置
步驟 2：初始化 start = 0, end = 0
步驟 3：遍歷字串中的每個字母
        - 更新 end = max(end, 該字母的最後出現位置)
        - 若當前位置 == end，則：
          - 記錄區段長度 (end - start + 1)
          - 設定 start = end + 1，開始下一個區段
步驟 4：回傳所有區段長度
```

---

## 範例演示

以 `s = "ababcbacadefegdehijhklij"` 為例：

### 步驟 1：建立 lastIndex

| 字母 | a | b | c | d | e | f | g | h | i | j | k | l |
|:----:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 最後位置 | 8 | 5 | 7 | 14 | 15 | 11 | 13 | 19 | 22 | 23 | 20 | 21 |

### 步驟 2：遍歷劃分

```
位置  字母  lastIndex[字母]  end 更新      動作
────────────────────────────────────────────────────
 0    'a'       8           end = 8       繼續
 1    'b'       5           end = 8       繼續
 2    'a'       8           end = 8       繼續
 3    'b'       5           end = 8       繼續
 4    'c'       7           end = 8       繼續
 5    'b'       5           end = 8       繼續
 6    'a'       8           end = 8       繼續
 7    'c'       7           end = 8       繼續
 8    'a'       8           end = 8       j == end → 記錄長度 9，start = 9
────────────────────────────────────────────────────
 9    'd'      14           end = 14      繼續
10    'e'      15           end = 15      繼續
11    'f'      11           end = 15      繼續
12    'e'      15           end = 15      繼續
13    'g'      13           end = 15      繼續
14    'd'      14           end = 15      繼續
15    'e'      15           end = 15      j == end → 記錄長度 7，start = 16
────────────────────────────────────────────────────
16    'h'      19           end = 19      繼續
17    'i'      22           end = 22      繼續
18    'j'      23           end = 23      繼續
19    'h'      19           end = 23      繼續
20    'k'      20           end = 23      繼續
21    'l'      21           end = 23      繼續
22    'i'      22           end = 23      繼續
23    'j'      23           end = 23      j == end → 記錄長度 8，start = 24
```

### 結果

```
區段 1: "ababcbaca"  (位置 0-8)  → 長度 9
區段 2: "defegde"    (位置 9-15) → 長度 7
區段 3: "hijhklij"   (位置 16-23)→ 長度 8

輸出: [9, 7, 8]
```

---

## 複雜度分析

| 複雜度 | 值 | 說明 |
|:------:|:--:|:-----|
| 時間複雜度 | O(n) | 遍歷字串兩次：一次建立 lastIndex，一次劃分區段 |
| 空間複雜度 | O(1) | 只使用固定大小的陣列（26 個字母） |

---

## 執行方式

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run --project leetcode_763
```

---

## 技術棧

- .NET 10
- C# 14
