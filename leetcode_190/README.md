# LeetCode 190. Reverse Bits（顛倒二進位位元）

> **難度：** Easy
> **標籤：** Bit Manipulation, Divide and Conquer
> **日期：** 2026-02-16 Daily Question

## 題目描述

給定一個 **32 位元有號整數**，將其二進位位元全部顛倒。

| 範例 | 輸入 (二進位) | 輸出 (十進位) | 輸出 (二進位) |
|------|--------------|--------------|--------------|
| 1 | `00000010100101000001111010011100` | 964176192 | `00111001011110000010100101000000` |
| 2 | `11111111111111111111111111111101` | -1073741825 | `10111111111111111111111111111111` |

**題目連結：**
- [LeetCode (EN)](https://leetcode.com/problems/reverse-bits/description/)
- [LeetCode (CN)](https://leetcode.cn/problems/reverse-bits/description/)

---

## 三種解題概念與出發點

本專案實作了三種不同思路的解法，從最直覺到最高效：

| # | 解法 | 核心概念 | 時間複雜度 | 出發點 |
|---|------|---------|-----------|--------|
| 1 | 逐位元取出並反轉 | 迴圈 + 位元運算 | O(32) | 最直覺：像十進位「取餘 → 組合 → 整除」一樣逐位元搬移 |
| 2 | 逐位元直接定位 | 迴圈 + 位移定位 | O(32)，可提前結束 | 改良思路：直接計算目標位置，免去堆疊式左移 |
| 3 | 分治法位元交換 | Divide & Conquer + Bitmask | O(1)，固定 5 次運算 | 最優解：利用分治思想，五步完成所有位元的翻轉 |

---

## 解法一：逐位元取出並反轉

### 概念

類似十進位中「先取 `%` 取出資料，再用 `/` 取下一位」的思路，只不過這裡是在二進位上操作。

每次從原數 `n` 的最低位元取出一個位元，放到結果 `result` 的最低位元，然後將 `result` 左移騰出空間、`n` 右移以處理下一位。重複 32 次後，原數的最低位元就跑到了結果的最高位元。

### 程式碼

```csharp
public int ReverseBits(int n)
{
    int result = 0;
    for (int i = 0; i < 32; i++)
    {
        result <<= 1;       // 左移一位，為新位元騰出空間
        result |= (n & 1);  // 取出 n 的最低位元，放入 result
        n >>= 1;             // n 右移一位，處理下一位
    }
    return result;
}
```

### 流程演示

以 `n = 1`（二進位 `00000000000000000000000000000001`）為例：

```
迭代 i=0:
  result = 0  <<1 → 0
  n & 1 = 1   → result |= 1 → result = 1
  n >>= 1     → n = 0

迭代 i=1:
  result = 1  <<1 → 2  (二進位 10)
  n & 1 = 0   → result |= 0 → result = 2
  n >>= 1     → n = 0

迭代 i=2 ~ i=31:
  每次 result 繼續左移，n & 1 始終為 0
  result 不斷左移，最終：

result = 10000000000000000000000000000000 (-2147483648)
```

---

## 解法二：逐位元直接定位目標位置

### 概念

與解法一同為逐位元處理，但思路不同：**直接計算每個位元在結果中的目標位置**。

原數的第 `i` 位元（從最低位算起），在結果中應該出現在第 `31 - i` 位。因此每次取出 `n & 1` 後，直接左移 `31 - i` 位放到正確位置，用 `|=` 合併到結果中。

另一個改良點：當 `n` 變為 0 時提前結束迴圈（剩餘位元全為 0，無需處理）。

### 程式碼

```csharp
public int ReverseBits2(int n)
{
    int result = 0;
    for (int i = 0; i < 32 && n != 0; i++)
    {
        result |= (n & 1) << (31 - i);  // 直接定位到目標位置
        n >>= 1;                          // 處理下一位
    }
    return result;
}
```

### 流程演示

以 `n = 43261596`（二進位 `00000010100101000001111010011100`）為例：

```
i=0:  n & 1 = 0 → 不影響 result, n 右移
i=1:  n & 1 = 0 → 不影響 result, n 右移
i=2:  n & 1 = 1 → result |= 1 << 29 → result 的第 29 位元被設為 1
i=3:  n & 1 = 1 → result |= 1 << 28
i=4:  n & 1 = 1 → result |= 1 << 27
i=5:  n & 1 = 0 → 不影響
...持續處理每一位...
i=25: n & 1 = 1 → result |= 1 << 6 (最後一個有效位元)
      n 右移後變為 0 → 迴圈提前結束！

最終結果: 964176192 (00111001011110000010100101000000)
```

> [!TIP]
> 當輸入值的高位元很多 0 時，解法二可以提前結束，實際效能優於解法一。

---

## 解法三：分治法位元交換

### 概念

利用 **分治法（Divide and Conquer）** 的思想：要翻轉一個 32 位元的數，可以先在最小粒度（相鄰 1 位元）交換，逐層擴大交換範圍，共五步即可完成整個翻轉。

想像用字母表示每個位元位置 `abcdefgh`（以 8 位元簡化說明）：

```
原始:                        abcdefgh
Step 1 交換相鄰 1 位元:      badcfehg
Step 2 交換相鄰 2 位元組:     dcbahgfe
Step 3 交換相鄰 4 位元組:     hgfedcba  ✓ 完成！
```

對於 32 位元，需要五步（1 → 2 → 4 → 8 → 16）。每一步使用位元遮罩 (mask) 分離出需要交換的位元群組，再透過位移和 OR 操作完成交換。

### 位元遮罩說明

| 遮罩 | 十六進位 | 二進位模式 | 用途 |
|------|---------|-----------|------|
| M1 | `0x55555555` | `01010101...` | 分離奇偶位元 |
| M2 | `0x33333333` | `00110011...` | 分離 2 位元組 |
| M4 | `0x0f0f0f0f` | `00001111...` | 分離 4 位元組 |
| M8 | `0x00ff00ff` | `0000000011111111...` | 分離 8 位元組 |

### 程式碼

```csharp
private const int M1 = 0x55555555;
private const int M2 = 0x33333333;
private const int M4 = 0x0f0f0f0f;
private const int M8 = 0x00ff00ff;

public int ReverseBits3(int n)
{
    int result = n;
    result = ((int)((uint)result >> 1) & M1) | ((result & M1) << 1);   // 交換相鄰 1 位元
    result = ((int)((uint)result >> 2) & M2) | ((result & M2) << 2);   // 交換相鄰 2 位元
    result = ((int)((uint)result >> 4) & M4) | ((result & M4) << 4);   // 交換相鄰 4 位元
    result = ((int)((uint)result >> 8) & M8) | ((result & M8) << 8);   // 交換相鄰 8 位元
    return (int)((uint)result >> 16) | (result << 16);                  // 交換高低 16 位元
}
```

### 流程演示

以 `n = 1`（二進位 `00000000000000000000000000000001`）為例：

```
原始:   00000000 00000000 00000000 00000001

Step 1 (交換相鄰 1 位元):
        00000000 00000000 00000000 00000010

Step 2 (交換相鄰 2 位元):
        00000000 00000000 00000000 00001000

Step 3 (交換相鄰 4 位元):
        00000000 00000000 00000000 10000000

Step 4 (交換相鄰 8 位元):
        00000000 00000000 10000000 00000000

Step 5 (交換高低 16 位元):
        10000000 00000000 00000000 00000000

結果: 10000000000000000000000000000000 (-2147483648) ✓
```

> [!NOTE]
> 在 C# 中，`int` 是有號整數，右移 (`>>`) 會進行算術右移（保留符號位元）。因此程式碼中使用 `(uint)` 強制轉型來實現邏輯右移（補 0），避免符號位元擴展導致錯誤。

---

## 快速開始

### 前置需求

- [.NET 10 SDK](https://dotnet.microsoft.com/download)

### 執行

```bash
dotnet run --project leetcode_190/leetcode_190.csproj
```

### 建構

```bash
dotnet build leetcode_190/leetcode_190.csproj
```

---

## 專案結構

```
leetcode_190/
├── leetcode_190.slnx           # Solution 檔案
├── README.md                   # 本文件
└── leetcode_190/
    ├── leetcode_190.csproj     # 專案檔 (.NET 10)
    └── Program.cs              # 主程式（含三種解法實作）
```
