# 3228. Maximum Number of Operations to Move Ones to the End

## 題目 (來源)

- **LeetCode 題號**：3228
- **題目連結**：[Maximum Number of Operations to Move Ones to the End](https://leetcode.cn/problems/maximum-number-of-operations-to-move-ones-to-the-end/)

## 問題描述

輸入一個只包含 `'0'` 與 `'1'` 的二元字串 `s`，每次操作可以選擇一個 `'1'` 與其右側相鄰的 `'0'` 交換位置。求將所有 `'1'` 移動到字串末端所能執行的最大操作次數。

**本專案提供兩種解法**：
- `MaxOperations(string s)`：解法一（連續零段跳過法）
- `MaxOperations2(string s)`：解法二（1→0 轉換偵測法）

---

## 解法一：MaxOperations（連續零段跳過法）

### 核心想法

從左到右掃描字串，維護已遇到的 `'1'` 數量（記為 `onesCount`）。每當遇到一段連續的零（zero segment），該零段可以讓它左側每個 `'1'` 各執行一次向右移動操作。因此，對每一段連續零，把目前的 `onesCount` 累加到結果 `operations` 中。

這是一個**貪心 + 計數策略**：一次掃描即可得到最大操作次數。

### 演算法流程

1. 初始化：`onesCount = 0`、`operations = 0`、`index = 0`
2. 當 `index < s.Length` 時：
   - 若 `s[index] == '0'`：
     - 使用內層迴圈跳過整段連續的 `'0'`（移動 `index` 至該零段的最後一個 `'0'`）
     - 累加操作數：`operations += onesCount`
   - 否則（`s[index] == '1'`）：
     - 增加 `'1'` 計數：`onesCount++`
   - 移動至下一個字元：`index++`
3. 回傳 `operations`

### 為何貪心是正確的

- 對任一連續零段，其能提供的最大操作數不可能超過「該段左側的 `'1'` 數量」
- 整體上界為對所有零段求左側 `'1'` 數量之和
- 採用從左到右累計 `onesCount` 並在遇到每個零段時計入，恰好達到上述上界，故為最優
- 補充：若有非貪心的操作分配，可透過交換論證將操作重新分配給更左側的 `'1'` 而不降低總數

### 時間與空間複雜度

- **時間複雜度**：O(n)，其中 n = `s.Length`。雖然有內層迴圈跳過零段，但每個字元最多被訪問一次
- **額外空間**：O(1)，僅使用少量整數變數

### 詳細範例

**範例 A：`"010010"`**

| 步驟 | index | 字元 | 動作 | onesCount | operations |
|------|-------|------|------|-----------|------------|
| 初始 | 0 | - | - | 0 | 0 |
| 0 | 0 | '0' | 零段（長度1），累加 | 0 | 0 |
| 1 | 1 | '1' | 增加計數 | 1 | 0 |
| 2 | 2 | '0' | 零段開始，跳到 index=3 | 1 | - |
| 2續 | 3 | '0' | 零段結束，累加 | 1 | 1 |
| 3 | 4 | '1' | 增加計數 | 2 | 1 |
| 4 | 5 | '0' | 零段（長度1），累加 | 2 | 3 |
| 結束 | 6 | - | - | 2 | **3** |

**範例 B：`"101010"`**

| 步驟 | index | 字元 | 動作 | onesCount | operations |
|------|-------|------|------|-----------|------------|
| 初始 | 0 | - | - | 0 | 0 |
| 0 | 0 | '1' | 增加計數 | 1 | 0 |
| 1 | 1 | '0' | 零段（長度1），累加 | 1 | 1 |
| 2 | 2 | '1' | 增加計數 | 2 | 1 |
| 3 | 3 | '0' | 零段（長度1），累加 | 2 | 3 |
| 4 | 4 | '1' | 增加計數 | 3 | 3 |
| 5 | 5 | '0' | 零段（長度1），累加 | 3 | 6 |
| 結束 | 6 | - | - | 3 | **6** |

---

## 解法二：MaxOperations2（1→0 轉換偵測法）

### 核心想法

透過偵測字元由 `'1'` 轉換為 `'0'` 的位置來辨識零段的起點。掃描字串並維護一個計數器 `onesSeen`（表示至目前位置為止已見的 `'1'` 數量）。當遇到字元為 `'0'` 且其前一字元為 `'1'` 時，代表找到一段連續零的開頭，此時將 `onesSeen` 累加到答案中。

### 演算法流程

1. 將字串轉為字元陣列：`chars = s.ToCharArray()`
2. 初始化：`operations2 = 0`、`onesSeen = 0`
3. 對每個索引 `i` 從 0 到 `chars.Length - 1`：
   - 若 `chars[i] == '1'`：
     - 增加 `'1'` 計數：`onesSeen++`
   - 否則若 `chars[i] == '0'` 且 `i > 0` 且 `chars[i-1] == '1'`：
     - 偵測到零段開始（1→0 轉換），累加：`operations2 += onesSeen`
4. 回傳 `operations2`

### 時間與空間複雜度

- **時間複雜度**：O(n)，對字串做一次線性掃描
- **額外空間**：O(n)，因使用 `ToCharArray()`。若改為直接以 `s[i]` 存取，可降為 O(1)

### 詳細範例

**範例 A：`"010010"`**

| 步驟 | i | 字元 | 前一字元 | 動作 | onesSeen | operations2 |
|------|---|------|----------|------|----------|-------------|
| 初始 | - | - | - | - | 0 | 0 |
| 0 | 0 | '0' | 無 | 不處理 | 0 | 0 |
| 1 | 1 | '1' | '0' | 增加計數 | 1 | 0 |
| 2 | 2 | '0' | '1' | 零段開始，累加 | 1 | 1 |
| 3 | 3 | '0' | '0' | 同一零段，不處理 | 1 | 1 |
| 4 | 4 | '1' | '0' | 增加計數 | 2 | 1 |
| 5 | 5 | '0' | '1' | 零段開始，累加 | 2 | 3 |
| 結束 | - | - | - | - | 2 | **3** |

**範例 B：`"101010"`**

| 步驟 | i | 字元 | 前一字元 | 動作 | onesSeen | operations2 |
|------|---|------|----------|------|----------|-------------|
| 初始 | - | - | - | - | 0 | 0 |
| 0 | 0 | '1' | 無 | 增加計數 | 1 | 0 |
| 1 | 1 | '0' | '1' | 零段開始，累加 | 1 | 1 |
| 2 | 2 | '1' | '0' | 增加計數 | 2 | 1 |
| 3 | 3 | '0' | '1' | 零段開始，累加 | 2 | 3 |
| 4 | 4 | '1' | '0' | 增加計數 | 3 | 3 |
| 5 | 5 | '0' | '1' | 零段開始，累加 | 3 | 6 |
| 結束 | - | - | - | - | 3 | **6** |

---

## 兩種解法比較

| 比較項目 | 解法一（MaxOperations） | 解法二（MaxOperations2） |
|---------|------------------------|-------------------------|
| **核心策略** | 跳過連續零段，在段尾累加 | 偵測 1→0 轉換點累加 |
| **程式碼複雜度** | 較複雜（需內層迴圈跳過） | 較簡潔（單一迴圈） |
| **時間複雜度** | O(n) | O(n) |
| **額外空間** | O(1) | O(n)（若用 `ToCharArray()`）<br>O(1)（若直接索引） |
| **可讀性** | 明確表達「零段」概念 | 轉換偵測較抽象 |
| **邊界處理** | 有 null 檢查 | 需補充 null 檢查 |
| **適用場景** | 適合理解「零段」邏輯的情境 | 適合需要簡潔程式碼的情境 |

### 邏輯等價性

兩種解法在邏輯上**完全等價**：
- **解法一**：明確把連續零當成一個單位，在零段末尾一次性累加左側所有 `'1'`
- **解法二**：在每個零段的「第一個 `'0'`」處（透過偵測 1→0 轉換）累加左側所有 `'1'`

兩者都確保每段連續零只被計算一次，且都累加相同的 `'1'` 數量。

---

## 邊界情況與函式行為

兩種解法對以下情況的處理：

| 輸入 | 預期結果 | 說明 |
|------|---------|------|
| `null` | 解法一：拋出 `ArgumentNullException`<br>解法二：`NullReferenceException` | 建議解法二加入 null 檢查 |
| `""` | `0` | 空字串無操作 |
| `"0"` | `0` | 無 `'1'` 可移動 |
| `"1"` | `0` | 無 `'0'` 可交換 |
| `"000"` | `0` | 全為 `'0'` |
| `"111"` | `0` | 全為 `'1'`，已在末端 |
| `"10"` | `1` | 一個 `'1'` 移過一個 `'0'` |
| `"0011"` | `0` | `'1'` 已在末端 |
| `"101010"` | `6` | 交替字元最大化操作數 |

### 非法字元處理

- **解法一**：將非 `'0'` 字元視為 `'1'`（在 `else` 分支）
- **解法二**：同樣將非 `'0'` 字元視為 `'1'`
- **建議**：若輸入可能包含非法字元，應在函式開頭加入驗證並拋出 `ArgumentException`

---

## 執行說明

專案入口為 `leetcode_3228/leetcode_3228/Program.cs`，包含多組測試案例。

### 在 macOS（zsh）下執行

```bash
dotnet run --project leetcode_3228/leetcode_3228.csproj
```

### 測試輸出範例

```
s = "010010", MaxOperations = 3, MaxOperations2 = 3
s = "0", MaxOperations = 0, MaxOperations2 = 0
s = "1", MaxOperations = 0, MaxOperations2 = 0
s = "10", MaxOperations = 1, MaxOperations2 = 1
s = "01", MaxOperations = 0, MaxOperations2 = 0
s = "0011", MaxOperations = 0, MaxOperations2 = 0
s = "", MaxOperations = 0, MaxOperations2 = 0
s = "101010", MaxOperations = 6, MaxOperations2 = 6
```

---

## 改進建議

### 共同改進

1. **輸入驗證**：
   ```csharp
   if (s is null) throw new ArgumentNullException(nameof(s));
   if (s.Any(c => c != '0' && c != '1')) 
       throw new ArgumentException("輸入字串只能包含 '0' 與 '1'", nameof(s));
   ```

2. **避免整數溢位**：
   - 將 `operations`、`onesCount`、`onesSeen` 改用 `long`
   - 或在回傳前檢查是否超出 `int.MaxValue`

3. **變數命名優化**：
   - `onesCount` → `onesSeen` 或 `onesBefore`
   - `operations` → `maxOperations`

### 解法二特定改進

4. **空間優化**：
   ```csharp
   // 移除 ToCharArray()，直接使用字串索引
   for (int i = 0; i < s.Length; i++)
   {
       if (s[i] == '1') { ... }
       else if (i > 0 && s[i - 1] == '1') { ... }
   }
   ```
   此改進可將額外空間從 O(n) 降為 O(1)。

---

## 總結

兩種解法都能正確且高效地解決問題，時間複雜度均為 O(n)：
- **解法一**適合需要明確表達「零段」概念的場景，程式碼邏輯清晰
- **解法二**程式碼更精簡，但需注意空間使用與邊界處理

選擇哪種解法取決於對可讀性、空間效率的偏好，以及團隊的程式碼風格規範。

