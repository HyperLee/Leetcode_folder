# LeetCode 3370: 僅含置位位的最小整數

> 尋找大於等於 n 且二進位表示全為 1 的最小整數

## 題目描述

### 問題定義

給定一個正整數 `n`,回傳最小的整數 `x`(其中 `x >= n`),使得 `x` 的二進位表示中**只含有置位**(即所有位元均為 1)。

### 什麼是「置位」(Set Bits)?

在電腦科學中,**置位**(Set Bit)指的是二進位表示中值為 **1** 的位元。相對地,值為 **0** 的位元稱為**未置位**(Unset Bit 或 Clear Bit)。

**範例說明:**

- 數字 `5` 的二進位表示為 `101`
  - 第 0 位和第 2 位是置位(值為 1)
  - 第 1 位是未置位(值為 0)
- 數字 `7` 的二進位表示為 `111`
  - 所有 3 個位元都是置位(全為 1)

本題要求找到的數字,其二進位表示必須**全部都是置位**,也就是形如 `1`、`11`、`111`、`1111`... 這樣的數字。

### 問題範例

| 輸入 n | n 的二進位 | 輸出 x | x 的二進位 | 說明 |
|--------|-----------|--------|-----------|------|
| 5 | `101` | 7 | `111` | 7 是第一個 >= 5 且全為 1 的數 |
| 10 | `1010` | 15 | `1111` | 15 是第一個 >= 10 且全為 1 的數 |
| 3 | `11` | 3 | `11` | 3 本身就全為 1 |
| 8 | `1000` | 15 | `1111` | 需要 4 個位元才能 >= 8 |

### LeetCode 連結

- [英文版題目](https://leetcode.com/problems/smallest-number-with-all-set-bits/description/?envType=daily-question&envId=2025-10-29)
- [中文版題目](https://leetcode.cn/problems/smallest-number-with-all-set-bits/description/?envType=daily-question&envId=2025-10-29)

## 解法說明

本專案提供兩種解法,都能高效解決此問題。

### 方法一:找規律(迭代法)

#### 核心思想

觀察僅含置位位的整數序列: **1, 3, 7, 15, 31, 63, 127, ...**

對應的二進位表示為:

- `1` = 2¹ - 1
- `11` = 2² - 1
- `111` = 2³ - 1
- `1111` = 2⁴ - 1
- `11111` = 2⁵ - 1

**規律發現**: 每個數字都可以通過前一個數字計算得出:

```text
x_{k+1} = x_k × 2 + 1
```

這個遞推公式在二進位運算上相當於**在右側新增一個 1 位元**。

#### 演算法步驟

1. 初始化 `x = 1`(第一個僅含置位位的整數)
2. 當 `x < n` 時,重複執行 `x = x × 2 + 1`
3. 當 `x >= n` 時,回傳 `x`

#### 範例追蹤

以 `n = 10` 為例:

```text
初始: x = 1 (0b1)
x < 10, x = 1 × 2 + 1 = 3 (0b11)
x < 10, x = 3 × 2 + 1 = 7 (0b111)
x < 10, x = 7 × 2 + 1 = 15 (0b1111)
x >= 10, 回傳 15
```

#### 程式碼實作

```csharp
public int SmallestNumber(int n)
{
    int x = 1;
    while (x < n)
    {
        x = x * 2 + 1;  // 等價於 (x << 1) | 1
    }
    return x;
}
```

#### 複雜度分析

- **時間複雜度**: O(log n)
  - `x` 以指數速度增長(每次迭代翻倍),因此迴圈次數為 O(log n)
- **空間複雜度**: O(1)
  - 只使用常數個變數

---

### 方法二:位元長度計算法(直接計算)

#### 解法思路

**關鍵觀察**: 如果 `n` 的二進位長度為 `m`,那麼答案就是長度為 `m` 的全 1 二進位數。

為什麼?因為:

1. 答案必須 >= n,所以至少需要 `m` 個位元
2. 長度為 `m` 的全 1 數(即 `2^m - 1`)必定 >= 任何 `m` 位元的數
3. 因此答案的二進位長度就是 `m`

#### 數學公式

```text
答案 = 2^m - 1
```

其中 `m` 是 `n` 的二進位長度。

#### 位元運算解釋

`(1 << m) - 1` 的運作原理:

1. `1 << m`: 將 1 左移 m 位,得到 `10...0`(1 後面跟 m 個 0)
2. 減 1: `10...0 - 1 = 11...1`(m 個 1)

**視覺化範例**:

```text
m = 4
1 << 4  = 10000 (十進位: 16)
16 - 1  =  1111 (十進位: 15)
```

#### 實作程式碼

```csharp
public int SmallestNumber2(int n)
{
    int bitLength = Convert.ToString(n, 2).Length;
    return (1 << bitLength) - 1;
}
```

#### 效能分析

- **時間複雜度**: O(log n)
  - 計算二進位長度需要 O(log n)
- **空間複雜度**: O(log n)
  - `Convert.ToString` 需要建立長度為 log n 的字串

---

## 兩種方法比較

| 比較項目 | 方法一:找規律 | 方法二:位元長度計算 |
|---------|-------------|------------------|
| **演算法類型** | 迭代法 | 直接計算法 |
| **核心概念** | 遞推生成序列 | 數學公式 2^m - 1 |
| **時間複雜度** | O(log n) | O(log n) |
| **空間複雜度** | O(1) | O(log n) |
| **程式碼行數** | 較多(需迴圈) | 較少(兩行) |
| **可讀性** | 清楚展示規律 | 需理解位元運算 |
| **效能** | 稍快(無字串操作) | 稍慢(有字串轉換) |
| **優點** | 空間效率高,無額外記憶體 | 程式碼簡潔,直觀 |
| **缺點** | 需要迴圈迭代 | 需要字串轉換 |

### 建議使用場景

- **方法一**(找規律):
  - 追求極致效能和空間效率
  - 希望避免字串操作
  - 程式碼清晰度優先

- **方法二**(位元長度計算):
  - 追求程式碼簡潔性
  - 熟悉位元運算和數學公式
  - 對記憶體開銷不敏感

> **實務建議**: 兩種方法的時間複雜度相同,都是最優解。在實際應用中,方法一因為空間複雜度為 O(1) 且無字串操作,通常會略快一些。但方法二更簡潔,在理解原理後更容易記憶和實作。

## 快速開始

### 環境需求

- .NET 8.0 或更高版本
- C# 13

### 執行程式

```bash
# 複製專案
cd leetcode_3370

# 建構專案
dotnet build

# 執行程式(包含測試案例)
dotnet run
```

### 預期輸出

```text
=== LeetCode 3370: 僅含置位位的最小整數 ===

輸入: n = 5
  二進位表示: 101
  方法一(找規律)結果: 7 (二進位: 111)
  方法二(位元長度)結果: 7 (二進位: 111)
  結果是否一致: ✓

輸入: n = 10
  二進位表示: 1010
  方法一(找規律)結果: 15 (二進位: 1111)
  方法二(位元長度)結果: 15 (二進位: 1111)
  結果是否一致: ✓
...
```

## 專案結構

```text
leetcode_3370/
├── leetcode_3370.sln          # Visual Studio 解決方案檔案
├── README.md                   # 本文件
└── leetcode_3370/
    ├── leetcode_3370.csproj   # 專案檔案
    └── Program.cs              # 主程式(包含兩種解法)
```

## 核心概念

### 二進位基礎

理解本題需要掌握以下二進位概念:

1. **二進位表示**: 任何正整數都可以用 0 和 1 表示
   - 十進位 5 = 二進位 101
   - 十進位 7 = 二進位 111

2. **位元運算**:
   - `<<` (左移): `1 << 3 = 1000` (相當於 × 2³)
   - `|` (OR): `110 | 001 = 111`
   - `× 2 + 1`: 等價於 `(x << 1) | 1`

3. **2 的冪次**:
   - 2¹ = 2 = `10`
   - 2² = 4 = `100`
   - 2³ = 8 = `1000`
   - 2^n - 1 總是 n 個 1: `111...1`

### 數列規律

僅含置位位的整數形成一個特殊數列:

- **十進位**: 1, 3, 7, 15, 31, 63, 127, 255, ...
- **二進位**: 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, ...
- **公式**: a_n = 2^n - 1 (n >= 1)
- **遞推**: a_{n+1} = a_n × 2 + 1

這個數列也稱為**梅森數**(Mersenne numbers)的一部分。

## 延伸思考

### 相關問題

1. 如果要找**至多 k 個置位**的最小數字呢?
2. 如何快速計算一個數字有多少個置位?(Hamming Weight 問題)
3. 如何翻轉特定位元的狀態?

### 位元操作技巧

```csharp
// 計算 n 的二進位長度(不使用字串)
int bitLength = (int)Math.Floor(Math.Log2(n)) + 1;

// 檢查 n 是否全為 1(即是否為 2^k - 1)
bool isAllOnes = (n & (n + 1)) == 0;

// 取得 n 的最高位元
int highestBit = 1 << (bitLength - 1);
```

## 技術重點

- ✅ C# 13 最新特性
- ✅ 清晰的 XML 文件註解
- ✅ 完整的演算法說明
- ✅ 時間和空間複雜度分析
- ✅ 多組測試案例驗證
- ✅ 位元運算最佳實踐

## 參考資源

- [二進位運算基礎](https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C)
- [梅森數](https://zh.wikipedia.org/wiki/%E6%A2%85%E6%A3%AE%E7%B4%A0%E6%95%B0)
- [C# 位元運算子](https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators)

---

**Daily Challenge Date**: 2025-10-29  
**Difficulty**: Easy  
**Topics**: Bit Manipulation, Math
