# LeetCode 1200 - Minimum Absolute Difference

> 最小絕對差 | 排序 + 一次遍歷解法

[![.NET](https://img.shields.io/badge/.NET-10.0-512BD4?style=flat-square)](https://dotnet.microsoft.com/)
[![C#](https://img.shields.io/badge/C%23-14-239120?style=flat-square)](https://docs.microsoft.com/dotnet/csharp/)
[![LeetCode](https://img.shields.io/badge/LeetCode-1200-FFA116?style=flat-square)](https://leetcode.com/problems/minimum-absolute-difference/)

## 📋 題目描述

給定一個由**互不相同**的整數所組成的陣列 `arr`，找出所有具有**最小絕對差**的元素對。

回傳一個以對為單位、以升冪排序的清單。每個對 `[a, b]` 必須滿足：

- `a` 與 `b` 來自 `arr`
- `a < b`
- `b - a` 等於陣列中任兩元素的最小絕對差

### 範例

**範例 1：**
```
輸入: arr = [4, 2, 1, 3]
輸出: [[1,2], [2,3], [3,4]]
解釋: 最小絕對差為 1，所有相鄰元素對的差都是 1。
```

**範例 2：**
```
輸入: arr = [1, 3, 6, 10, 15]
輸出: [[1,3]]
解釋: 最小絕對差為 2，只有 (1,3) 這一對。
```

**範例 3：**
```
輸入: arr = [3, 8, -10, 23, 19, -4, -14, 27]
輸出: [[-14,-10], [19,23], [23,27]]
解釋: 最小絕對差為 4。
```

### 限制條件

- `2 <= arr.length <= 10^5`
- `-10^6 <= arr[i] <= 10^6`

---

## 💡 解題概念與出發點

### 核心觀察

要找出所有最小絕對差的元素對，最直觀的方法是比較所有可能的元素對，但這會導致 O(n²) 的時間複雜度。

**關鍵洞察：** 如果我們先將陣列排序，那麼具有最小絕對差的元素對**一定是相鄰的兩個元素**。

為什麼？因為對於排序後的陣列：
- 若 `arr[i] < arr[j] < arr[k]`
- 則 `arr[k] - arr[i] = (arr[k] - arr[j]) + (arr[j] - arr[i])`
- 所以 `arr[k] - arr[i]` 一定大於等於 `arr[j] - arr[i]`

這意味著我們只需要檢查相鄰元素！

---

## 🔧 解法說明

### 方法一：排序 + 一次遍歷（原始解法）

#### 核心思路

此方法利用「排序後最小差值必定出現在相鄰元素」的特性，在一次遍歷中同時找出最小差值並收集符合條件的元素對。當遇到更小的差值時，會清空先前的結果重新收集。

#### 演算法步驟

1. **排序陣列**：將 `arr` 進行升冪排序
2. **初始化**：設定 `minDiff = int.MaxValue`，建立空的結果清單
3. **遍歷相鄰元素**：計算每對相鄰元素的差值 δ
4. **維護最小差值**：
   - 若 `δ < minDiff`：更新 `minDiff`，清空結果，加入新的元素對
   - 若 `δ == minDiff`：直接將元素對加入結果
   - 若 `δ > minDiff`：跳過此元素對

#### 虛擬碼

```
function MinimumAbsDifference(arr):
    Sort(arr)
    minDiff = INT_MAX
    result = empty list
    
    for i = 0 to length(arr) - 2:
        diff = arr[i + 1] - arr[i]
        
        if diff < minDiff:
            minDiff = diff
            result.Clear()           // 清空先前結果
            result.Add([arr[i], arr[i + 1]])
        else if diff == minDiff:
            result.Add([arr[i], arr[i + 1]])
    
    return result
```

#### 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n log n) | 排序為主要開銷，遍歷為 O(n) |
| 空間複雜度 | O(log n) | 排序所需的堆疊空間（不含輸出） |

#### 優點與缺點

| 優點 | 缺點 |
|------|------|
| ✅ 只需一次遍歷即可完成 | ❌ 遇到更小差值時需執行 `Clear()` 操作 |
| ✅ 程式碼簡潔易懂 | ❌ `Clear()` 在最壞情況下可能影響效能 |
| ✅ 適合大多數場景 | |

#### 關鍵實作細節

- **為什麼用 `int.MaxValue`？** 確保第一個差值一定會觸發更新
- **`Clear()` 的影響**：若陣列是 `[1, 100, 101, 102, 103]`，會先收集 `[1, 100]`，遇到差值 1 時清空並重新收集

---

### 方法二：計數排序 (Counting Sort)

#### 核心思路

不使用比較排序，而是建立一個布林陣列來標記哪些數字存在。由於數字的相對順序由索引決定，我們可以直接遍歷這個布林陣列來找出排序後的相鄰元素。這種方法在數值範圍有限時特別有效。

#### 演算法步驟

1. **找出數值範圍**：遍歷陣列取得最小值 `min` 與最大值 `max`
2. **建立存在性陣列**：建立大小為 `(max - min + 1)` 的布林陣列
3. **標記存在的數字**：遍歷原陣列，將對應位置設為 `true`
4. **第一次遍歷**：遍歷布林陣列找出最小差值
5. **第二次遍歷**：收集所有差值等於最小差值的元素對

#### 虛擬碼

```
function MinimumAbsDifference_CountingSort(arr):
    min = Min(arr)
    max = Max(arr)
    
    // 建立存在性陣列
    exists = new boolean[max - min + 1]
    for num in arr:
        exists[num - min] = true
    
    // 找最小差值
    minDiff = INT_MAX
    prev = -1  // 上一個存在的數字位置
    
    for i = 0 to length(exists) - 1:
        if exists[i]:
            if prev != -1:
                minDiff = Min(minDiff, i - prev)
            prev = i
    
    // 收集結果
    result = empty list
    prev = -1
    
    for i = 0 to length(exists) - 1:
        if exists[i]:
            if prev != -1 and (i - prev) == minDiff:
                result.Add([prev + min, i + min])
            prev = i
    
    return result
```

#### 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n + k) | n 為元素數量，k 為數值範圍 (max - min) |
| 空間複雜度 | O(k) | 布林陣列所需空間 |

#### 適用場景分析

| 場景 | 是否適用 | 原因 |
|------|----------|------|
| k ≤ 2×10^6 | ✅ 非常適合 | 記憶體消耗可接受，時間接近線性 |
| k > 10^7 | ⚠️ 需考量 | 記憶體消耗較大 |
| n 很小但 k 很大 | ❌ 不適合 | 例如 `[1, 1000000]` 只有 2 個元素但需要大量空間 |

#### 優點與缺點

| 優點 | 缺點 |
|------|------|
| ✅ 時間複雜度可達線性 O(n + k) | ❌ 空間複雜度與數值範圍成正比 |
| ✅ 不需要比較排序 | ❌ 數值範圍大時記憶體消耗過高 |
| ✅ 適合數值密集的場景 | ❌ 實作較複雜 |

#### 範例：計數排序過程

以 `arr = [4, 2, 1, 3]` 為例：

```
Step 1: min = 1, max = 4, 範圍 k = 4

Step 2: 建立布林陣列 (索引 0~3 對應數值 1~4)
        exists = [true, true, true, true]
                   ↑     ↑     ↑     ↑
                   1     2     3     4

Step 3: 遍歷找最小差值
        索引 0→1: 差值 1, minDiff = 1
        索引 1→2: 差值 1, minDiff = 1
        索引 2→3: 差值 1, minDiff = 1

Step 4: 收集結果 → [[1,2], [2,3], [3,4]]
```

---

### 方法三：兩次遍歷優化版本

#### 核心思路

將「找最小差值」和「收集結果」分成兩個獨立的迴圈，避免方法一中可能的 `Clear()` 操作。第一次遍歷專注於找出最小差值，第二次遍歷專注於收集結果，程式邏輯更清晰。

#### 演算法步驟

1. **排序陣列**：將 `arr` 進行升冪排序
2. **第一次遍歷**：遍歷所有相鄰元素對，找出最小差值 `minDiff`
3. **第二次遍歷**：再次遍歷，收集所有差值等於 `minDiff` 的元素對

#### 虛擬碼

```
function MinimumAbsDifference_TwoPass(arr):
    Sort(arr)
    
    // 第一次遍歷：找最小差值
    minDiff = INT_MAX
    for i = 0 to length(arr) - 2:
        diff = arr[i + 1] - arr[i]
        minDiff = Min(minDiff, diff)
    
    // 第二次遍歷：收集結果
    result = empty list
    for i = 0 to length(arr) - 2:
        if arr[i + 1] - arr[i] == minDiff:
            result.Add([arr[i], arr[i + 1]])
    
    return result
```

#### 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n log n) | 排序為主要開銷，兩次遍歷共 O(2n) = O(n) |
| 空間複雜度 | O(log n) | 排序所需的堆疊空間（不含輸出） |

#### 優點與缺點

| 優點 | 缺點 |
|------|------|
| ✅ 程式碼邏輯清晰，易於理解 | ❌ 需要遍歷陣列兩次 |
| ✅ 避免 `Clear()` 操作 | ❌ 理論上常數因子比方法一略大 |
| ✅ 每個迴圈職責單一 | |
| ✅ 除錯與維護更容易 | |

#### 與方法一的比較

| 比較項目 | 方法一（一次遍歷） | 方法三（兩次遍歷） |
|----------|-------------------|-------------------|
| 遍歷次數 | 1 次 | 2 次 |
| 是否需要 Clear() | 是 | 否 |
| 程式碼複雜度 | 中等 | 簡單 |
| 實際效能 | 略快（通常） | 略慢（通常） |
| 可讀性 | 中等 | 高 |

---

### 方法四：陣列優化版本

#### 核心思路

在方法三的基礎上進一步優化記憶體分配。通過預先計算符合條件的元素對數量，一次性分配正確大小的結果清單，並使用固定大小的陣列（而非 `List<int>`）來儲存每個元素對，減少動態記憶體分配的開銷。

#### 演算法步驟

1. **排序陣列**：將 `arr` 進行升冪排序
2. **第一次遍歷**：
   - 找出最小差值 `minDiff`
   - 同時計算符合條件的元素對數量 `count`
3. **預先分配**：建立大小為 `count` 的結果清單
4. **第二次遍歷**：收集結果，使用 `int[]` 陣列（容量為 2）取代 `List<int>`

#### 虛擬碼

```
function MinimumAbsDifference_ArrayOptimized(arr):
    Sort(arr)
    
    // 第一次遍歷：找最小差值並計數
    minDiff = INT_MAX
    count = 0
    
    for i = 0 to length(arr) - 2:
        diff = arr[i + 1] - arr[i]
        if diff < minDiff:
            minDiff = diff
            count = 1
        else if diff == minDiff:
            count++
    
    // 預先分配結果清單
    result = new List with capacity = count
    
    // 第二次遍歷：收集結果（使用陣列）
    for i = 0 to length(arr) - 2:
        if arr[i + 1] - arr[i] == minDiff:
            result.Add(new int[] { arr[i], arr[i + 1] })
    
    return result
```

#### 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n log n) | 排序為主要開銷 |
| 空間複雜度 | O(log n) | 排序所需的堆疊空間（不含輸出） |

#### 記憶體優化細節

| 優化項目 | 未優化版本 | 優化後版本 | 效益 |
|----------|-----------|-----------|------|
| 結果清單容量 | 動態擴展 | 預先分配 `count` | 避免多次擴容複製 |
| 元素對類型 | `List<int>` | `int[2]` | 減少物件開銷 |
| 記憶體分配次數 | 多次 | 最小化 | 減少 GC 壓力 |

#### 優點與缺點

| 優點 | 缺點 |
|------|------|
| ✅ 記憶體分配最佳化 | ❌ 程式碼較長 |
| ✅ 減少垃圾回收壓力 | ❌ 需要兩次遍歷 |
| ✅ 適合大量資料場景 | ❌ 實作複雜度較高 |
| ✅ 效能微優化 | |

#### 效能提升場景

此方法特別適合以下情況：
- **大量資料**：當 n > 10^4 時，記憶體分配優化效果明顯
- **高頻呼叫**：在需要多次執行此演算法的場景中，減少 GC 可提升整體效能
- **記憶體敏感環境**：在記憶體受限的環境中更有優勢

---

## 📝 演示流程

以 `arr = [4, 2, 1, 3]` 為例：

### Step 1：排序

```
原始陣列: [4, 2, 1, 3]
排序後:   [1, 2, 3, 4]
```

### Step 2：遍歷相鄰元素

| i | arr[i] | arr[i+1] | δ (差值) | minDiff | 操作 | result |
|---|--------|----------|----------|---------|------|--------|
| 0 | 1 | 2 | 1 | ∞ → 1 | 更新 minDiff，清空並加入 [1,2] | [[1,2]] |
| 1 | 2 | 3 | 1 | 1 | δ == minDiff，加入 [2,3] | [[1,2], [2,3]] |
| 2 | 3 | 4 | 1 | 1 | δ == minDiff，加入 [3,4] | [[1,2], [2,3], [3,4]] |

### Step 3：回傳結果

```
輸出: [[1,2], [2,3], [3,4]]
```

---

## 🧪 另一個範例演示

以 `arr = [3, 8, -10, 23, 19, -4, -14, 27]` 為例：

### 排序後

```
[-14, -10, -4, 3, 8, 19, 23, 27]
```

### 遍歷過程

| 相鄰元素對 | 差值 δ | minDiff | 操作 |
|-----------|--------|---------|------|
| (-14, -10) | 4 | ∞ → 4 | 更新，加入 [-14,-10] |
| (-10, -4) | 6 | 4 | 跳過 (6 > 4) |
| (-4, 3) | 7 | 4 | 跳過 |
| (3, 8) | 5 | 4 | 跳過 |
| (8, 19) | 11 | 4 | 跳過 |
| (19, 23) | 4 | 4 | δ == minDiff，加入 [19,23] |
| (23, 27) | 4 | 4 | δ == minDiff，加入 [23,27] |

### 最終結果

```
[[-14,-10], [19,23], [23,27]]
```

---

## 🚀 快速開始

### 環境需求

- [.NET 10.0 SDK](https://dotnet.microsoft.com/download) 或更新版本

### 執行專案

```bash
# 複製專案
git clone https://github.com/HyperLee/Leetcode_folder.git

# 進入專案目錄
cd Leetcode_folder/leetcode_1200

# 建構並執行
dotnet run --project leetcode_1200/leetcode_1200.csproj
```

### 預期輸出

```
測試案例 1:
輸入: [4, 2, 1, 3]
輸出: [[1,2],[2,3],[3,4]]

測試案例 2:
輸入: [1, 3, 6, 10, 15]
輸出: [[1,3]]

測試案例 3:
輸入: [3, 8, -10, 23, 19, -4, -14, 27]
輸出: [[-14,-10],[19,23],[23,27]]
```

---

## 📚 相關連結

- [LeetCode 1200 - Minimum Absolute Difference (英文)](https://leetcode.com/problems/minimum-absolute-difference/)
- [力扣 1200 - 最小绝对差 (中文)](https://leetcode.cn/problems/minimum-absolute-difference/)

---

## 📊 各解法比較

| 解法 | 時間複雜度 | 空間複雜度 | 優點 | 缺點 |
|------|-----------|-----------|------|------|
| **方法一：排序 + 一次遍歷** | O(n log n) | O(log n) | 簡潔、一次遍歷找結果 | 遇到更小差值需 Clear() |
| **方法二：計數排序** | O(n + k) | O(k) | 數值範圍小時接近線性 | 數值範圍大時空間消耗高 |
| **方法三：兩次遍歷** | O(n log n) | O(log n) | 程式碼清晰、避免 Clear() | 需遍歷兩次 |
| **方法四：陣列優化** | O(n log n) | O(log n) | 減少記憶體分配、效能微優化 | 程式碼略長 |

> **註：** k 為數值範圍 (max - min)，n 為陣列長度

### 選擇建議

1. **通用場景**：使用**方法一**或**方法三**，時間複雜度最佳且程式碼簡潔
2. **數值範圍小**（k ≤ 2×10^6）：使用**方法二計數排序**可達到線性時間
3. **追求極致效能**：使用**方法四**減少記憶體分配開銷
4. **面試場景**：優先使用**方法一**，展示排序後相鄰元素的關鍵洞察
