# LeetCode 1200 - Minimum Absolute Difference

> 最小絕對差 | 排序 + 一次遍歷解法

[![.NET](https://img.shields.io/badge/.NET-10.0-512BD4?style=flat-square)](https://dotnet.microsoft.com/)
[![C#](https://img.shields.io/badge/C%23-14-239120?style=flat-square)](https://docs.microsoft.com/dotnet/csharp/)
[![LeetCode](https://img.shields.io/badge/LeetCode-1200-FFA116?style=flat-square)](https://leetcode.com/problems/minimum-absolute-difference/)

## 📋 題目描述

給定一個由**互不相同**的整數所組成的陣列 `arr`，找出所有具有**最小絕對差**的元素對。

回傳一個以對為單位、以升冪排序的清單。每個對 `[a, b]` 必須滿足：

- `a` 與 `b` 來自 `arr`
- `a < b`
- `b - a` 等於陣列中任兩元素的最小絕對差

### 範例

**範例 1：**
```
輸入: arr = [4, 2, 1, 3]
輸出: [[1,2], [2,3], [3,4]]
解釋: 最小絕對差為 1，所有相鄰元素對的差都是 1。
```

**範例 2：**
```
輸入: arr = [1, 3, 6, 10, 15]
輸出: [[1,3]]
解釋: 最小絕對差為 2，只有 (1,3) 這一對。
```

**範例 3：**
```
輸入: arr = [3, 8, -10, 23, 19, -4, -14, 27]
輸出: [[-14,-10], [19,23], [23,27]]
解釋: 最小絕對差為 4。
```

### 限制條件

- `2 <= arr.length <= 10^5`
- `-10^6 <= arr[i] <= 10^6`

---

## 💡 解題概念與出發點

### 核心觀察

要找出所有最小絕對差的元素對，最直觀的方法是比較所有可能的元素對，但這會導致 O(n²) 的時間複雜度。

**關鍵洞察：** 如果我們先將陣列排序，那麼具有最小絕對差的元素對**一定是相鄰的兩個元素**。

為什麼？因為對於排序後的陣列：
- 若 `arr[i] < arr[j] < arr[k]`
- 則 `arr[k] - arr[i] = (arr[k] - arr[j]) + (arr[j] - arr[i])`
- 所以 `arr[k] - arr[i]` 一定大於等於 `arr[j] - arr[i]`

這意味著我們只需要檢查相鄰元素！

---

## 🔧 解法說明

### 方法一：排序 + 一次遍歷（原始解法）

#### 演算法步驟

1. **排序陣列**：將 `arr` 進行升冪排序
2. **遍歷相鄰元素**：計算每對相鄰元素的差值 δ
3. **維護最小差值**：
   - 若 `δ < minDiff`：更新 `minDiff`，清空結果，加入新的元素對
   - 若 `δ == minDiff`：直接將元素對加入結果

#### 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n log n) | 排序為主要開銷 |
| 空間複雜度 | O(log n) | 排序所需的堆疊空間 |

---

### 方法二：計數排序 (Counting Sort)

適用於數值範圍有限的情況，可將時間複雜度降至線性。

#### 演算法步驟

1. **找出數值範圍**：取得陣列的最小值 `min` 與最大值 `max`
2. **建立計數陣列**：使用布林陣列標記哪些數字存在
3. **遍歷計數陣列**：找出相鄰存在的數字，計算差值並維護結果

#### 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n + k) | k 為數值範圍 (max - min) |
| 空間複雜度 | O(k) | 計數陣列所需空間 |

#### 適用場景

當數值範圍 k 較小時（如 k ≤ 2×10^6），效率優於排序解法。

---

### 方法三：兩次遍歷優化版本

程式碼更清晰簡潔，避免 `Clear()` 操作。

#### 演算法步驟

1. **排序陣列**：將 `arr` 進行升冪排序
2. **第一次遍歷**：只找最小差值 `minDiff`
3. **第二次遍歷**：收集所有差值等於 `minDiff` 的元素對

#### 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n log n) | 排序為主要開銷 |
| 空間複雜度 | O(log n) | 排序所需的堆疊空間 |

---

### 方法四：陣列優化版本

預先分配記憶體，減少動態分配開銷。

#### 演算法步驟

1. **排序陣列**：將 `arr` 進行升冪排序
2. **第一次遍歷**：找最小差值 `minDiff` 並計算符合條件的元素對數量
3. **預先分配**：建立正確大小的結果清單
4. **第二次遍歷**：收集結果，使用陣列取代 `List<int>` 作為元素對

#### 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n log n) | 排序為主要開銷 |
| 空間複雜度 | O(log n) | 排序所需的堆疊空間 |

---

## 📝 演示流程

以 `arr = [4, 2, 1, 3]` 為例：

### Step 1：排序

```
原始陣列: [4, 2, 1, 3]
排序後:   [1, 2, 3, 4]
```

### Step 2：遍歷相鄰元素

| i | arr[i] | arr[i+1] | δ (差值) | minDiff | 操作 | result |
|---|--------|----------|----------|---------|------|--------|
| 0 | 1 | 2 | 1 | ∞ → 1 | 更新 minDiff，清空並加入 [1,2] | [[1,2]] |
| 1 | 2 | 3 | 1 | 1 | δ == minDiff，加入 [2,3] | [[1,2], [2,3]] |
| 2 | 3 | 4 | 1 | 1 | δ == minDiff，加入 [3,4] | [[1,2], [2,3], [3,4]] |

### Step 3：回傳結果

```
輸出: [[1,2], [2,3], [3,4]]
```

---

## 🧪 另一個範例演示

以 `arr = [3, 8, -10, 23, 19, -4, -14, 27]` 為例：

### 排序後

```
[-14, -10, -4, 3, 8, 19, 23, 27]
```

### 遍歷過程

| 相鄰元素對 | 差值 δ | minDiff | 操作 |
|-----------|--------|---------|------|
| (-14, -10) | 4 | ∞ → 4 | 更新，加入 [-14,-10] |
| (-10, -4) | 6 | 4 | 跳過 (6 > 4) |
| (-4, 3) | 7 | 4 | 跳過 |
| (3, 8) | 5 | 4 | 跳過 |
| (8, 19) | 11 | 4 | 跳過 |
| (19, 23) | 4 | 4 | δ == minDiff，加入 [19,23] |
| (23, 27) | 4 | 4 | δ == minDiff，加入 [23,27] |

### 最終結果

```
[[-14,-10], [19,23], [23,27]]
```

---

## 🚀 快速開始

### 環境需求

- [.NET 10.0 SDK](https://dotnet.microsoft.com/download) 或更新版本

### 執行專案

```bash
# 複製專案
git clone https://github.com/HyperLee/Leetcode_folder.git

# 進入專案目錄
cd Leetcode_folder/leetcode_1200

# 建構並執行
dotnet run --project leetcode_1200/leetcode_1200.csproj
```

### 預期輸出

```
測試案例 1:
輸入: [4, 2, 1, 3]
輸出: [[1,2],[2,3],[3,4]]

測試案例 2:
輸入: [1, 3, 6, 10, 15]
輸出: [[1,3]]

測試案例 3:
輸入: [3, 8, -10, 23, 19, -4, -14, 27]
輸出: [[-14,-10],[19,23],[23,27]]
```

---

## 📚 相關連結

- [LeetCode 1200 - Minimum Absolute Difference (英文)](https://leetcode.com/problems/minimum-absolute-difference/)
- [力扣 1200 - 最小绝对差 (中文)](https://leetcode.cn/problems/minimum-absolute-difference/)

---

## 📊 各解法比較

| 解法 | 時間複雜度 | 空間複雜度 | 優點 | 缺點 |
|------|-----------|-----------|------|------|
| **方法一：排序 + 一次遍歷** | O(n log n) | O(log n) | 簡潔、一次遍歷找結果 | 遇到更小差值需 Clear() |
| **方法二：計數排序** | O(n + k) | O(k) | 數值範圍小時接近線性 | 數值範圍大時空間消耗高 |
| **方法三：兩次遍歷** | O(n log n) | O(log n) | 程式碼清晰、避免 Clear() | 需遍歷兩次 |
| **方法四：陣列優化** | O(n log n) | O(log n) | 減少記憶體分配、效能微優化 | 程式碼略長 |

> **註：** k 為數值範圍 (max - min)，n 為陣列長度

### 選擇建議

1. **通用場景**：使用**方法一**或**方法三**，時間複雜度最佳且程式碼簡潔
2. **數值範圍小**（k ≤ 2×10^6）：使用**方法二計數排序**可達到線性時間
3. **追求極致效能**：使用**方法四**減少記憶體分配開銷
4. **面試場景**：優先使用**方法一**，展示排序後相鄰元素的關鍵洞察
