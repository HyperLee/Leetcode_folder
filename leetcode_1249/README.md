# LeetCode 1249 - Minimum Remove to Make Valid Parentheses

移除最少括號使字串有效

## 題目描述

給定一個由 `'('`、`')'` 以及小寫英文字母組成的字串 `s`。

任務是**最少移除若干括號**（`'('` 或 `')'`，可位於任意位置），使得結果的括號字串為**有效**，並回傳任一個有效的字串。

### 有效括號字串定義

- 空字串，或只包含小寫字母
- 可以寫成 `AB`（`A` 與 `B` 為有效字串）
- 可以寫成 `(A)`，其中 `A` 為有效字串

### 範例

**範例 1：**
```
輸入：s = "lee(t(c)o)de)"
輸出："lee(t(c)o)de"
解釋：移除索引 12 的 ')' 即可
```

**範例 2：**
```
輸入：s = "a)b(c)d"
輸出："ab(c)d"
解釋：移除索引 1 的 ')' 即可
```

**範例 3：**
```
輸入：s = "))(("
輸出：""
解釋：所有括號都無效，全部移除後為空字串
```

### 限制條件

- `1 <= s.length <= 10^5`
- `s[i]` 為 `'('`、`')'` 或小寫英文字母

## 解題思路

### 核心觀察

1. **無效的 `)`**：當遇到 `)` 時，前面沒有未匹配的 `(` 可以配對
2. **無效的 `(`**：當處理完所有字元後，仍有未被 `)` 匹配的 `(`

### 解題出發點

我們可以分兩階段處理：

1. **從左到右掃描**：移除所有無效的 `)`
2. **再次掃描**：移除多餘的 `(`

> [!TIP]
> 這個解法不需要使用 Stack，只需要計數器即可完成，時間與空間複雜度皆為 O(n)。

## 演算法詳解

### 第一階段：移除無效的 `)`

使用兩個計數器：
- `openCount`：記錄遇到的 `(` 總數
- `balanceCount`：記錄目前未匹配的 `(` 數量

```
遍歷每個字元：
├── 遇到 '(' → openCount++, balanceCount++
├── 遇到 ')' 
│   ├── balanceCount > 0 → 有效配對，balanceCount--
│   └── balanceCount == 0 → 無效，跳過不加入結果
└── 遇到字母 → 直接加入結果
```

### 第二階段：移除多餘的 `(`

經過第一階段後：
- `balanceCount` = 未匹配的 `(` 數量（即多餘的 `(`）
- 需要保留的 `(` = `openCount - balanceCount`

```
從左到右遍歷第一階段的結果：
├── 遇到 '(' 
│   ├── 還需要保留 → 保留，balancedOpenCount--
│   └── 已保留足夠 → 跳過
└── 其他字元 → 直接加入結果
```

> [!NOTE]
> 為何從左保留 `(` 可行？因為第一階段後，所有 `)` 都是有效的。多餘的 `(` 必定在字串較右側（右側沒有足夠的 `)` 來匹配）。

## 範例演示

以 `s = "lee(t(c)o)de)"` 為例：

### 第一階段執行過程

| 索引 | 字元 | openCount | balanceCount | 動作 | 結果 |
|:---:|:---:|:---:|:---:|---|---|
| 0 | `l` | 0 | 0 | 加入 | `l` |
| 1 | `e` | 0 | 0 | 加入 | `le` |
| 2 | `e` | 0 | 0 | 加入 | `lee` |
| 3 | `(` | 1 | 1 | 加入 | `lee(` |
| 4 | `t` | 1 | 1 | 加入 | `lee(t` |
| 5 | `(` | 2 | 2 | 加入 | `lee(t(` |
| 6 | `c` | 2 | 2 | 加入 | `lee(t(c` |
| 7 | `)` | 2 | 1 | 配對成功 | `lee(t(c)` |
| 8 | `o` | 2 | 1 | 加入 | `lee(t(c)o` |
| 9 | `)` | 2 | 0 | 配對成功 | `lee(t(c)o)` |
| 10 | `d` | 2 | 0 | 加入 | `lee(t(c)o)d` |
| 11 | `e` | 2 | 0 | 加入 | `lee(t(c)o)de` |
| 12 | `)` | 2 | 0 | ⚠️ 無效跳過 | `lee(t(c)o)de` |

**第一階段結果**：`"lee(t(c)o)de"`
- `openCount = 2`
- `balanceCount = 0`（所有 `(` 都已匹配）

### 第二階段執行過程

需要保留的 `(` 數量 = 2 - 0 = 2

由於 `balanceCount = 0`，沒有多餘的 `(`，第二階段不需移除任何字元。

**最終結果**：`"lee(t(c)o)de"`

---

### 另一個範例：`s = "(a(b(c)d)"`

**第一階段**：所有 `)` 都有對應的 `(`，結果不變
- 結果：`"(a(b(c)d)"`
- `openCount = 3`
- `balanceCount = 1`（有 1 個未匹配的 `(`）

**第二階段**：
- 需要保留的 `(` = 3 - 1 = 2
- 從左開始保留 2 個 `(`，第 3 個 `(` 會被跳過

| 索引 | 字元 | balancedOpenCount | 動作 | 結果 |
|:---:|:---:|:---:|---|---|
| 0 | `(` | 2→1 | 保留 | `(` |
| 1 | `a` | 1 | 加入 | `(a` |
| 2 | `(` | 1→0 | 保留 | `(a(` |
| 3 | `b` | 0 | 加入 | `(a(b` |
| 4 | `(` | 0 | ⚠️ 跳過 | `(a(b` |
| 5 | `c` | 0 | 加入 | `(a(bc` |
| 6 | `)` | 0 | 加入 | `(a(bc)` |
| 7 | `d` | 0 | 加入 | `(a(bc)d` |
| 8 | `)` | 0 | 加入 | `(a(bc)d)` |

**最終結果**：`"(a(bc)d)"`

## 複雜度分析

| 複雜度 | 數值 | 說明 |
|---|---|---|
| 時間複雜度 | O(n) | 兩次線性掃描 |
| 空間複雜度 | O(n) | StringBuilder 儲存結果 |

## 執行方式

```bash
cd leetcode_1249
dotnet run
```

## 參考資料

- [LeetCode 1249 - 英文題目](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/)
- [LeetCode 1249 - 中文題目](https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/)
- [LeetCode 官方解法](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/solution/yi-chu-wu-xiao-gua-hao-by-leetcode/)
