# LeetCode 540: Single Element in a Sorted Array

有序陣列中的單一元素

## 題目描述

給你一個已排序的整數陣列，陣列中每個元素恰好出現兩次，只有一個元素恰好出現一次。

**找出並回傳那個只出現一次的元素。**

> [!IMPORTANT]
> 要求：時間複雜度必須為 `O(log n)`，且額外空間為 `O(1)`。

### 範例

```text
輸入: nums = [1,1,2,3,3,4,4,8,8]
輸出: 2
```

```text
輸入: nums = [3,3,7,7,10,11,11]
輸出: 10
```

### 限制條件

- `1 <= nums.length <= 10^5`
- `0 <= nums[i] <= 10^5`

## 解題概念與出發點

### 為什麼使用二分查找？

由於題目要求 `O(log n)` 時間複雜度，這明確指向**二分查找**演算法。

### 關鍵觀察

1. **陣列長度為奇數**：因為只有一個元素出現一次，其餘都出現兩次
2. **有序陣列的特性**：相同的元素一定相鄰
3. **奇偶性分界**：單一元素將陣列分成左右兩部分，改變了配對元素起始下標的奇偶規律

### 核心思路

假設單一元素位於下標 `x`：

| 位置       | 規律                             |
|------------|----------------------------------|
| `x` 左邊   | 配對元素的第一個下標為**偶數**   |
| `x` 右邊   | 配對元素的第一個下標為**奇數**   |

這個**奇偶性分界點**就是我們要找的目標！

## 解法詳解：全陣列的二分查找

### 演算法步驟

1. 初始化左邊界 `low = 0`，右邊界 `high = nums.length - 1`
2. 計算中間位置 `mid`
3. 使用 **XOR 運算** 找到 `mid` 的配對下標
4. 根據比較結果調整搜尋範圍
5. 當 `low == high` 時找到答案

### XOR 技巧

利用按位異或的特性：

```text
mid ^ 1 的效果：
├── 當 mid 是偶數 → mid ^ 1 = mid + 1
└── 當 mid 是奇數 → mid ^ 1 = mid - 1
```

這樣無需判斷 `mid` 的奇偶性，直接比較 `nums[mid]` 和 `nums[mid ^ 1]`。

### 程式碼

```csharp
public int SingleNonDuplicate(int[] nums)
{
    int low = 0;
    int high = nums.Length - 1;

    while (low < high)
    {
        int mid = low + (high - low) / 2;

        // 使用 XOR 找配對下標
        if (nums[mid] == nums[mid ^ 1])
        {
            low = mid + 1;  // 單一元素在右邊
        }
        else
        {
            high = mid;     // 單一元素在左邊（包含 mid）
        }
    }

    return nums[low];
}
```

### 複雜度分析

| 複雜度     | 數值       | 說明                 |
|------------|------------|----------------------|
| 時間複雜度 | `O(log n)` | 每次迭代搜尋範圍減半 |
| 空間複雜度 | `O(1)`     | 只使用常數個變數     |

---

## 解法二：Dictionary 雜湊表計數法

### 思路

使用 Dictionary 統計每個元素出現的次數，找出出現次數為 1 的元素即為答案。

> [!WARNING]
> 此解法**不符合**題目要求的 `O(log n)` 時間複雜度和 `O(1)` 空間複雜度。

### 程式碼

```csharp
public int SingleNonDuplicate2(int[] nums)
{
    Dictionary<int, int> dict = new Dictionary<int, int>();

    // 統計每個元素的出現次數
    for (int i = 0; i < nums.Length; i++)
    {
        if (dict.ContainsKey(nums[i]))
            dict[nums[i]]++;
        else
            dict[nums[i]] = 1;
    }

    // 找出出現次數為 1 的元素
    foreach (var kvp in dict)
    {
        if (kvp.Value == 1)
            return kvp.Key;
    }

    return -1;
}
```

### 複雜度分析

| 複雜度     | 數值   | 說明                           |
|------------|--------|--------------------------------|
| 時間複雜度 | `O(n)` | 需要遍歷整個陣列               |
| 空間複雜度 | `O(n)` | 需要額外的 Dictionary 儲存計數 |

---

## 解法三：XOR 異或運算法

### 思路

利用 XOR 的數學特性：
- `a ^ a = 0`（相同數字 XOR 結果為 0）
- `a ^ 0 = a`（任何數字與 0 XOR 結果為本身）
- XOR 具有交換律和結合律

將所有元素逐一進行 XOR 運算，成對出現的元素會互相抵消變成 0，最後留下的就是單一元素。

> [!WARNING]
> 此解法**不符合**題目要求的 `O(log n)` 時間複雜度，且沒有利用「陣列已排序」這個條件。

### 程式碼

```csharp
public int SingleNonDuplicate3(int[] nums)
{
    int res = 0;

    // 將所有元素 XOR，成對的會抵消
    for (int i = 0; i < nums.Length; i++)
    {
        res = res ^ nums[i];
    }

    return res;
}
```

### 運算過程範例

```text
輸入: [1, 1, 2, 3, 3]

0 ^ 1 = 1
1 ^ 1 = 0
0 ^ 2 = 2
2 ^ 3 = 1
1 ^ 3 = 2

結果: 2 ✓
```

### 複雜度分析

| 複雜度     | 數值   | 說明               |
|------------|--------|--------------------|
| 時間複雜度 | `O(n)` | 需要遍歷整個陣列   |
| 空間複雜度 | `O(1)` | 只使用常數額外空間 |

---

## 解法四：步長為 2 的線性遍歷法

### 思路

在單一元素之前，每對相同元素的第一個都在偶數下標。因此以步長 2 遍歷偶數下標，檢查 `nums[i]` 是否等於 `nums[i+1]`。第一個不符合條件的位置就是單一元素的位置。

> [!WARNING]
> 此解法**不符合**題目要求的 `O(log n)` 時間複雜度。

### 程式碼

```csharp
public int SingleNonDuplicate4(int[] nums)
{
    int n = nums.Length;

    // 以步長 2 遍歷所有偶數下標
    for (int i = 0; i < n - 1; i += 2)
    {
        if (nums[i] != nums[i + 1])
        {
            return nums[i];
        }
    }

    // 單一元素在最後一個位置
    return nums[n - 1];
}
```

### 複雜度分析

| 複雜度     | 數值   | 說明                     |
|------------|--------|--------------------------|
| 時間複雜度 | `O(n)` | 最壞情況遍歷整個陣列     |
| 空間複雜度 | `O(1)` | 只使用常數額外空間       |

---

## 解法五：偶數下標二分查找法

### 思路

將陣列以「配對」為單位進行二分查找。假設有 n 個元素，則有 `(n-1)/2` 個完整配對和 1 個單一元素。

對於配對編號 `mid`，對應的元素下標為 `2*mid` 和 `2*mid+1`：
- 如果 `nums[2*mid] == nums[2*mid+1]`，表示這個配對是完整的，單一元素在右邊
- 否則，單一元素在這裡或左邊

### 程式碼

```csharp
public int SingleNonDuplicate5(int[] nums)
{
    int low = -1;
    int high = nums.Length / 2;

    while (low + 1 < high)
    {
        int mid = (low + high) / 2;

        if (nums[2 * mid] == nums[2 * mid + 1])
        {
            low = mid;  // 配對完整，單一元素在右邊
        }
        else
        {
            high = mid; // 配對不完整，單一元素在這裡或左邊
        }
    }

    return nums[2 * high];
}
```

### 複雜度分析

| 複雜度     | 數值       | 說明                 |
|------------|------------|----------------------|
| 時間複雜度 | `O(log n)` | 每次縮小一半搜尋範圍 |
| 空間複雜度 | `O(1)`     | 只使用常數額外空間   |

---

## 各解法比較

| 解法                       | 時間複雜度 | 空間複雜度 | 符合題目要求 | 特點                       |
|----------------------------|------------|------------|--------------|----------------------------|
| 解法一：全陣列二分查找     | `O(log n)` | `O(1)`     | ✅            | 使用 XOR 技巧找配對下標     |
| 解法二：Dictionary 計數    | `O(n)`     | `O(n)`     | ❌            | 簡單但效率低               |
| 解法三：XOR 異或運算       | `O(n)`     | `O(1)`     | ❌            | 巧妙但未利用排序特性       |
| 解法四：步長為 2 遍歷      | `O(n)`     | `O(1)`     | ❌            | 直觀但效率低               |
| 解法五：偶數下標二分查找   | `O(log n)` | `O(1)`     | ✅            | 以配對為單位思考           |

### 推薦解法

- **面試首選**：解法一（全陣列二分查找）- 程式碼簡潔，XOR 技巧展現位運算能力
- **最易理解**：解法五（偶數下標二分查找）- 以配對為單位的思路更直觀
- **快速實現**：解法三（XOR 異或運算）- 雖不符合時間要求，但程式碼最短

## 範例演示

以 `nums = [1, 1, 2, 3, 3, 4, 4, 8, 8]` 為例，找出單一元素 `2`：

```text
初始狀態: low=0, high=8
陣列索引:  0  1  2  3  4  5  6  7  8
陣列內容: [1, 1, 2, 3, 3, 4, 4, 8, 8]
```

### 第一次迭代

```text
mid = (0 + 8) / 2 = 4
mid ^ 1 = 4 ^ 1 = 5

比較: nums[4]=3, nums[5]=4
結果: 3 ≠ 4 → 單一元素在左半部
更新: high = 4
```

### 第二次迭代

```text
mid = (0 + 4) / 2 = 2
mid ^ 1 = 2 ^ 1 = 3

比較: nums[2]=2, nums[3]=3
結果: 2 ≠ 3 → 單一元素在左半部
更新: high = 2
```

### 第三次迭代

```text
mid = (0 + 2) / 2 = 1
mid ^ 1 = 1 ^ 1 = 0

比較: nums[1]=1, nums[0]=1
結果: 1 == 1 → 單一元素在右半部
更新: low = 2
```

### 結束

```text
low = 2, high = 2
迴圈結束，回傳 nums[2] = 2 ✓
```

## 執行專案

```bash
# 建構專案
dotnet build

# 執行測試
dotnet run --project leetcode_540
```

## 相關連結

- [LeetCode 540 - Single Element in a Sorted Array](https://leetcode.com/problems/single-element-in-a-sorted-array/)
- [力扣 540 - 有序數組中的單一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)
