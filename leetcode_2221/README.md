# LeetCode 2221: Find Triangular Sum of an Array

> **陣列的三角和** - Medium 難度

C# 實作解決方案，提供三種不同的解法策略及完整的時間/空間複雜度分析。

## 題目描述

給定一個 0 索引的整數陣列 `nums`，其中 `nums[i]` 是介於 0 到 9 之間的數字（包括 0 和 9）。

**陣列的三角和**是經過以下過程後 `nums` 中唯一剩餘元素的值：

1. 設 `nums` 包含 `n` 個元素
2. 如果 `n == 1`，結束過程；否則，建立一個新的 0 索引整數陣列 `newNums`，長度為 `n - 1`
3. 對於每個索引 `i`（其中 `0 <= i < n - 1`），將 `newNums[i]` 的值設為 `(nums[i] + nums[i+1]) % 10`
4. 將陣列 `nums` 替換為 `newNums`
5. 重複整個過程從步驟 1 開始

返回 `nums` 的三角和。

### 範例

**範例 1:**
```
輸入: nums = [1,2,3,4,5]
輸出: 8
說明:
第 1 輪: [3,5,7,9]     → (1+2)%10, (2+3)%10, (3+4)%10, (4+5)%10
第 2 輪: [8,2,6]       → (3+5)%10, (5+7)%10, (7+9)%10
第 3 輪: [0,8]         → (8+2)%10, (2+6)%10
第 4 輪: [8]           → (0+8)%10
```

**範例 2:**
```
輸入: nums = [5]
輸出: 5
說明: 陣列只有一個元素，直接返回
```

### 限制條件

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 9`

## 解法策略

本專案提供三種不同的解法，每種都有其特點和適用場景：

### 方法 1: 模擬法 (Simulation)

**核心思想：** 直接按照題目描述模擬整個過程。

#### 演算法步驟

1. 檢查邊界條件：如果陣列長度為 1，直接返回該元素
2. 進入迴圈，每次建立新陣列 `newNums`，長度為當前陣列長度 - 1
3. 遍歷當前陣列，將相鄰元素相加並取模 10，存入新陣列
4. 用新陣列取代原陣列
5. 重複步驟 2-4 直到陣列長度為 1

#### 複雜度分析

- **時間複雜度:** `O(n²)`
  - 外層迴圈執行 n-1 次
  - 第 i 次迴圈內層執行 n-i 次操作
  - 總操作次數: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n²)

- **空間複雜度:** `O(n)`
  - 每次迴圈需要建立新陣列
  - 最大陣列長度為 n-1

#### 優點
- 程式碼清晰易懂，完全按照題意實作
- 容易理解和除錯
- 適合初學者學習

#### 缺點
- 需要額外的空間建立新陣列
- 相對較高的記憶體使用

#### 程式碼範例

```csharp
public int TriangularSum_Method1(int[] nums)
{
    int n = nums.Length;

    if (n == 1)
    {
        return nums[0];
    }

    while (n > 1)
    {
        int[] newNums = new int[n - 1];
        
        for (int i = 0; i < n - 1; i++)
        {
            newNums[i] = (nums[i] + nums[i + 1]) % 10;
        }
        
        nums = newNums;
        n--;
    }

    return nums[0];
}
```

---

### 方法 2: 原地修改法 (In-Place Modification)

**核心思想：** 優化空間使用，直接在原陣列上進行修改，不建立新陣列。

#### 演算法步驟

1. 使用變數 `currentLength` 追蹤當前有效長度
2. 每次運算時，直接將計算結果寫回原陣列的前面位置
3. 因為每次計算 `nums[i] = (nums[i] + nums[i+1]) % 10`，舊的 `nums[i]` 值在計算完後就不再需要
4. 逐步縮減有效長度，直到只剩一個元素

#### 複雜度分析

- **時間複雜度:** `O(n²)`
  - 與方法 1 相同的迴圈結構
  - 總操作次數: n(n-1)/2 = O(n²)

- **空間複雜度:** `O(1)`
  - 只使用常數額外空間（currentLength 變數）
  - 直接在原陣列上修改，不需要建立新陣列
  - **相較方法 1 有顯著的空間優化**

#### 優點
- 空間效率最佳，只需 O(1) 額外空間
- 時間效率與方法 1 相同
- 實際運行速度可能更快（減少記憶體配置和 GC 負擔）

#### 缺點
- 會修改原始輸入陣列（如需保留原陣列需先複製）
- 程式碼可讀性略低於方法 1

#### 程式碼範例

```csharp
public int TriangularSum_Method2(int[] nums)
{
    int currentLength = nums.Length;

    while (currentLength > 1)
    {
        for (int i = 0; i < currentLength - 1; i++)
        {
            nums[i] = (nums[i] + nums[i + 1]) % 10;
        }
        
        currentLength--;
    }

    return nums[0];
}
```

#### 運作示意圖

```
原始: [1, 2, 3, 4, 5]  (currentLength = 5)
     ↓
第1輪: [3, 5, 7, 9, 5]  (currentLength = 4, 只看前4個)
     ↓
第2輪: [8, 2, 6, 9, 5]  (currentLength = 3, 只看前3個)
     ↓
第3輪: [0, 8, 6, 9, 5]  (currentLength = 2, 只看前2個)
     ↓
第4輪: [8, 8, 6, 9, 5]  (currentLength = 1, 結果是 nums[0] = 8)
```

---

### 方法 3: 數學解法 - 二項式係數 (Binomial Coefficients)

**核心思想：** 利用數學性質，觀察到最終結果實際上是各元素乘以對應的二項式係數（楊輝三角/帕斯卡三角形的係數）後的加權和。

#### 數學原理

經過觀察和數學推導，我們發現：

```
triangularSum(nums) = Σ(nums[i] × C(n-1, i)) mod 10
```

其中：
- `n` 是陣列長度
- `C(n-1, i)` 是二項式係數，表示「從 n-1 個中選 i 個」的組合數
- 這些係數恰好對應**楊輝三角（帕斯卡三角形）**的第 n-1 行

#### 為什麼是二項式係數？

讓我們用範例理解：

對於 `nums = [1, 2, 3, 4, 5]` (n=5)：

**傳統模擬過程：**
```
[1, 2, 3, 4, 5]
[3, 5, 7, 9]      → 每個數字受到相鄰兩個原始數字的影響
[8, 2, 6]         → 繼續累積影響
[0, 8]
[8]
```

**數學分析：**

最終結果 8 實際上可以表示為：
```
1×C(4,0) + 2×C(4,1) + 3×C(4,2) + 4×C(4,3) + 5×C(4,4)
= 1×1 + 2×4 + 3×6 + 4×4 + 5×1
= 1 + 8 + 18 + 16 + 5
= 48
= 48 % 10
= 8
```

這裡的 `[1, 4, 6, 4, 1]` 正是楊輝三角第 4 行的係數！

#### 楊輝三角參考

```
第 0 行:           1
第 1 行:         1   1
第 2 行:       1   2   1
第 3 行:     1   3   3   1
第 4 行:   1   4   6   4   1
第 5 行: 1   5  10  10   5   1
...
```

每個數字等於上一行兩個相鄰數字之和，這與我們的題目過程完全對應！

#### 演算法步驟

1. 建立陣列儲存第 n-1 行的二項式係數
2. 使用遞推公式計算係數：`C(n, k) = C(n, k-1) × (n-k+1) / k`
3. 計算加權和：將每個 `nums[i]` 乘以對應的 `C(n-1, i)`
4. 每次加法後取模 10（避免數值過大）

#### 複雜度分析

- **時間複雜度:** `O(n)`
  - 計算 n 個二項式係數：O(n)
  - 計算加權和：O(n)
  - 總時間：O(n)
  - **相較前兩種方法有顯著的時間優化**

- **空間複雜度:** `O(n)`
  - 需要陣列儲存 n 個係數

#### 優點
- 時間複雜度最優，從 O(n²) 降至 O(n)
- 展現數學之美，將模擬問題轉化為數學公式
- 對於大規模數據有顯著效能優勢
- 只需要一次遍歷

#### 缺點
- 需要理解二項式係數和楊輝三角的數學概念
- 程式碼可讀性較低，需要額外註解說明
- 計算大數組合數時可能有溢位風險（本題數據範圍內安全）

#### 程式碼範例

```csharp
public int TriangularSum_Method3(int[] nums)
{
    int n = nums.Length;

    if (n == 1)
    {
        return nums[0];
    }

    // 建立並計算二項式係數
    int[] coefficients = new int[n];
    coefficients[0] = 1; // C(n-1, 0) = 1

    for (int i = 1; i < n; i++)
    {
        // C(n-1, i) = C(n-1, i-1) × (n-i) / i
        coefficients[i] = coefficients[i - 1] * (n - i) / i;
    }

    // 計算加權和
    int result = 0;
    for (int i = 0; i < n; i++)
    {
        result = (result + nums[i] * coefficients[i]) % 10;
    }

    return result;
}
```

#### 詳細計算範例

對於 `nums = [1, 1, 1, 1, 1, 1]` (n=6)：

**步驟 1: 計算第 5 行的二項式係數**
```
C(5,0) = 1
C(5,1) = 1 × 5/1 = 5
C(5,2) = 5 × 4/2 = 10
C(5,3) = 10 × 3/3 = 10
C(5,4) = 10 × 2/4 = 5
C(5,5) = 5 × 1/5 = 1

係數: [1, 5, 10, 10, 5, 1]
```

**步驟 2: 計算加權和**
```
result = (1×1 + 1×5 + 1×10 + 1×10 + 1×5 + 1×1) % 10
       = 32 % 10
       = 2
```

---

## 三種方法比較表

| 方法 | 時間複雜度 | 空間複雜度 | 優點 | 適用場景 |
|------|-----------|-----------|------|---------|
| **方法 1: 模擬法** | O(n²) | O(n) | 程式碼清晰、易於理解 | 小規模數據、教學用途 |
| **方法 2: 原地修改** | O(n²) | O(1) | 空間效率最佳 | 記憶體受限環境 |
| **方法 3: 數學解法** | O(n) | O(n) | 時間效率最佳 | 大規模數據、效能要求高 |

## 測試結果

專案包含 5 組測試案例，涵蓋各種情境：

```
測試 1 - 基本範例: [1, 2, 3, 4, 5] → 8
測試 2 - 單一元素: [5] → 5
測試 3 - 兩個元素: [9, 8] → 7
測試 4 - 包含零: [0, 0, 0] → 0
測試 5 - 重複元素: [1, 1, 1, 1, 1, 1] → 2
```

所有三種方法在所有測試案例中均產生一致的正確結果。

## 執行專案

### 前置需求

- .NET 8.0 或更高版本

### 建構與執行

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run --project leetcode_2221/leetcode_2221.csproj
```

### 預期輸出

```
測試 1 - 輸入: [1, 2, 3, 4, 5]
方法 1 結果: 8
方法 2 結果: 8
方法 3 結果: 8

測試 2 - 輸入: [5]
方法 1 結果: 5
方法 2 結果: 5
方法 3 結果: 5

... (其他測試案例)
```

## 程式碼結構

```
leetcode_2221/
├── Program.cs          # 主程式，包含三種解法和測試案例
├── leetcode_2221.csproj
└── README.md          # 本文件
```

## 學習重點

1. **演算法優化思維**
   - 從直觀模擬到空間優化
   - 從模擬到數學建模

2. **時間與空間權衡**
   - 理解不同解法的取捨
   - 根據實際場景選擇合適方案

3. **數學在程式設計中的應用**
   - 二項式係數的計算
   - 楊輝三角的性質
   - 將問題抽象為數學公式

4. **C# 程式設計實踐**
   - 陣列操作技巧
   - 原地修改 vs 建立新結構
   - 程式碼可讀性與效能的平衡

## 延伸思考

1. **為什麼取模 10？**
   - 限制數值範圍，避免溢位
   - 實際上只關心個位數

2. **能否進一步優化方法 3？**
   - 考慮使用費馬小定理優化模運算
   - 考慮使用快速冪計算大組合數

3. **這個問題與其他經典問題的關聯**
   - 帕斯卡三角形
   - 動態規劃中的組合數應用
   - 數字三角形路徑問題

## 參考資源

- [LeetCode 2221 - English](https://leetcode.com/problems/find-triangular-sum-of-an-array/)
- [LeetCode 2221 - 中文](https://leetcode.cn/problems/find-triangular-sum-of-an-array/)
- [楊輝三角（帕斯卡三角形）](https://zh.wikipedia.org/wiki/杨辉三角形)
- [二項式係數](https://zh.wikipedia.org/wiki/二项式系数)

## 授權

此專案的程式碼可自由用於學習和參考用途。

---

**Happy Coding! 🚀**
