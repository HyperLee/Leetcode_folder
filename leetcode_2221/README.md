# LeetCode 2221: Find Triangular Sum of an Array

> **陣列的三角和** - Medium 難度

C# 實作解決方案，提供三種不同的解法策略及完整的時間/空間複雜度分析。

## 題目描述

給定一個 0 索引的整數陣列 `nums`，其中 `nums[i]` 是介於 0 到 9 之間的數字（包括 0 和 9）。

**陣列的三角和**是經過以下過程後 `nums` 中唯一剩餘元素的值：

1. 設 `nums` 包含 `n` 個元素
2. 如果 `n == 1`，結束過程；否則，建立一個新的 0 索引整數陣列 `newNums`，長度為 `n - 1`
3. 對於每個索引 `i`（其中 `0 <= i < n - 1`），將 `newNums[i]` 的值設為 `(nums[i] + nums[i+1]) % 10`
4. 將陣列 `nums` 替換為 `newNums`
5. 重複整個過程從步驟 1 開始

返回 `nums` 的三角和。

### 範例

**範例 1:**
```
輸入: nums = [1,2,3,4,5]
輸出: 8
說明:
第 1 輪: [3,5,7,9]     → (1+2)%10, (2+3)%10, (3+4)%10, (4+5)%10
第 2 輪: [8,2,6]       → (3+5)%10, (5+7)%10, (7+9)%10
第 3 輪: [0,8]         → (8+2)%10, (2+6)%10
第 4 輪: [8]           → (0+8)%10
```

**範例 2:**
```
輸入: nums = [5]
輸出: 5
說明: 陣列只有一個元素，直接返回
```

### 限制條件

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 9`

## 解法策略

本專案提供三種不同的解法，每種都有其特點和適用場景：

### 方法 1: 模擬法 (Simulation)

**核心思想：** 直接按照題目描述模擬整個過程。

#### 演算法步驟

1. 檢查邊界條件：如果陣列長度為 1，直接返回該元素
2. 進入迴圈，每次建立新陣列 `newNums`，長度為當前陣列長度 - 1
3. 遍歷當前陣列，將相鄰元素相加並取模 10，存入新陣列
4. 用新陣列取代原陣列
5. 重複步驟 2-4 直到陣列長度為 1

#### 複雜度分析

- **時間複雜度:** `O(n²)`
  - 外層迴圈執行 n-1 次
  - 第 i 次迴圈內層執行 n-i 次操作
  - 總操作次數: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n²)

- **空間複雜度:** `O(n)`
  - 每次迴圈需要建立新陣列
  - 最大陣列長度為 n-1

#### 優點
- 程式碼清晰易懂，完全按照題意實作
- 容易理解和除錯
- 適合初學者學習

#### 缺點
- 需要額外的空間建立新陣列
- 相對較高的記憶體使用

#### 程式碼範例

```csharp
public int TriangularSum_Method1(int[] nums)
{
    int n = nums.Length;

    if (n == 1)
    {
        return nums[0];
    }

    while (n > 1)
    {
        int[] newNums = new int[n - 1];
        
        for (int i = 0; i < n - 1; i++)
        {
            newNums[i] = (nums[i] + nums[i + 1]) % 10;
        }
        
        nums = newNums;
        n--;
    }

    return nums[0];
}
```

---

### 方法 2: 原地修改法 (In-Place Modification)

**核心思想：** 優化空間使用，直接在原陣列上進行修改，不建立新陣列。

#### 演算法步驟

1. 使用變數 `currentLength` 追蹤當前有效長度
2. 每次運算時，直接將計算結果寫回原陣列的前面位置
3. 因為每次計算 `nums[i] = (nums[i] + nums[i+1]) % 10`，舊的 `nums[i]` 值在計算完後就不再需要
4. 逐步縮減有效長度，直到只剩一個元素

#### 複雜度分析

- **時間複雜度:** `O(n²)`
  - 與方法 1 相同的迴圈結構
  - 總操作次數: n(n-1)/2 = O(n²)

- **空間複雜度:** `O(1)`
  - 只使用常數額外空間（currentLength 變數）
  - 直接在原陣列上修改，不需要建立新陣列
  - **相較方法 1 有顯著的空間優化**

#### 優點
- 空間效率最佳，只需 O(1) 額外空間
- 時間效率與方法 1 相同
- 實際運行速度可能更快（減少記憶體配置和 GC 負擔）

#### 缺點
- 會修改原始輸入陣列（如需保留原陣列需先複製）
- 程式碼可讀性略低於方法 1

#### 程式碼範例

```csharp
public int TriangularSum_Method2(int[] nums)
{
    int currentLength = nums.Length;

    while (currentLength > 1)
    {
        for (int i = 0; i < currentLength - 1; i++)
        {
            nums[i] = (nums[i] + nums[i + 1]) % 10;
        }
        
        currentLength--;
    }

    return nums[0];
}
```

#### 運作示意圖

```
原始: [1, 2, 3, 4, 5]  (currentLength = 5)
     ↓
第1輪: [3, 5, 7, 9, 5]  (currentLength = 4, 只看前4個)
     ↓
第2輪: [8, 2, 6, 9, 5]  (currentLength = 3, 只看前3個)
     ↓
第3輪: [0, 8, 6, 9, 5]  (currentLength = 2, 只看前2個)
     ↓
第4輪: [8, 8, 6, 9, 5]  (currentLength = 1, 結果是 nums[0] = 8)
```

---

### 方法 3: 數學解法 - 二項式係數 (Binomial Coefficients)

**核心思想：** 利用數學性質，觀察到最終結果實際上是各元素乘以對應的二項式係數（楊輝三角/帕斯卡三角形的係數）後的加權和。

#### 數學原理

經過觀察和數學推導，我們發現：

```
triangularSum(nums) = Σ(nums[i] × C(n-1, i)) mod 10
```

其中：
- `n` 是陣列長度
- `C(n-1, i)` 是二項式係數，表示「從 n-1 個中選 i 個」的組合數
- 這些係數恰好對應**楊輝三角（帕斯卡三角形）**的第 n-1 行

#### 為什麼是二項式係數？

讓我們用範例理解：

對於 `nums = [1, 2, 3, 4, 5]` (n=5)：

**傳統模擬過程：**
```
[1, 2, 3, 4, 5]
[3, 5, 7, 9]      → 每個數字受到相鄰兩個原始數字的影響
[8, 2, 6]         → 繼續累積影響
[0, 8]
[8]
```

**數學分析：**

最終結果 8 實際上可以表示為：
```
1×C(4,0) + 2×C(4,1) + 3×C(4,2) + 4×C(4,3) + 5×C(4,4)
= 1×1 + 2×4 + 3×6 + 4×4 + 5×1
= 1 + 8 + 18 + 16 + 5
= 48
= 48 % 10
= 8
```

這裡的 `[1, 4, 6, 4, 1]` 正是楊輝三角第 4 行的係數！

#### 楊輝三角參考

```
第 0 行:           1
第 1 行:         1   1
第 2 行:       1   2   1
第 3 行:     1   3   3   1
第 4 行:   1   4   6   4   1
第 5 行: 1   5  10  10   5   1
...
```

每個數字等於上一行兩個相鄰數字之和，這與我們的題目過程完全對應！

#### 演算法步驟

1. 建立陣列儲存楊輝三角的係數（第 n-1 行）
2. 使用楊輝三角的性質逐行計算：每個數等於上一行相鄰兩數之和
3. 從右往左更新陣列，避免覆蓋還需使用的值
4. 在計算過程中取模 10，避免數值溢位
5. 計算加權和：將每個 `nums[i]` 乘以對應的係數並取模

#### 複雜度分析

- **時間複雜度:** `O(n²)`
  - 計算楊輝三角第 n-1 行：需要逐行計算，共 n(n-1)/2 次操作
  - 計算加權和：O(n)
  - 總時間：O(n²)
  - **注意**：雖然與方法 1、2 相同，但操作更簡單（只有加法和取模）

- **空間複雜度:** `O(n)`
  - 需要陣列儲存一行楊輝三角係數

#### 優點

- 展現數學之美，將模擬問題轉化為數學公式
- 利用楊輝三角性質，避免大數溢位問題
- 操作簡單（只有加法），實作安全可靠
- 適合理解組合數學與程式設計的結合

#### 缺點

- 需要理解二項式係數和楊輝三角的數學概念
- 程式碼可讀性較低，需要額外註解說明
- 時間複雜度與方法 1、2 相同（O(n²)）
- 相較原地修改法，需要額外 O(n) 空間

#### 程式碼範例（修正後）

**關鍵改進：避免整數溢位**

原本使用乘除法計算二項式係數會在大數組時溢位：
```csharp
// ❌ 錯誤做法：n=48 時會溢位
coefficients[i] = coefficients[i - 1] * (n - i) / i;
```

修正後使用楊輝三角的加法性質：
```csharp
// ✅ 正確做法：使用加法 + 取模，完全避免溢位
public int TriangularSum_Method3(int[] nums)
{
    int n = nums.Length;
    
    if (n == 1)
    {
        return nums[0];
    }

    // 使用楊輝三角性質逐行計算
    long[] coefficients = new long[n];
    coefficients[0] = 1;

    // 逐行計算楊輝三角，直到第 n-1 行
    for (int row = 1; row < n; row++)
    {
        // 從右往左計算，避免覆蓋還需使用的值
        for (int col = row; col > 0; col--)
        {
            // 楊輝三角性質：每個數 = 上一行相鄰兩數之和
            // 取模避免溢位
            coefficients[col] = (coefficients[col] + coefficients[col - 1]) % 10;
        }
    }

    // 計算加權和
    long result = 0;
    for (int i = 0; i < n; i++)
    {
        result = (result + (long)nums[i] * coefficients[i]) % 10;
    }

    return (int)result;
}
```

#### 詳細計算範例

對於 `nums = [1, 1, 1, 1, 1, 1]` (n=6)：

**步驟 1: 計算第 5 行的二項式係數**
```
C(5,0) = 1
C(5,1) = 1 × 5/1 = 5
C(5,2) = 5 × 4/2 = 10
C(5,3) = 10 × 3/3 = 10
C(5,4) = 10 × 2/4 = 5
C(5,5) = 5 × 1/5 = 1

係數: [1, 5, 10, 10, 5, 1]
```

**步驟 2: 計算加權和**
```
result = (1×1 + 1×5 + 1×10 + 1×10 + 1×5 + 1×1) % 10
       = 32 % 10
       = 2
```

---

---

## 方法比較：陣列 vs List

### List 版本實作

有些解法會使用 `List<int>` 而非原生陣列：

```csharp
public int TriangularSum_ListVersion(int[] nums)
{
    List<int> current = new List<int>(nums);
    
    while (current.Count > 1)
    {
        List<int> newNums = new List<int>();
        
        for (int i = 0; i < current.Count - 1; ++i)
        {
            newNums.Add((current[i] + current[i + 1]) % 10);
        }
        
        current = newNums;
    }
    
    return current[0];
}
```

### 核心差異分析

| 項目 | 方法 1 (陣列版本) | List 版本 |
|------|------------------|-----------|
| **資料結構** | `int[]` 陣列 | `List<int>` 泛型集合 |
| **記憶體配置** | 固定大小，一次配置 | 動態擴容，可能多次配置 |
| **存取效能** | 直接記憶體存取 | 包裝層存取 |
| **初始化** | `new int[n-1]` | `new List<int>()` + 多次 `Add()` |

### 效能基準測試結果

實際測試 (Release 模式，10000 次迭代)：

| 陣列大小 | 方法 1 (陣列) | List 版本 | 效能提升 | 陣列快幾倍 |
|---------|--------------|----------|---------|-----------|
| **10** | 5 ms | 6 ms | +20% | 1.2x |
| **50** | 11 ms | 87 ms | +691% | **7.9x** |
| **100** | 43 ms | 156 ms | +263% | **3.6x** |
| **500** | 1018 ms | 1932 ms | +90% | **1.9x** |
| **1000** | 3968 ms | 7261 ms | +83% | **1.8x** |

### List 效能問題分析

#### 1. 動態擴容開銷

```csharp
List<int> newNums = new List<int>();  // ⚠️ 初始容量可能為 0 或 4
for (int i = 0; i < current.Count - 1; ++i)
{
    newNums.Add(...);  // 每次 Add 可能觸發擴容
}
```

**List 擴容機制：**
- 初始容量: 0 或 4
- 第 1 次擴容: 4 → 8
- 第 2 次擴容: 8 → 16
- 第 3 次擴容: 16 → 32

每次擴容需要：
1. 配置新的更大陣列（通常 2 倍大小）
2. 複製所有現有元素到新陣列
3. 釋放舊陣列記憶體

#### 2. 效能損耗來源

- 🔴 **多次記憶體配置**：List 擴容時需要重新配置記憶體
- 🔴 **陣列複製**：擴容時需要複製所有現有元素
- 🔴 **間接存取**：List 底層是陣列包裝，有輕微額外開銷
- 🔴 **邊界檢查**：`Add()` 方法需要檢查容量

#### 3. 為什麼中型陣列（50 元素）差異最大？

- **小陣列（10）**：擴容次數少，影響有限
- **中型陣列（50）**：最能凸顯擴容的負面影響
- **大陣列（1000）**：相對而言，擴容開銷被 O(n²) 的計算時間稀釋

### List 版本優化建議

如果必須使用 List，可以預分配容量：

```csharp
// ❌ 原始版本（差）
List<int> newNums = new List<int>();

// ✅ 優化版本（好）
List<int> newNums = new List<int>(current.Count - 1);
```

但即使優化後，效能仍不及直接使用陣列。

### 結論

**效能排名（由快到慢）：**

1. 🥇 **方法 2（原地修改）** - O(1) 空間，最快且最實用
2. 🥈 **方法 1（陣列版本）** - 快速且程式碼清晰
3. 🥉 **方法 3（數學解法）** - 數學優雅但時間複雜度與方法 1、2 相同
4. 📉 **List 版本** - 效能最差，不推薦

> **💡 重要提示**：同樣的邏輯，資料結構選擇不同，效能可能相差 2-8 倍！

> **⚠️ 常見陷阱**：方法 3 使用乘除法計算二項式係數時，大陣列會導致整數溢位。務必使用楊輝三角的加法性質來避免此問題。

---

---

## 常見陷阱：整數溢位問題

### 問題描述

方法 3 的數學解法在實作時容易遇到**整數溢位**問題，這是一個重要的教訓。

### 錯誤實作示例

```csharp
// ❌ 危險：使用乘除法計算二項式係數
for (int i = 1; i < n; i++)
{
    coefficients[i] = coefficients[i - 1] * (n - i) / i;  // 可能溢位！
}
```

**問題：** 當 `n` 較大時（如 n=48），中間的二項式係數會非常大：
- C(47, 23) ≈ 1.77 × 10¹³（遠超過 `int` 的最大值 2.14 × 10⁹）
- 即使使用 `long`，更大的 `n` 值仍會溢位

### 測試案例失敗範例

```
輸入: [0,3,3,4,1,2,6,4,9,3,5,1,7,7,3,0,3,2,5,1,9,0,2,6,3,9,2,5,9,2,6,4,2,9,7,2,0,3,0,1,1,2,7,8,6,4,4,5]
長度: 48
錯誤輸出: 0 (因為溢位導致計算錯誤)
正確輸出: 5
```

### 正確解決方案

使用**楊輝三角的加法性質**，完全避免乘除法：

```csharp
// ✅ 安全：使用加法逐行計算
for (int row = 1; row < n; row++)
{
    for (int col = row; col > 0; col--)
    {
        // 楊輝三角：每個數 = 上一行相鄰兩數之和
        coefficients[col] = (coefficients[col] + coefficients[col - 1]) % 10;
    }
}
```

**優點：**
- ✅ 只使用加法，不會產生大數
- ✅ 每次計算後取模 10，數值永遠在 0-9 範圍內
- ✅ 完全避免溢位問題
- ✅ 適用於任意大小的輸入

### 關鍵啟示

1. **不要盲目套用數學公式** - 數學上正確的公式在程式實作時可能有數值問題
2. **注意數據範圍** - 題目限制 n ≤ 1000，但中間計算值可能遠超此範圍
3. **使用模運算性質** - `(a+b) % m = ((a%m) + (b%m)) % m` 可以控制數值大小
4. **選擇合適的演算法** - 有時改變演算法比使用更大的資料型別更有效

---

## 三種方法比較表

| 方法 | 時間複雜度 | 空間複雜度 | 優點 | 適用場景 |
|------|-----------|-----------|------|---------|
| **方法 1: 模擬法** | O(n²) | O(n) | 程式碼清晰、易於理解 | 小規模數據、教學用途 |
| **方法 2: 原地修改** | O(n²) | O(1) | 空間效率最佳 | 記憶體受限環境、最佳實務 |
| **方法 3: 數學解法** | O(n²) | O(n) | 數學優雅、避免溢位 | 展示數學知識、學習用途 |
| **List 版本** | O(n²) | O(n) | - | ❌ 不推薦使用 |

> **💡 效能建議**：方法 2（原地修改）是生產環境的最佳選擇，方法 1 適合理解題意，方法 3 展現數學之美。

## 測試結果

專案包含 5 組測試案例，涵蓋各種情境：

```
測試 1 - 基本範例: [1, 2, 3, 4, 5] → 8
測試 2 - 單一元素: [5] → 5
測試 3 - 兩個元素: [9, 8] → 7
測試 4 - 包含零: [0, 0, 0] → 0
測試 5 - 重複元素: [1, 1, 1, 1, 1, 1] → 2
```

所有三種方法在所有測試案例中均產生一致的正確結果。

## 執行專案

### 前置需求

- .NET 8.0 或更高版本

### 建構與執行

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run --project leetcode_2221/leetcode_2221.csproj
```

### 預期輸出

```
測試 1 - 輸入: [1, 2, 3, 4, 5]
方法 1 結果: 8
方法 2 結果: 8
方法 3 結果: 8

測試 2 - 輸入: [5]
方法 1 結果: 5
方法 2 結果: 5
方法 3 結果: 5

... (其他測試案例)
```

## 程式碼結構

```
leetcode_2221/
├── Program.cs          # 主程式，包含三種解法和測試案例
├── leetcode_2221.csproj
└── README.md          # 本文件
```

### 執行效能測試

專案包含完整的效能基準測試，可以執行以下指令查看詳細的效能比較：

```bash
# 以 Release 模式執行（獲得最佳效能數據）
dotnet run --project leetcode_2221/leetcode_2221.csproj -c Release
```

輸出將包含：
- 5 組功能測試案例的結果
- 不同陣列大小下的效能基準測試
- 陣列版本 vs List 版本的詳細效能對比

---

## 學習重點

1. **演算法優化思維**
   - 從直觀模擬到空間優化
   - 從模擬到數學建模

2. **時間與空間權衡**
   - 理解不同解法的取捨
   - 根據實際場景選擇合適方案

3. **數學在程式設計中的應用**
   - 二項式係數的計算
   - 楊輝三角的性質
   - 將問題抽象為數學公式

4. **C# 程式設計實踐**
   - 陣列操作技巧
   - 原地修改 vs 建立新結構
   - 程式碼可讀性與效能的平衡

5. **資料結構選擇的重要性**
   - 陣列 vs List 的效能差異
   - 記憶體配置策略的影響
   - 實際測試勝過理論推測

## 延伸思考

1. **為什麼取模 10？**
   - 限制數值範圍，避免溢位
   - 實際上只關心個位數

2. **能否進一步優化方法 3？**
   - 考慮使用費馬小定理優化模運算
   - 考慮使用快速冪計算大組合數

3. **這個問題與其他經典問題的關聯**
   - 帕斯卡三角形
   - 動態規劃中的組合數應用
   - 數字三角形路徑問題

## 參考資源

- [LeetCode 2221 - English](https://leetcode.com/problems/find-triangular-sum-of-an-array/)
- [LeetCode 2221 - 中文](https://leetcode.cn/problems/find-triangular-sum-of-an-array/)
- [楊輝三角（帕斯卡三角形）](https://zh.wikipedia.org/wiki/杨辉三角形)
- [二項式係數](https://zh.wikipedia.org/wiki/二项式系数)

## 授權

此專案的程式碼可自由用於學習和參考用途。

---

**Happy Coding! 🚀**
