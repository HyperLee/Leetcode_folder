# 打家劫舍 II：環形街道問題解析

## 為什麼以「不包含最後一間」和「不包含第一間」為思考方向

這種思考方向的關鍵在於題目的特殊限制 - 房屋呈環形排列，意味著第一間和最後一間房屋被視為相鄰。

## 環形排列的核心問題

在環形街道中，如果我們想遵守「不能同時搶劫相鄰房屋」的規則，第一間和最後一間房屋不能同時選擇。這就產生了一個關鍵約束：

- 如果搶劫第一間房屋，就**不能搶劫最後一間**
- 如果搶劫最後一間房屋，就**不能搶劫第一間**

## 拆解為兩個子問題

基於上述約束，我們可以將環形問題轉化為兩個線性問題：

### 1. 不包含最後一間房屋

- 只考慮從索引 0 到 n-2 的房屋
- 這確保我們可以自由選擇是否搶劫第一間房屋，而不必擔心與最後一間的相鄰關係

### 2. 不包含第一間房屋

- 只考慮從索引 1 到 n-1 的房屋
- 這確保我們可以自由選擇是否搶劫最後一間房屋，而不必擔心與第一間的相鄰關係

## 為什麼這種拆分是有效的

這種拆分涵蓋了所有可能的最優解情境：

1. 如果最優解包含第一間房屋，那麼必然不包含最後一間，這種情況在「不包含最後一間」的子問題中會被找到
2. 如果最優解包含最後一間房屋，那麼必然不包含第一間，這種情況在「不包含第一間」的子問題中會被找到
3. 如果最優解既不包含第一間也不包含最後一間，那麼這個解在兩個子問題中都會被找到

因此，我們只需分別解決這兩個子問題，然後取其最大值，就能得到原問題的最優解。這是處理環形約束的經典技巧。

## 演算法實作重點

- 將問題拆分為兩個子問題
- 對每個子問題使用動態規劃求解
- 取兩個子問題結果的最大值作為最終答案

```csharp
// 關鍵演算法要點
return Math.Max(RobRange(nums, 0, n - 2), RobRange(nums, 1, n - 1));