# 題目描述 (繁體中文)

你會得到兩個長度相同的字串 `s1` 和 `s2`，以及另一個字串 `baseStr`。

我們定義：若 `s1[i]` 和 `s2[i]` 在同一位置上，則 `s1[i]` 與 `s2[i]` 是等價的字元。

舉個例子：如果 `s1 = "abc"` 且 `s2 = "cde"`，那麼我們有以下等價關係：

- `'a'` 等價於 `'c'`
- `'b'` 等價於 `'d'`
- `'c'` 等價於 `'e'`

這些等價字元遵循等價關係的三個基本規則：

- **反身性 (Reflexivity)**：每個字元與自己等價，例如 `'a' == 'a'`。
- **對稱性 (Symmetry)**：如果 `'a' == 'b'`，那麼 `'b' == 'a'`。
- **傳遞性 (Transitivity)**：如果 `'a' == 'b'` 且 `'b' == 'c'`，那麼 `'a' == 'c'`。

基於這些等價關係，許多字串可能都是 `baseStr` 的等價字串。

例如，根據 `s1 = "abc"` 與 `s2 = "cde"` 的資訊：

- `baseStr = "eed"` 的等價字串可以是 `"acd"` 或 `"aab"`。
- 在所有等價字串中，`"aab"` 是字典序最小的。

---

## 任務

請你根據從 `s1` 和 `s2` 得到的等價關係，回傳 `baseStr` 所有等價字串中，字典序最小的那一個。

---

## 題目說明

這題是 LeetCode 第 1061 題「依字典序排列最小的等效字串」。題目給你三個字串：`s1`、`s2` 和 `baseStr`。`s1` 和 `s2` 長度相同，代表每一對位置上的字元是等價的。等價關係具有**反身性**、**對稱性**、**轉移性**，也就是說只要透過這些規則連結起來的字元都算等價。

你的任務是 **根據這些等價關係，把 `baseStr` 轉換成所有等價字串中，字典序最小的那一個**。

---

### 範例

假設：

- `s1 = "abc"`
- `s2 = "cde"`
- `baseStr = "eed"`

等價關係如下：

- `'a'` 等價 `'c'`
- `'b'` 等價 `'d'`
- `'c'` 等價 `'e'`

這些關係可以串起來，例如 `'a'` 也等價 `'e'`，因為 `'a' == 'c'`，`'c' == 'e'`。

`baseStr = "eed"`，你可以把每個字元換成它等價類中**字典序最小**的字元，所以：

- `'e'` 的等價類有 `'a'`, `'c'`, `'e'`，最小的是 `'a'`
- `'d'` 的等價類有 `'b'`, `'d'`，最小的是 `'b'`

所以答案是 `"aab"`。

---

### 重點

- 等價關係可以用**並查集 (Union-Find)**  來管理。
- 最後要找出每個字元等價類中**字典序最小**的字元來替換。

這題考察你對等價關係、並查集資料結構，以及如何處理字典序的理解。

## 解題流程說明

### 1. 建立 UnionFind 物件

- 先建立一個 UnionFind 物件，管理 26 個小寫英文字母 (a~z)，每個字母初始時各自為一個集合。

### 2. 合併等價關係

- 用 for 迴圈遍歷 s1 和 s2，每一對相同位置的字元 (s1[i], s2[i]) 都呼叫 Union，把它們合併到同一個集合。
- Union 操作時，會將字典序較小的字元設為集合代表，確保每個集合的根節點永遠是字典序最小的字元。

### 3. 查詢 baseStr 的最小等價字串

- 建立一個 char 陣列 result，長度等於 baseStr。
- 用 for 迴圈遍歷 baseStr，對每個字元呼叫 Find，取得其等價類的代表字元 (即字典序最小的字元)，並存入 result。

### 4. 回傳結果

- 將 result 陣列轉成字串並回傳，就是 baseStr 所有等價字串中字典序最小的那一個。

---

### 核心資料結構與技巧

- **UnionFind 物件**：用 parent 陣列記錄每個字元的父節點，支援合併與查找操作。
- **路徑壓縮**：Find 操作會讓所有經過的節點直接指向根節點，加速未來查詢。
- **字典序最小**：Union 操作時，總是讓字典序較小的字元成為根，確保查詢時能直接取得最小字元。

---

### 範例流程

假設 s1 = "abc", s2 = "cde", baseStr = "eed"：

1. 合併等價關係後，'a', 'c', 'e' 在同一集合，代表字元為 'a'；'b', 'd' 在同一集合，代表字元為 'b'。
2. 查詢 baseStr：
   - 'e' → 'a'
   - 'e' → 'a'
   - 'd' → 'b'
3. 回傳結果 `"aab"`。