# LeetCode 3510: Minimum Pair Removal to Sort Array II

使陣列有序的最少移除數對數 II

## 題目說明

給定一個整數陣列 `nums`，你可以重複執行以下操作任意次數：

1. **選擇**陣列中相鄰且和最小的一對元素。若存在多個這樣的數對，選取**最左邊**的那一對。
2. **合併**這對元素，用它們的和替換原本的兩個元素。

回傳使陣列變為**非遞減**所需的最少操作次數。

> [!NOTE]
> 若陣列為非遞減，則對於每個索引 `i > 0` 都滿足 `nums[i] >= nums[i-1]`。

### 範例

**範例 1:**
```
輸入: nums = [5, 2, 3, 1]
輸出: 2

執行過程:
[5, 2, 3, 1] → 選擇 (3,1)，和為 4 → [5, 2, 4]
[5, 2, 4]    → 選擇 (2,4)，和為 6 → [5, 6]
[5, 6] 已為非遞減，共執行 2 次操作
```

**範例 2:**
```
輸入: nums = [1, 2, 2]
輸出: 0

陣列已經是非遞減，不需要任何操作
```

### 限制條件

- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

---

## 解題思路

### 為什麼朴素模擬會超時？

本題是「3507. 移除最小數對使數組有序 I」的數據增強版。在朴素模擬中，每次操作需要：

1. 掃描整個陣列找最小和數對：O(n)
2. 執行合併操作：O(n)
3. 最壞情況需要 O(n) 次操作

總時間複雜度為 O(n²)，在 `n = 10^5` 的數據規模下會超時。

### 優化策略

我們需要對三個關鍵邏輯進行優化：

| 操作 | 朴素方法 | 優化方法 |
|------|---------|---------|
| 尋找最小相鄰數對和 | O(n) 掃描 | **優先佇列** O(log n) |
| 判斷陣列單調性 | O(n) 掃描 | **遞減計數器** O(1) |
| 合併元素 | O(n) 陣列操作 | **雙向鏈結串列** O(1) |

---

## 演算法詳解

### 1. 優先佇列 + 惰性刪除

使用**最小堆**（優先佇列）維護所有相鄰數對，每次取出和最小的數對進行合併。

#### 為什麼優先佇列取出的一定是最小的？

這是優先佇列與一般佇列、堆疊的核心差異：

| 資料結構 | 取出順序 | 取出方法 | 使用場景 |
| -------- | -------- | -------- | -------- |
| **Queue（一般佇列）** | FIFO（先進先出） | 第一個加入的最先取出 | 排隊系統 |
| **Stack（堆疊）** | LIFO（後進先出） | 最後加入的最先取出 | 函式呼叫堆疊 |
| **PriorityQueue（優先佇列）** | **依優先順序** | 優先順序最高的最先取出 | 任務排程、最短路徑 |

**優先佇列的內部實作是最小堆（Min-Heap）**，這是一種特殊的二元樹結構：

```text
        (3,1) 和=4      ← 根節點永遠是最小值
       /          \
   (5,2) 和=7    (2,3) 和=5
```

**堆的特性**：父節點的值永遠 ≤ 子節點的值，因此根節點永遠是最小值。

#### C# PriorityQueue 的使用方式

```csharp
// 建立優先佇列：PriorityQueue<元素類型, 優先順序類型>
var pq = new PriorityQueue<Item, Item>();

// 加入元素：Enqueue(元素, 優先順序)
pq.Enqueue(item, item);

// 取出優先順序最小的元素（不是第一個加入的！）
var minItem = pq.Dequeue();
```

#### 如何定義「誰比較小」？

透過實作 `IComparable<T>` 介面來定義比較規則：

```csharp
public class Item : IComparable<Item>
{
    public int CompareTo(Item? other)
    {
        // 1. 優先比較成本（數對和），成本較小者優先
        if (cost != other.cost)
            return cost.CompareTo(other.cost);
        
        // 2. 成本相同時，位置較左者優先（符合題目要求）
        return first.left.CompareTo(other.first.left);
    }
}
```

這段程式碼定義：

- **主要排序**：數對和越小，優先順序越高
- **次要排序**：和相同時，位置越左，優先順序越高

#### 範例演示

假設依序加入以下數對：

```text
加入順序:
1. (5,2) 和=7
2. (2,3) 和=5  
3. (3,1) 和=4

取出順序（按優先順序，非加入順序）:
1. (3,1) 和=4  ← 最小
2. (2,3) 和=5
3. (5,2) 和=7  ← 最大
```

即使 `(5,2)` 最先加入，但因為它的和最大，所以最後才被取出。這就是優先佇列的核心價值：**自動維護元素的優先順序，每次都能在 O(log n) 時間內取出最小（或最大）的元素**。

#### 惰性刪除的必要性

當合併數對 `(i, j)` 後：
- 新數對 `(i-1, merged)` 和 `(merged, j+1)` 需要加入佇列
- 舊數對 `(i-1, i)` 和 `(j, j+1)` 變成**髒資料**

直接刪除優先佇列中的元素需要 O(n) 時間，因此使用惰性刪除：在取出時判斷是否有效。

#### 判斷髒資料的方法

```
1. merged[first.left] == true  → first 節點已被合併
2. merged[second.left] == true → second 節點已被合併  
3. first.value + second.value ≠ cost → 數對和已改變
```

### 2. 維護遞減計數器

使用變數 `decreaseCount` 追蹤有多少對相鄰元素滿足 `nums[i] > nums[i+1]`：

- 當 `decreaseCount == 0` 時，陣列已非遞減
- 每次合併時更新計數器

#### 更新規則

設合併數對為 `(first, second)`，合併後值為 `cost = first + second`：

| 情況 | 條件 | decreaseCount 變化 |
|------|------|-------------------|
| 原數對遞減消失 | `first > second` | -1 |
| 前驅關係變化 | `prev > first` → `prev <= cost` | -1 |
| 前驅關係變化 | `prev <= first` → `prev > cost` | +1 |
| 後繼關係變化 | `second > next` → `cost <= next` | -1 |
| 後繼關係變化 | `second <= next` → `cost > next` | +1 |

### 3. 雙向鏈結串列

使用雙向鏈結串列維護元素，支援 O(1) 的刪除與重新連接：

```
合併前: ... ⟷ prev ⟷ first ⟷ second ⟷ next ⟷ ...
合併後: ... ⟷ prev ⟷ first(=cost) ⟷ next ⟷ ...
```

---

## 流程演示

以 `nums = [5, 2, 3, 1]` 為例：

### 初始化

```
建立鏈結串列: 5 ⟷ 2 ⟷ 3 ⟷ 1

優先佇列（按數對和排序）:
  (2,3) 和=5
  (5,2) 和=7
  (3,1) 和=4  ← 最小

decreaseCount = 2（5>2 和 3>1 兩對遞減）
```

### 第一次合併

```
取出 (3,1)，和=4
檢查有效性：✓ 有效

合併前: 5 ⟷ 2 ⟷ 3 ⟷ 1
合併後: 5 ⟷ 2 ⟷ 4

更新 decreaseCount:
  - 3>1 遞減關係消失: -1
  - 2≤3 → 2≤4（無變化）
  
decreaseCount = 1
count = 1

新增數對 (2,4) 和=6 到佇列
```

### 第二次合併

```
優先佇列:
  (5,2) 和=7
  (2,3) 和=5  ← 髒資料（3 已不存在）
  (2,4) 和=6

取出 (2,3)，檢查有效性：✗ 髒資料，跳過
取出 (2,4)，檢查有效性：✓ 有效

合併前: 5 ⟷ 2 ⟷ 4
合併後: 5 ⟷ 6

更新 decreaseCount:
  - 2≤4（非遞減，無變化）
  - 5>2 → 5≤6: -1

decreaseCount = 0
count = 2
```

### 結束

`decreaseCount == 0`，陣列 `[5, 6]` 已非遞減。

**答案：2**

---

## 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n log n) | 每個元素最多被合併一次，每次合併涉及 O(log n) 的佇列操作 |
| 空間複雜度 | O(n) | 儲存節點和優先佇列 |

---

## 執行專案

### 前置需求

- [.NET 10 SDK](https://dotnet.microsoft.com/download)

### 建構與執行

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run --project leetcode_3510
```

### 預期輸出

```
範例 1: nums = [5, 2, 3, 1]
結果: 2

範例 2: nums = [1, 2, 2]
結果: 0

範例 3: nums = [3, 2, 1]
結果: 1

範例 4: nums = [1]
結果: 0
```

---

## 相關題目

- [3507. Minimum Pair Removal to Sort Array I](https://leetcode.com/problems/minimum-pair-removal-to-sort-array-i/) - 本題的基礎版本
