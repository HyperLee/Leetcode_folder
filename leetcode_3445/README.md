# LeetCode 3445 - 奇偶頻次間的最大差值 II

## 題目描述

給定一個字串 `s` 和一個整數 `k`，你需要找到一個長度至少為 `k` 的子字串，使得某個字元的奇數頻率與另一個字元的偶數頻率之間的差值最大。

### 問題條件
- 字串 `s` 只包含數字字元 '0' 到 '4'
- 子字串長度必須 ≥ k
- 計算 `freq[x] - freq[y]` 的最大值，其中 `freq[x]` 為奇數，`freq[y]` 為偶數

## 解題方法概述

本解法使用**滑動視窗 + 前綴和技巧**的組合演算法：

1. **外層雙迴圈枚舉**：遍歷所有可能的字元對 `(x, y)`
2. **滑動視窗維護**：確保子字串長度 ≥ k
3. **奇偶性追蹤**：使用位元運算處理奇偶性
4. **最佳化記錄**：記錄歷史最小差值來優化計算

## 演算法詳細解析

### 1. 初始化設計

```csharp
const int INF = int.MaxValue / 2;
```

**INF 常數的作用**：設為 `int.MaxValue / 2` 而非 `int.MaxValue`，這是為了防止後續計算時的整數溢位問題。當進行減法運算時，避免了潛在的數值範圍超出限制。

### 2. 外層雙迴圈策略

```csharp
for (int x = 0; x < 5; x++) {
    for (int y = 0; y < 5; y++) {
```

**枚舉策略**：這裡枚舉了 5×5 = 25 種字元對組合。雖然題目要求 `x` 為奇數頻率、`y` 為偶數頻率，但演算法會在執行過程中動態判斷奇偶性，因此需要考慮所有可能的字元組合。

### 3. 位元運算技巧

```csharp
curS[x] & 1        // 判斷奇偶性：奇數為1，偶數為0
curS[x] & 1 ^ 1    // 翻轉奇偶性：奇數變偶數，偶數變奇數
```

**位元運算巧思**：
- `& 1` 用於提取最低位，判斷數字的奇偶性
- `^ 1` 用於翻轉最低位，實現奇偶性轉換

### 4. minS 陣列索引設計

```csharp
int[,] minS = new int[2, 2];
minS[p, q] // p=字元x的奇偶性, q=字元y的奇偶性
```

**索引設計巧思**：
- `minS[0,0]`：x偶數，y偶數
- `minS[0,1]`：x偶數，y奇數  
- `minS[1,0]`：x奇數，y偶數
- `minS[1,1]`：x奇數，y奇數

這樣的設計允許演算法根據當前字元頻率的奇偶性快速查找對應的歷史最小值。

### 5. 滑動視窗機制

```csharp
while (right - left + 1 >= k && (curS[x] > 0 || curS[y] > 0)) {
    // 取最小值：記錄當前左邊界的差值
    minS[preS[x] & 1, preS[y] & 1] = Math.Min(minS[preS[x] & 1, preS[y] & 1], preS[x] - preS[y]);
    
    // 計算左邊界：為下次迭代準備
    left = Math.Max(left, Math.Max(leftBoundary[x], leftBoundary[y]));
}
```

**為什麼要取最小值**：我們記錄歷史上的最小差值 `preS[x] - preS[y]`，這樣在後續計算 `curS[x] - curS[y] - minS[...]` 時，減去最小的歷史值能得到最大的結果。

**為什麼計算左邊界**：`leftBoundary[x]` 和 `leftBoundary[y]` 記錄了字元 x 和 y 最後一次出現的位置。取其最大值確保滑動視窗包含這兩個字元。

### 6. 兩階段演算法設計

**第一階段（記錄階段）**：
```csharp
minS[preS[x] & 1, preS[y] & 1] = Math.Min(minS[preS[x] & 1, preS[y] & 1], preS[x] - preS[y]);
```

**第二階段（計算階段）**：
```csharp
ans = Math.Max(ans, curS[x] - curS[y] - minS[curS[x] & 1 ^ 1, curS[y] & 1]);
```

**設計思想**：先記錄歷史狀態，再基於當前狀態計算最大差值。關鍵在於使用 `^1` 來尋找與當前奇偶性相反的歷史記錄，確保滿足「奇數頻率 - 偶數頻率」的條件。

## 常見問題解答

### Q1: 為什麼 INF 設為 int.MaxValue / 2？
**A1**: 防止後續減法運算時發生整數溢位。使用 `/2` 提供了安全的數值範圍緩衝。

### Q2: 外層雙迴圈為什麼要枚舉 25 種組合？
**A2**: 雖然題目要求奇偶特定組合，但演算法在執行時會動態判斷奇偶性，因此需要考慮所有可能的字元對以找到最優解。

### Q3: 位元運算 `& 1` 和 `^ 1` 的作用？
**A3**: `& 1` 用於快速判斷奇偶性，`^ 1` 用於翻轉奇偶性。這種位元運算技巧比使用 `% 2` 更高效。

### Q4: minS 陣列的索引設計有什麼巧思？
**A4**: 使用二維陣列 `minS[p,q]` 其中 p 和 q 分別代表兩個字元頻率的奇偶性，允許演算法根據當前狀態快速查找對應的歷史最小值。

## 演算法複雜度分析

- **時間複雜度**：O(n)
  - 外層雙迴圈：O(25) = O(1)
  - 內層字串遍歷：O(n)
  - 滑動視窗操作：每個位置最多訪問常數次
  
- **空間複雜度**：O(1)
  - 固定大小的陣列：curS[5], preS[5], minS[2,2], leftBoundary[5]
  - 不隨輸入規模變化

## 方法二：枚舉字元 + 雙指針技巧

### 演算法核心思想

方法二採用了更加直觀的雙指針方法，結合奇偶性狀態編碼來解決問題。其核心創新在於**狀態編碼系統**和**異或運算**的巧妙結合。

### 關鍵技術原理

#### 1. 奇偶性狀態編碼系統

```csharp
/// <summary>
/// 計算兩個字元頻率的奇偶性狀態
/// 狀態編碼：(字元a奇偶性) × 2 + (字元b奇偶性)
/// </summary>
private static int GetStatus(int cntA, int cntB)
{
    return (cntA % 2) * 2 + (cntB % 2);
}
```

**狀態對應表**：

| 狀態值 | 二進位 | cntA | cntB | 說明 |
|-------|-------|------|------|------|
| 0 | 00 | 偶數 | 偶數 | 兩者都是偶數頻率 |
| 1 | 01 | 偶數 | 奇數 | A偶數，B奇數 |
| 2 | 10 | 奇數 | 偶數 | A奇數，B偶數 ← **目標狀態** |
| 3 | 11 | 奇數 | 奇數 | 兩者都是奇數頻率 |

#### 2. 異或運算的狀態轉換

```csharp
// 關鍵操作：rightStatus ^ 0b10
// 0b10 = 2，這個異或運算有特殊含義
```

**異或轉換邏輯**：

| 當前狀態 | 異或 0b10 | 目標狀態 | 轉換意義 |
|---------|----------|---------|----------|
| 0 (00) | ^ 10 | 2 (10) | 偶偶 → 奇偶 |
| 1 (01) | ^ 10 | 3 (11) | 偶奇 → 奇奇 |
| 2 (10) | ^ 10 | 0 (00) | 奇偶 → 偶偶 |
| 3 (11) | ^ 10 | 1 (01) | 奇奇 → 偶奇 |

**設計巧思**：異或運算 `^ 0b10` 正好翻轉字元A的奇偶性，保持字元B的奇偶性不變。這樣可以找到與當前狀態「互補」的歷史狀態。

#### 3. 雙指針移動策略

```csharp
// 右指針擴展：遍歷所有可能的右邊界
for (int right = 0; right < n; right++) {
    // 更新字元頻率
    if (s[right] - '0' == a) cntA++;
    if (s[right] - '0' == b) cntB++;
    
    // 左指針收縮：滿足條件時記錄狀態並移動
    while (right - left >= k && cntB - prevB >= 2) {
        // 記錄歷史狀態
        // 移動左指針
    }
}
```

**移動條件解析**：

1. **`right - left >= k`**：確保子字串長度至少為 k
2. **`cntB - prevB >= 2`**：確保字元 b 在當前視窗中出現偶數次且非零

### 演算法流程詳解

#### 步驟一：狀態記錄階段

```csharp
// 計算當前左邊界的狀態
int leftStatus = GetStatus(prevA, prevB);
// 記錄歷史最小差值
best[leftStatus] = Math.Min(best[leftStatus], prevA - prevB);
```

**記錄策略**：在左指針移動之前，記錄當前左邊界的差值 `prevA - prevB`。這個差值代表了某種奇偶性組合下的歷史狀態。

#### 步驟二：最大差值計算階段

```csharp
// 計算當前右邊界的狀態
int rightStatus = GetStatus(cntA, cntB);
// 尋找互補狀態並計算最大差值
if (best[rightStatus ^ 0b10] != int.MaxValue) {
    ans = Math.Max(ans, (cntA - cntB) - best[rightStatus ^ 0b10]);
}
```

**計算邏輯**：

1. 當前右邊界差值：`cntA - cntB`
2. 查找互補狀態：`rightStatus ^ 0b10`
3. 歷史最小差值：`best[rightStatus ^ 0b10]`
4. 最終結果：`(cntA - cntB) - best[...]`

### 數學原理解釋

#### 為什麼要減去歷史最小值

假設我們有區間 `[i, j]`，其中：

- 左邊界 i 的差值：`leftDiff = prefixA[i] - prefixB[i]`
- 右邊界 j 的差值：`rightDiff = prefixA[j] - prefixB[j]`
- 子區間 `[i+1, j]` 的差值：`rightDiff - leftDiff`

為了讓 `rightDiff - leftDiff` 最大，我們需要 `leftDiff` 最小。因此演算法記錄歷史最小值，然後用當前值減去最小值。

#### 異或運算的數學意義

```csharp
rightStatus ^ 0b10
```

這個操作在數學上等價於：

- 如果當前 A 是奇數頻率，我們尋找歷史上 A 為偶數頻率的狀態
- 如果當前 A 是偶數頻率，我們尋找歷史上 A 為奇數頻率的狀態
- B 的奇偶性保持不變

這正好符合題目要求：「奇數頻率 - 偶數頻率」。

### 最佳化特點總結

1. **狀態壓縮**：用 0-3 四個數值表示所有奇偶性組合
2. **異或巧思**：一次運算找到互補狀態
3. **雙指針效率**：每個位置最多訪問常數次
4. **記錄策略**：記錄最小值以計算最大差值

### 與方法一的本質區別

| 比較項目 | 方法一 | 方法二 |
|---------|-------|-------|
| **狀態表示** | 位元運算 `& 1` | 數值編碼 `(a%2)*2 + (b%2)` |
| **狀態查找** | `curS[x] & 1 ^ 1` | `rightStatus ^ 0b10` |
| **資料結構** | 二維陣列 `minS[2,2]` | 一維陣列 `best[4]` |
| **語意化程度** | 較低（需要理解位運算） | 較高（狀態編碼直觀） |

方法二的創新在於將複雜的位元運算轉換為更直觀的狀態編碼，同時保持了相同的演算法效率。

## 方法一與方法二比較分析

### 演算法設計理念

| 比較項目 | 方法一（滑動視窗 + 前綴和） | 方法二（雙指針 + 狀態編碼） |
|---------|---------------------------|---------------------------|
| **核心思想** | 記錄歷史最小差值，計算當前最大差值 | 狀態編碼配合異或運算找互補狀態 |
| **資料結構** | 二維陣列 `minS[2,2]` | 一維陣列 `best[4]` |
| **狀態表示** | 位元運算 `& 1` 判斷奇偶性 | 數值編碼 `(cntA%2)*2 + (cntB%2)` |
| **最佳化策略** | `curS[x] & 1 ^ 1` 找互補奇偶性 | `rightStatus ^ 0b10` 找目標狀態 |

### 複雜度比較

| 比較項目 | 方法一 | 方法二 |
|---------|-------|-------|
| **時間複雜度** | O(25n) = O(n) | O(25n) = O(n) |
| **空間複雜度** | O(1) | O(1) |
| **常數因子** | 較大（25個字元對 × 內層操作） | 較小（25個字元對，更簡潔的內層邏輯） |
| **實際效能** | 略慢於方法二 | 略快於方法一 |

### 實作特點分析

#### 方法一優勢

1. **演算法經典性**：體現了競程中常見的「記錄最值」思想
2. **技巧豐富度**：包含滑動視窗、前綴和、位元運算等多種技巧
3. **數學美感**：`curS[x] - curS[y] - minS[...]` 的計算公式優雅
4. **教學價值**：適合學習多種演算法技巧的組合應用

#### 方法二優勢

1. **邏輯清晰度**：雙指針移動邏輯更直觀易懂
2. **狀態管理**：數值編碼系統比位元運算更容易理解
3. **程式碼簡潔性**：實作相對簡潔，邏輯層次分明
4. **除錯友善性**：狀態追蹤和除錯更加方便

### 技術深度比較

#### 位元運算技巧

- **方法一**：`& 1`, `^ 1` 的巧妙運用，體現位元運算的精髓
- **方法二**：`^ 0b10` 異或運算，更具語意化的狀態轉換

#### 陣列索引設計

- **方法一**：`minS[p,q]` 二維陣列，索引含義需要仔細思考
- **方法二**：`best[4]` 一維陣列，狀態編碼更加直觀

#### 條件判斷邏輯

- **方法一**：複雜的滑動視窗條件，需要同時考慮多個因素
- **方法二**：清晰的雙指針條件，每個條件目的明確

### 學習建議與選擇

#### 適合方法一的情況

1. **競程訓練**：想要學習多種演算法技巧的組合應用
2. **面試準備**：希望展示對位元運算和滑動視窗的深度理解
3. **演算法研究**：關注經典演算法模式的應用

#### 適合方法二的情況

1. **工程實作**：需要程式碼可讀性和維護性
2. **快速開發**：追求實作效率和除錯便利性
3. **教學場景**：希望邏輯清晰，容易解釋和理解

### 效能實測建議

為了實際比較兩種方法的效能，建議進行以下測試：

```csharp
// 大規模測試資料
string largeTestCase = new string('0', 100000) + new string('1', 100000);
int k = 50000;

// 測試兩種方法的執行時間
Stopwatch sw1 = Stopwatch.StartNew();
int result1 = MaxDifference(largeTestCase, k);
sw1.Stop();

Stopwatch sw2 = Stopwatch.StartNew();  
int result2 = MaxDifference2(largeTestCase, k);
sw2.Stop();

Console.WriteLine($"方法一：{sw1.ElapsedMilliseconds}ms");
Console.WriteLine($"方法二：{sw2.ElapsedMilliseconds}ms");
```

## 總結與啟發

### 演算法設計啟發

1. **多解法思維**：同一個問題往往有多種有效的解決方案
2. **技巧組合**：複雜問題通常需要多種演算法技巧的巧妙組合
3. **權衡考量**：效能與可讀性之間需要根據具體需求進行權衡

### 競程技巧總結

1. **位元運算**：在處理奇偶性、狀態轉換時非常有效
2. **滑動視窗**：處理子陣列/子字串問題的經典方法
3. **狀態編碼**：將複雜狀態編碼為數值，便於查找和比較
4. **雙指針**：在滿足條件的範圍內尋找最優解的有效策略

### 程式碼品質提升

1. **註解完整性**：詳細的中文註解提升程式碼可讀性
2. **變數命名**：有意義的變數名稱幫助理解邏輯
3. **邏輯分層**：將複雜邏輯分解為清晰的步驟
4. **測試充分性**：多樣化的測試案例確保解法正確性

這兩種方法都是優秀的解決方案，選擇哪一種主要取決於具體的使用場景和個人偏好。在競程中，通常優先考慮實作速度和正確性；在工程專案中，則更注重程式碼的可維護性和可理解性。

## 相關資源

- **原題連結**：[LeetCode 3445](https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-ii/)
- **相關題目**：LeetCode 上其他涉及字元頻率和滑動視窗的問題
- **演算法學習**：建議深入學習滑動視窗和雙指針技巧的其他應用

---

### 專案資訊

- 語言：C# (.NET 8.0)
- 開發環境：Visual Studio Code
- 測試通過：5個綜合測試案例
- 文件更新：2024年完整版