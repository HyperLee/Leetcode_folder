# LeetCode 989 — Add to Array-Form of Integer

> **難度**：Easy　｜　**標籤**：Array, Math

---

## 題目說明

整數 `num` 的**陣列形式（Array-Form）**是一個由左到右依序存放每位數字的陣列。  
例如，`num = 1321` 的陣列形式為 `[1, 3, 2, 1]`。

給定整數的陣列形式 `num` 以及一個整數 `k`，請回傳 `num + k` 的陣列形式。

**範例：**

| 輸入 `num`     | 輸入 `k` | 輸出            |
|---------------|---------|----------------|
| `[1, 2, 0, 0]` | `34`    | `[1, 2, 3, 4]` |
| `[2, 7, 4]`    | `181`   | `[4, 5, 5]`    |
| `[2, 1, 5]`    | `806`   | `[1, 0, 2, 1]` |

**限制條件：**

- `1 <= num.length <= 10^4`
- `0 <= num[i] <= 9`
- `num` 不含前導零（除非 `num = [0]`）
- `1 <= k <= 10^4`

---

## 解題核心觀念

加法的本質是**逐位相加、處理進位**。不論是在紙上做直式加法，還是在程式中操作，都必須從最低位（個位數）開始，遇到 ≥ 10 的結果就保留個位值並向上進位。

三種解法都圍繞這個核心展開，但切入角度不同：

| 解法   | 核心思路                                   | 優點               | 缺點                   |
|--------|--------------------------------------------|--------------------|------------------------|
| 方法一 | 類比直式加法，逐位拆解 `k` 的每一位與陣列對應位相加 | 邏輯清晰直觀       | 略為繁瑣，需額外迴圈處理 `k` 剩餘位 |
| 方法二 | 先將陣列整體還原為整數，再與 `k` 相加      | 程式碼最短         | 有整數溢位風險，結果格式不符要求 |
| 方法三 | 把整個 `k` 直接加到陣列最低位，進位自然向高位擴散 | 迴圈最精簡、邏輯統一 | 稍需理解「k 同時作為加數與進位暫存器」的用法 |

---

## 解法詳解

### 方法一：逐位相加（Digit-by-Digit）

**出發點**：模擬手算加法，從右到左一位一位加。

```
[1, 2, 0, 0]  +  34
           ↑
      從這裡開始，每次取 k % 10 與 num[i] 相加
```

**步驟：**

1. 從陣列最右邊（索引 `n-1`）往左走。
2. 每輪取 `k % 10`（k 的個位）與 `num[i]` 相加得 `sum`，然後 `k /= 10`（k 右移一位）。
3. 若 `sum >= 10`，則 `k++`（把進位 1 疊加回 k 的末尾），並 `sum -= 10`。
4. 把 `sum` 加入結果 List。
5. 陣列走完後，若 `k > 0` 仍有剩餘位，繼續把 `k % 10` 加入結果。
6. 最後反轉結果 List（因為是從低位開始存入的）。

**核心程式碼（C#）：**

```csharp
for (int i = n - 1; i >= 0; i--)
{
    int sum = num[i] + k % 10;
    k /= 10;
    if (sum >= 10) { k++; sum -= 10; }
    res.Add(sum);
}
for (; k > 0; k /= 10) res.Add(k % 10);
res.Reverse();
```

---

### 方法二：陣列轉整數相加（Array-to-Int Conversion）

**出發點**：直覺上最簡單——把陣列變回整數，直接加。

```
[1, 2, 0, 0]  →  1×10³ + 2×10² + 0×10¹ + 0×10⁰  =  1200
1200 + 34 = 1234
```

**步驟：**

1. 遍歷陣列，每個元素乘以對應的 10 的冪次方後累加，得到整數。
2. 整數與 `k` 直接相加。
3. 把結果存入 List 回傳。

> [!WARNING]
> **此方法存在已知限制：**
> - 當 `num` 長度超過 9~10 位時，會發生 `int` 溢位（最大值約 2.1×10⁹）。
> - 回傳時把整個整數作為單一元素存入 List，**不符合題目要求的「每位分開回傳」格式**。
> - 此方法僅作為概念展示，不建議作為正式解答提交。

---

### 方法三：進位擴散法（Carry-Propagation）

**出發點**：把整個 `k` 直接加到陣列最低位，讓進位自然往高位傳播，`k` 本身同時扮演「加數 + 進位暫存器」的雙重角色。

```
[1, 2, 3]  +  912

初始 k = 912
i=2：k += 3  → k=915  → 存入 915%10=5，k=915/10=91
i=1：k += 2  → k=93   → 存入  93%10=3，k=93/10=9
i=0：k += 1  → k=10   → 存入  10%10=0，k=10/10=1
k=1：                    存入   1%10=1，k=1/10=0
結果（反轉前）= [5, 3, 0, 1]  →  反轉後 = [1, 0, 3, 5]
```

**步驟：**

1. 從陣列最右邊（`i = n-1`）開始，條件為「陣列未走完 **OR** k > 0」。
2. 若陣列還有元素，則 `k += num[i--]`（把當前位加入 k，i 左移）。
3. 取 `k % 10` 存入結果，`k /= 10` 讓進位自動帶入下一輪。
4. 最後反轉結果。

**核心程式碼（C#）：**

```csharp
for (int i = n - 1; i >= 0 || k > 0; k /= 10)
{
    if (i >= 0) k += num[i--];
    res.Add(k % 10);
}
res.Reverse();
```

---

## 演示流程

### 範例一：`[1, 2, 0, 0] + 34 = [1, 2, 3, 4]`

使用**方法一**逐步展示：

```
i=3: sum = 0 + 4 = 4,  k = 3 → 存入 4
i=2: sum = 0 + 3 = 3,  k = 0 → 存入 3
i=1: sum = 2 + 0 = 2,  k = 0 → 存入 2
i=0: sum = 1 + 0 = 1,  k = 0 → 存入 1
k = 0，不需要繼續

結果（反轉前）= [4, 3, 2, 1]
結果（反轉後）= [1, 2, 3, 4] ✓
```

---

### 範例二：`[2, 7, 4] + 181 = [4, 5, 5]`

使用**方法三**逐步展示：

```
初始 k = 181
i=2: k += 4  → k=185  → 存入 185%10=5,  k=185/10=18
i=1: k += 7  → k=25   → 存入  25%10=5,  k=25/10=2
i=0: k += 2  → k=4    → 存入   4%10=4,  k=4/10=0
k = 0，迴圈結束

結果（反轉前）= [5, 5, 4]
結果（反轉後）= [4, 5, 5] ✓
```

---

### 範例三：`[2, 1, 5] + 806 = [1, 0, 2, 1]`（含進位）

使用**方法一**逐步展示進位情況：

```
i=2: sum = 5 + 6 = 11 ≥ 10 → sum=1, k=(80+1)=81 → 存入 1
i=1: sum = 1 + 1 = 2,       k = 8               → 存入 2
i=0: sum = 2 + 8 = 10 ≥ 10 → sum=0, k=(0+1)=1  → 存入 0
k=1 > 0: 存入 1%10=1, k=0

結果（反轉前）= [1, 2, 0, 1]
結果（反轉後）= [1, 0, 2, 1] ✓
```

---

## 執行方式

```bash
cd leetcode_989
dotnet run
```

或使用 VS Code 內建建構任務：**Terminal → Run Build Task**。

---

## 參考連結

- [LeetCode 989 (英文)](https://leetcode.com/problems/add-to-array-form-of-integer/description/)
- [LeetCode 989 (中文)](https://leetcode.cn/problems/add-to-array-form-of-integer/description/)
