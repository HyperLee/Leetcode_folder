# leetcode_1304

題目：1304. Find N Unique Integers Sum up to Zero

本專案包含一個簡單的 C# 控制台程式，用以示範 LeetCode 題目 1304 的解法：給定整數 n，回傳包含 n 個互不相同整數且總和為 0 的陣列。

## 快速開始

建置：

```bash
dotnet build ./leetcode_1304/leetcode_1304.csproj -c Debug
```

執行：

```bash
dotnet run --project ./leetcode_1304/leetcode_1304.csproj
```

程式會在 `Main` 中示範 n = 5 的輸出。

## 解法總覽（對稱構造）

核心想法

- 觀察：x + (-x) = 0，故可成對加入互為相反數的整數保證局部和為 0。若 n 為奇數，額外加入 0。
- 構造方法：令 m = floor(n/2)。生成 1..m 和 -1..-m 作為成對元素；若 n 為奇數，再加入 0。

而在 C# 中，用 `new int[n]` 會把陣列以 0 初始化，因此若 n 為奇數而只填入前 2*m 個元素，最後一個元素會是預設 0。

### 演算法步驟（詳細）

1. 建立長度為 n 的整數陣列 res（自動以 0 初始化）。
2. 計算 m = n / 2（整數相除即為向下取整）。
3. 使用迴圈 i 從 0 到 m-1：
   - 將 `res[i] = i + 1`（放入正數），
   - 將 `res[i + m] = -(i + 1)`（放入對應負數）。
   - 這樣每一次迭代會加入一對互為相反數的元素。
4. 若 n 為奇數：
   - 可以顯式指定 `res[n-1] = 0`（但在 C# 中該位置已被初始化為 0，可不做顯式賦值）。
5. 回傳 res。

舉例：n = 5
- m = 2
- i = 0：res[0] = 1；res[2] = -1
- i = 1：res[1] = 2；res[3] = -2
- 最後 res[4] = 0（預設）
- 結果（可能的輸出順序）：[1, 2, -1, -2, 0]


### 正確性與不重複性說明

- 所有正值 k（1..m）與對應負值 -k 都在陣列中，彼此唯一。若 n 為奇數，0 也只出現一次。
- 總和：每對 k 與 -k 相加為 0，若 n 為奇數，額外的 0 不影響總和。因此陣列總和為 0。

### 複雜度分析

- 時間複雜度：O(n)，只需單次迴圈填入所有元素。
- 空間複雜度：O(n)，輸出本身即佔 O(n) 空間。

## 實作重點（C# 注意事項）

- C# 對陣列元素做預設初始化：`new int[n]` 會填入 0，因此不需要在奇數情況下額外賦 0，但加入註解以表達意圖會提升可讀性。
- 若把實作搬到不會自動初始化的語言（例如 C）或改用可為 null 的型別（`int?[]`），就必須明確初始化或賦值。

## 測試建議

- 測試 n=0（應回傳空陣列）
- 測試 n=1（應回傳 [0]）
- 測試 n=2（應回傳 [1, -1] 或等價解）
- 測試幾個較大的值確認性能與記憶體使用

## 檔案說明

- `leetcode_1304/Program.cs`：主要實作與範例。

---

如果你要我把 README 擴充為英文版、加入更多示範或測試腳本，我可以接著建立簡單的測試 harness 或 GitHub Actions 工作流程檔案。
