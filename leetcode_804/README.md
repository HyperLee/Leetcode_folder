# LeetCode 804 — Unique Morse Code Words

> C# solution for [LeetCode 804: Unique Morse Code Words](https://leetcode.com/problems/unique-morse-code-words/)
> / [力扣 804：唯一摩爾斯密碼詞](https://leetcode.cn/problems/unique-morse-code-words/)

## 題目說明

國際摩爾斯密碼定義了一套標準編碼，26 個英文字母各自對應一組點（`.`）與線（`-`）的組合，完整對照表如下：

| a | b | c | d | e | f | g | h | i | j | k | l | m |
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| `.-` | `-...` | `-.-.` | `-..` | `.` | `..-.` | `--.` | `....` | `..` | `.---` | `-.-` | `.-..` | `--` |

| n | o | p | q | r | s | t | u | v | w | x | y | z |
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| `-.` | `---` | `.--.` | `--.-` | `.-.` | `...` | `-` | `..-` | `...-` | `.--` | `-..-` | `-.--` | `--..` |

給定一個字串陣列 `words`，每個單詞均由小寫英文字母組成，將其每個字母依序轉換為對應的摩爾斯密碼並拼接，所得結果即稱為該單詞的**轉換形式（Transformation）**。

**請回傳所有單詞中，不同轉換形式的數量。**

### 限制條件

- `1 <= words.length <= 100`
- `1 <= words[i].length <= 12`
- `words[i]` 只含小寫英文字母

---

## 解題概念與出發點

### 核心觀察

不同的單詞**可能產生相同的摩爾斯密碼字串**。例如：

- `"gin"` → `--....-.`
- `"zen"` → `--....-.`

兩者雖然是不同的英文單詞，摩爾斯密碼結果卻完全相同，因此題目只算作 **1 種**轉換形式。

由此可知，問題的本質是：**對所有轉換後的字串做去重，再計算個數**。

### 選擇 HashSet 的理由

`HashSet<T>` 具備天然的去重特性：

- 插入重複元素時**靜默忽略**，不拋出例外。
- 底層以雜湊結構實作，插入與查詢均攤複雜度為 $O(1)$。
- 最終 `.Count` 即為不重複元素的個數。

這使得整個演算法只需**一次迴圈**，邊建構摩爾斯密碼字串、邊加入集合，無需額外比較或排序。

---

## 解法詳解

```csharp
public int UniqueMorseRepresentations(string[] words)
{
    // 使用 HashSet 自動去除重複的摩爾斯密碼轉換形式
    ISet<string> seen = new HashSet<string>();

    foreach (var word in words)
    {
        // 逐字母查表，拼接出整個單詞的摩爾斯密碼字串
        StringBuilder sb = new StringBuilder();
        foreach (var c in word)
        {
            // c - 'a' 利用 ASCII 差值取得 MORSE 陣列的對應索引（'a'=0, 'b'=1, ...）
            sb.Append(MORSE[c - 'a']);
        }

        // 加入集合；若已存在相同字串，HashSet 會自動忽略，確保唯一性
        seen.Add(sb.ToString());
    }

    // 集合元素個數即為不同轉換形式的數量
    return seen.Count;
}
```

### 步驟說明

1. **建立 HashSet** — 用來收集所有不重複的摩爾斯密碼字串。
2. **外層迴圈** — 逐一處理 `words` 陣列中的每個單詞。
3. **內層迴圈** — 對單詞的每個字母，以 `c - 'a'` 計算索引，從 `MORSE` 陣列取出對應的摩爾斯密碼片段，拼接至 `StringBuilder`。
4. **加入集合** — 將完整的摩爾斯密碼字串加入 `HashSet`，重複者自動被忽略。
5. **回傳計數** — `seen.Count` 即為答案。

### 複雜度分析

| 項目 | 複雜度 |
|------|--------|
| 時間複雜度 | $O(S)$，$S$ 為所有單詞的字元總數 |
| 空間複雜度 | $O(S)$，HashSet 最多儲存所有不重複的摩爾斯密碼字串 |

---

## 流程演示

以官方範例 `["gin", "zen", "tit", "maps"]` 為例：

### 步驟 1：逐一轉換

| 單詞 | 字母拆解 | 摩爾斯密碼拼接 |
|------|----------|----------------|
| `gin`  | g=`--.` , i=`..` , n=`-.`  | `--....-.` |
| `zen`  | z=`--..` , e=`.` , n=`-.`  | `--....-.` |
| `tit`  | t=`-` , i=`..` , t=`-`     | `-..-`     |
| `maps` | m=`--` , a=`.-` , p=`.--.` , s=`...` | `--.-.--.…` |

> 實際拼接：`maps` → `--` + `.-` + `.--.` + `...` = `--.-.--.…`

### 步驟 2：加入 HashSet

```
seen = {}
加入 "--....-."  → seen = {"--....-."}
加入 "--....-."  → 已存在，忽略 → seen = {"--....-."}
加入 "-..-"      → seen = {"--....-.","-..-"}
加入 "--.-.--.…" → seen = {"--....-.","-..-","--.-.--.…"}
```

### 步驟 3：回傳結果

```
seen.Count = 2
```

**輸出：`2`**

---

## 專案建構

需求：[.NET 10 SDK](https://dotnet.microsoft.com/download)

```bash
dotnet build
dotnet run --project leetcode_804/leetcode_804.csproj
```

預期輸出：

```
測試案例 1：2
測試案例 2：1
測試案例 3：2
```

> [!NOTE]
> 測試案例 1 為 LeetCode 官方範例，預期答案為 `2`。
