# 🍎 LeetCode 1443 - 收集樹上所有蘋果的最少時間

[![C#](https://img.shields.io/badge/C%23-14-512BD4?style=flat-square&logo=csharp&logoColor=white)](https://docs.microsoft.com/dotnet/csharp/)
[![.NET](https://img.shields.io/badge/.NET-10-512BD4?style=flat-square&logo=dotnet&logoColor=white)](https://dotnet.microsoft.com/)
[![LeetCode](https://img.shields.io/badge/LeetCode-Medium-FFA116?style=flat-square&logo=leetcode&logoColor=white)](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/)

## 📋 題目描述

給定一棵由 `n` 個節點（編號 `0` 到 `n-1`）組成的**無向樹**，部分節點上有蘋果。每走過一條邊需花費 **1 秒**。從節點 `0` 出發並最終回到節點 `0`，求收集樹上**所有蘋果**所需的**最短時間**（秒）。

### 輸入

- `n`：樹的節點數量
- `edges`：樹的邊，`edges[i] = [ai, bi]` 表示 `ai` 與 `bi` 之間存在一條邊
- `hasApple`：布林陣列，`hasApple[i] = true` 表示節點 `i` 有蘋果

### 輸出

收集所有蘋果所需的最少時間（秒）

## 💡 解題思路

### 核心觀察

1. **避免重複路徑**：收集蘋果時，同一條邊最多在兩個方向上各走一次
2. **最短路徑原則**：對於每個蘋果，應該走從根節點直接到達該蘋果的路徑
3. **邊數轉換時間**：將需要經過的邊數乘以 2 即為最少時間（去程 + 回程）

### 演算法步驟

```
1. 建立鄰接表 → 從邊列表轉換為圖結構
2. DFS 建立父節點關係 → 確定樹的結構
3. 回溯計算時間 → 從每個蘋果節點向根節點回溯
```

### 關鍵技巧

使用 `visited` 陣列避免重複計算已經走過的路徑：

- 初始時只有根節點 `0` 被標記為已訪問
- 對於每個有蘋果的節點，從該節點向根節點移動
- 遇到已訪問的節點時停止，避免重複計算

## 📊 複雜度分析

| 複雜度 | 數值 | 說明 |
|--------|------|------|
| 時間複雜度 | O(n) | 每個節點最多被訪問兩次（DFS + 回溯） |
| 空間複雜度 | O(n) | 鄰接表、父節點陣列、訪問標記 |

---

## 💡 解法二：DFS 後序遍歷

### 解題概念與出發點

解法二採用**後序遍歷（Post-order Traversal）**的策略，核心思想是「由下往上」匯總結果：

1. **後序遍歷特性**：先處理所有子節點，再處理當前節點
2. **資訊傳遞**：每個節點回傳「子樹是否有蘋果」及「子樹所需時間」
3. **時間累加規則**：若子樹有蘋果，則進入該子樹的邊需要走兩次（去 + 回）

### 詳細說明

#### 資料結構設計

每個 DFS 呼叫回傳一個長度為 2 的陣列 `res`：

- `res[0]`：標記位，`1` 表示此子樹（含當前節點）有蘋果需要收集
- `res[1]`：收集此子樹所有蘋果所需的時間（不含進入此子樹的邊）

#### 演算法流程

```text
1. 建立鄰接表 → 使用 Dictionary<int, HashSet<int>> 儲存圖
2. 從根節點 0 開始 DFS 後序遍歷
3. 對於每個節點：
   a. 若自身有蘋果，設定 res[0] = 1
   b. 遞迴處理所有子節點
   c. 若子節點的子樹有蘋果，累加時間：res[1] += 子樹時間 + 2
4. 根節點的 res[1] 即為答案
```

#### 與解法一的差異

| 比較項目 | 解法一（回溯法） | 解法二（後序遍歷） |
| -------- | --------------- | ----------------- |
| 遍歷方向 | 建立父子關係後，從蘋果向根回溯 | 直接在 DFS 中由下往上匯總 |
| 時間計算 | 從蘋果節點向根累加 | 從子樹向父節點累加 |
| 額外空間 | 需要 parents 陣列 | 不需要額外陣列 |
| 程式碼風格 | 兩階段處理 | 一次 DFS 完成 |

### 範例演示

以範例 1 為例，展示後序遍歷的執行流程：

```text
樹結構：
        0
       / \
      1   2 (🍎)
     / \
    4   5
   (🍎) (🍎)
```

**DFS 執行順序（後序）：**

| 步驟 | 處理節點 | hasApple | 子節點結果 | 回傳 res |
| ---- | -------- | -------- | ---------- | -------- |
| 1 | 4 | ✅ | 無子節點 | [1, 0] |
| 2 | 5 | ✅ | 無子節點 | [1, 0] |
| 3 | 1 | ❌ | 4:[1,0], 5:[1,0] | [1, 4] |
| 4 | 3 | ❌ | 無子節點 | [0, 0] |
| 5 | 6 | ❌ | 無子節點 | [0, 0] |
| 6 | 2 | ✅ | 3:[0,0], 6:[0,0] | [1, 0] |
| 7 | 0 | ❌ | 1:[1,4], 2:[1,0] | [1, 8] |

**步驟 3 詳細說明（處理節點 1）：**

```text
節點 1 本身沒有蘋果，但子節點 4 和 5 都有蘋果
- 子節點 4 回傳 [1, 0]：有蘋果，子樹時間 0
  → 累加時間：0 + 2 = 2（進入節點 4 的邊）
- 子節點 5 回傳 [1, 0]：有蘋果，子樹時間 0
  → 累加時間：0 + 2 = 2（進入節點 5 的邊）
- 節點 1 回傳 [1, 4]：標記有蘋果（因子樹有），時間 4
```

**步驟 7 詳細說明（處理節點 0）：**

```text
節點 0 本身沒有蘋果
- 子節點 1 回傳 [1, 4]：有蘋果
  → 累加時間：4 + 2 = 6（進入節點 1 子樹的邊）
- 子節點 2 回傳 [1, 0]：有蘋果
  → 累加時間：0 + 2 = 2（進入節點 2 的邊）
- 節點 0 回傳 [1, 8]：總時間 8 秒
```

**最終結果：** `8` 秒

---

## 🎯 解法一範例演示

### 範例 1

```text
輸入：
n = 7
edges = [[0,1], [0,2], [1,4], [1,5], [2,3], [2,6]]
hasApple = [false, false, true, false, true, true, false]

樹結構：
        0 (無蘋果)
       / \
      1   2 (有蘋果)
     / \   \
    4   5   3
  (有) (有) (無)
```

**執行流程：**

1. **處理節點 2 的蘋果**（`hasApple[2] = true`）
   - 回溯路徑：`2 → 0`
   - 經過邊：`2-0`
   - 時間增加：2 秒
   - 標記節點 2 為已訪問

2. **處理節點 4 的蘋果**（`hasApple[4] = true`）
   - 回溯路徑：`4 → 1 → 0`
   - 經過邊：`4-1`, `1-0`
   - 時間增加：4 秒
   - 標記節點 4, 1 為已訪問

3. **處理節點 5 的蘋果**（`hasApple[5] = true`）
   - 回溯路徑：`5 → 1`（節點 1 已訪問，停止）
   - 經過邊：`5-1`
   - 時間增加：2 秒
   - 標記節點 5 為已訪問

**輸出：** `2 + 4 + 2 = 8` 秒

### 視覺化路徑

```text
收集路徑（需要經過的邊，用 * 標記）：

        0
       /*\*
      1   2
     /*\
    4   5

經過的邊：0-1, 1-4, 1-5, 0-2
每條邊走 2 次（去 + 回）= 8 秒
```

## 🚀 快速開始

### 前置需求

- [.NET 10 SDK](https://dotnet.microsoft.com/download) 或更高版本

### 執行程式

```bash
# 複製專案
git clone https://github.com/HyperLee/Leetcode_folder.git

# 進入專案目錄
cd Leetcode_folder/leetcode_1443

# 建構並執行
dotnet run --project leetcode_1443/leetcode_1443.csproj
```

### 預期輸出

```text
測試範例 1: 8
測試範例 2: 6
測試範例 3: 0
```

## 📁 專案結構

```text
leetcode_1443/
├── leetcode_1443.sln          # 方案檔
├── README.md                  # 本文件
└── leetcode_1443/
    ├── leetcode_1443.csproj   # 專案檔
    └── Program.cs             # 主程式與解題實作
```

## 🔗 相關連結

- [LeetCode 題目連結（英文）](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/)
- [LeetCode 題目連結（中文）](https://leetcode.cn/problems/minimum-time-to-collect-all-apples-in-a-tree/)

## 📚 相關知識

- **深度優先搜尋 (DFS)**：用於遍歷樹結構並建立父子關係
- **樹的遍歷**：無向圖轉換為有根樹的技巧
- **回溯法**：從葉節點向根節點回溯計算路徑
