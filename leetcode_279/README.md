# 279. Perfect Squares 完全平方數

[![LeetCode](https://img.shields.io/badge/LeetCode-279-orange)](https://leetcode.com/problems/perfect-squares/)
[![Difficulty](https://img.shields.io/badge/Difficulty-Medium-yellow)](https://leetcode.com/problems/perfect-squares/)
[![.NET](https://img.shields.io/badge/.NET-10.0-purple)](https://dotnet.microsoft.com/)

使用動態規劃解決 LeetCode 第 279 題「完全平方數」的 C# 實作。

## 題目描述

給定一個正整數 `n`，找到若干個完全平方數（例如 `1, 4, 9, 16, ...`）使得它們的和等於 `n`。回傳組成和所需的**最少完全平方數數量**。

### 範例

```text
輸入：n = 12
輸出：3
解釋：12 = 4 + 4 + 4
```

```text
輸入：n = 13
輸出：2
解釋：13 = 4 + 9
```

### 限制條件

- `1 <= n <= 10⁴`

## 解題概念與出發點

### 為什麼想到動態規劃？

這道題目要求找到「最少」的完全平方數數量，這是一個**最優化問題**。觀察題目特性：

1. **重疊子問題**：計算 `f[12]` 時需要 `f[11]`、`f[8]`、`f[3]` 等，而這些子問題會被重複計算
2. **最優子結構**：`f[n]` 的最優解可以由更小規模的子問題最優解推導出來

這正是動態規劃的典型應用場景。

### 解題出發點

假設我們要組成數字 `n`，最後一步必定是選擇某個完全平方數 `j²`（其中 `j² ≤ n`）。選擇 `j²` 後，剩餘問題變成：如何用最少的完全平方數組成 `n - j²`？

這個子問題與原問題結構相同，只是規模變小了！

## 解法詳解

### 狀態定義

定義 `f[i]` 為組成整數 `i` 所需的最少完全平方數數量。

### 狀態轉移方程

$$f[i] = 1 + \min_{1 \leq j \leq \lfloor\sqrt{i}\rfloor} f[i - j^2]$$

對於每個 `i`，枚舉所有可能的完全平方數 `j²`（其中 `j² ≤ i`），選擇使得總數量最小的那個。

### 邊界條件

- `f[0] = 0`：組成 0 不需要任何完全平方數

> [!NOTE]
> 雖然實際上無法用完全平方數表示 0，但設定 `f[0] = 0` 是為了保證狀態轉移的正確性。當 `j² = i` 時，`f[i - j²] = f[0] = 0`，此時 `f[i] = 1`，恰好表示只需要一個完全平方數 `j²`。

### 演算法流程

```text
1. 建立長度為 n+1 的陣列 f，初始化 f[0] = 0
2. 對於 i 從 1 到 n：
   a. 設定 min = ∞
   b. 對於 j 從 1 開始，當 j² ≤ i 時：
      - min = min(min, f[i - j²])
   c. f[i] = min + 1
3. 回傳 f[n]
```

### 複雜度分析

| 複雜度類型 | 數值   | 說明                              |
| ---------- | ------ | --------------------------------- |
| 時間複雜度 | O(n√n) | 外層迴圈 n 次，內層迴圈最多 √n 次 |
| 空間複雜度 | O(n)   | 需要長度為 n+1 的陣列儲存狀態     |

## 範例演示

以 `n = 12` 為例，逐步演示 DP 填表過程：

```text
初始狀態：f[0] = 0

計算 f[1]：
  j=1: j²=1, f[1-1] = f[0] = 0
  f[1] = min(0) + 1 = 1  ← 12 = 1

計算 f[2]：
  j=1: j²=1, f[2-1] = f[1] = 1
  f[2] = min(1) + 1 = 2  ← 2 = 1+1

計算 f[3]：
  j=1: j²=1, f[3-1] = f[2] = 2
  f[3] = min(2) + 1 = 3  ← 3 = 1+1+1

計算 f[4]：
  j=1: j²=1, f[4-1] = f[3] = 3
  j=2: j²=4, f[4-4] = f[0] = 0  ✓ 最小
  f[4] = min(3,0) + 1 = 1  ← 4 = 4

計算 f[5]：
  j=1: j²=1, f[5-1] = f[4] = 1  ✓ 最小
  j=2: j²=4, f[5-4] = f[1] = 1
  f[5] = min(1,1) + 1 = 2  ← 5 = 4+1

計算 f[6]：
  j=1: j²=1, f[6-1] = f[5] = 2
  j=2: j²=4, f[6-4] = f[2] = 2
  f[6] = min(2,2) + 1 = 3  ← 6 = 4+1+1

計算 f[7]：
  j=1: j²=1, f[7-1] = f[6] = 3
  j=2: j²=4, f[7-4] = f[3] = 3
  f[7] = min(3,3) + 1 = 4  ← 7 = 4+1+1+1

計算 f[8]：
  j=1: j²=1, f[8-1] = f[7] = 4
  j=2: j²=4, f[8-4] = f[4] = 1  ✓ 最小
  f[8] = min(4,1) + 1 = 2  ← 8 = 4+4

計算 f[9]：
  j=1: j²=1, f[9-1] = f[8] = 2
  j=2: j²=4, f[9-4] = f[5] = 2
  j=3: j²=9, f[9-9] = f[0] = 0  ✓ 最小
  f[9] = min(2,2,0) + 1 = 1  ← 9 = 9

計算 f[10]：
  j=1: j²=1, f[10-1] = f[9] = 1  ✓ 最小
  j=2: j²=4, f[10-4] = f[6] = 3
  j=3: j²=9, f[10-9] = f[1] = 1
  f[10] = min(1,3,1) + 1 = 2  ← 10 = 9+1

計算 f[11]：
  j=1: j²=1, f[11-1] = f[10] = 2
  j=2: j²=4, f[11-4] = f[7] = 4
  j=3: j²=9, f[11-9] = f[2] = 2
  f[11] = min(2,4,2) + 1 = 3  ← 11 = 9+1+1

計算 f[12]：
  j=1: j²=1, f[12-1] = f[11] = 3
  j=2: j²=4, f[12-4] = f[8] = 2  ✓ 最小
  j=3: j²=9, f[12-9] = f[3] = 3
  f[12] = min(3,2,3) + 1 = 3  ← 12 = 4+4+4
```

**最終結果**：`f[12] = 3`，表示 12 = 4 + 4 + 4

### DP 陣列視覺化

```text
索引:  0   1   2   3   4   5   6   7   8   9  10  11  12
f[i]:  0   1   2   3   1   2   3   4   2   1   2   3   3
            │   │   │   │   │   │   │   │   │   │   │   │
            │   │   │   │   │   │   │   │   │   │   │   └─ 4+4+4
            │   │   │   │   │   │   │   │   │   │   └─ 9+1+1
            │   │   │   │   │   │   │   │   │   └─ 9+1
            │   │   │   │   │   │   │   │   └─ 9
            │   │   │   │   │   │   │   └─ 4+4
            │   │   │   │   │   │   └─ 4+1+1+1
            │   │   │   │   │   └─ 4+1+1
            │   │   │   │   └─ 4+1
            │   │   │   └─ 4
            │   │   └─ 1+1+1
            │   └─ 1+1
            └─ 1
```

## 解法二：數學方法（四平方和定理）

### 數學背景

這道題目可以運用數論中的經典定理來解決：

#### 四平方和定理（Lagrange's four-square theorem）

任意一個正整數都可以被表示為**至多四個**正整數的平方和。這給出了本題答案的上界為 4。

#### 三平方和定理（Legendre's three-square theorem）

一個正整數 n 可以表示為三個平方數之和，**當且僅當** n 不是 $4^k \times (8m + 7)$ 的形式。

換言之，當 $n = 4^k \times (8m + 7)$ 時，n **只能**被表示為四個正整數的平方和。

### 解題思路

根據上述定理，我們可以按以下順序判斷答案：

```text
1. 答案為 4：檢查 n 是否符合 4^k × (8m + 7) 的形式
   - 若是，直接回傳 4

2. 答案為 1：檢查 n 本身是否為完全平方數
   - 若是，直接回傳 1

3. 答案為 2：檢查 n 是否可以表示為兩個平方數之和
   - 枚舉所有 a（1 ≤ a ≤ √n），檢查 n - a² 是否為完全平方數
   - 若是，回傳 2

4. 答案為 3：排除法
   - 若以上情況都不滿足，答案必為 3
```

### 輔助函式

#### IsPerfectSquare(x)：判斷是否為完全平方數

```csharp
public bool IsPerfectSquare(int x)
{
    int y = (int)Math.Sqrt(x);
    return y * y == x;
}
```

#### CheckAnswer4(x)：判斷是否符合 4^k × (8m + 7) 形式

```csharp
public bool CheckAnswer4(int x)
{
    // 持續除以 4，消除所有 4^k 因子
    while (x % 4 == 0)
    {
        x /= 4;
    }
    // 檢查剩餘的數是否符合 8m + 7 的形式
    return x % 8 == 7;
}
```

### 數學方法複雜度分析

| 複雜度類型 | 數值  | 說明                           |
| ---------- | ----- | ------------------------------ |
| 時間複雜度 | O(√n) | 主要耗費在枚舉檢查答案是否為 2 |
| 空間複雜度 | O(1)  | 僅使用常數空間                 |

### 數學方法範例演示

以幾個典型數字為例：

```text
n = 7：
  - CheckAnswer4(7)：7 % 4 ≠ 0，直接檢查 7 % 8 = 7 ✓
  - 答案為 4

n = 12：
  - CheckAnswer4(12)：12 % 4 = 0 → 12/4 = 3 → 3 % 8 = 3 ≠ 7
  - IsPerfectSquare(12)：√12 ≈ 3.46 → 3² = 9 ≠ 12
  - 枚舉檢查 n = a² + b²：
    - a=1: 12-1=11, √11 ≈ 3.32, 3² ≠ 11
    - a=2: 12-4=8, √8 ≈ 2.83, 2² ≠ 8
    - a=3: 12-9=3, √3 ≈ 1.73, 1² ≠ 3
  - 答案為 3（12 = 4 + 4 + 4）

n = 13：
  - CheckAnswer4(13)：13 % 4 ≠ 0，13 % 8 = 5 ≠ 7
  - IsPerfectSquare(13)：√13 ≈ 3.6 → 3² ≠ 13
  - 枚舉檢查 n = a² + b²：
    - a=2: 13-4=9, √9 = 3, 3² = 9 ✓
  - 答案為 2（13 = 4 + 9）

n = 16：
  - CheckAnswer4(16)：16/4=4, 4/4=1, 1 % 8 = 1 ≠ 7
  - IsPerfectSquare(16)：√16 = 4, 4² = 16 ✓
  - 答案為 1
```

## 兩種解法比較

| 比較項目       | 方法一：動態規劃               | 方法二：數學方法（四平方和定理） |
| -------------- | ------------------------------ | -------------------------------- |
| **時間複雜度** | O(n × √n)                      | O(√n)                            |
| **空間複雜度** | O(n)                           | O(1)                             |
| **優點**       | 直觀易懂、可擴展               | 效率極高、空間最優               |
| **缺點**       | 當 n 很大時耗費記憶體與時間    | 需要數學背景知識                 |
| **適用場景**   | 需要獲得中間結果或理解 DP 思想 | 追求最優效能                     |
| **程式碼複雜度** | 簡單                         | 中等（需理解數學定理）           |

### 效能比較

假設 n = 10,000：

| 方法 | 時間複雜度計算 | 預估操作次數 |
| ---- | -------------- | ------------ |
| DP   | 10,000 × 100   | ~1,000,000   |
| 數學 | ~100           | ~100         |

> [!TIP]
> 在實際 LeetCode 測試中，數學方法通常能達到**擊敗 100%** 的效能表現，而 DP 方法約在 50-80% 之間。

### 如何選擇？

- 如果追求**最優效能**，選擇**數學方法**
- 如果要**學習 DP 思想**或需要**獲得分解方式**，選擇**動態規劃**
- 面試時建議**兩種都掌握**，展示多角度思考能力

## 快速開始

### 環境需求

- [.NET 10.0 SDK](https://dotnet.microsoft.com/download) 或更高版本

### 執行程式

```bash
cd leetcode_279
dotnet run
```

### 預期輸出

```text
n = 12, 最少完全平方數數量 = 3
n = 13, 最少完全平方數數量 = 2
n = 1, 最少完全平方數數量 = 1
n = 4, 最少完全平方數數量 = 1
n = 7, 最少完全平方數數量 = 4

=== 方法二：數學解法（四平方和定理）===
n = 12, 最少完全平方數數量 = 3
n = 13, 最少完全平方數數量 = 2
n = 1, 最少完全平方數數量 = 1
n = 4, 最少完全平方數數量 = 1
n = 7, 最少完全平方數數量 = 4
```

## 參考資料

- [LeetCode 279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)
- [力扣 279. 完全平方數](https://leetcode.cn/problems/perfect-squares/)
- [四平方和定理 - 維基百科](https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86)
- [三平方和定理 - 維基百科](https://en.wikipedia.org/wiki/Legendre%27s_three-square_theorem)
