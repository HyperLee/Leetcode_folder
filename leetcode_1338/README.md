# LeetCode 1338: 數組大小減半

> **Reduce Array Size to The Half**

[![LeetCode](https://img.shields.io/badge/LeetCode-1338-orange?style=flat-square)](https://leetcode.com/problems/reduce-array-size-to-the-half/)
[![Difficulty](https://img.shields.io/badge/Difficulty-Medium-yellow?style=flat-square)]()
[![.NET](https://img.shields.io/badge/.NET-10.0-512BD4?style=flat-square)](https://dotnet.microsoft.com/)

## 題目描述

給定一個整數陣列 `arr`。你可以選擇一個整數集合，並從陣列中移除該集合中所有整數的所有出現。

**目標**：返回該集合的**最小大小**，使得陣列中**至少一半**的整數被移除。

### 範例

**範例 1：**
```
輸入: arr = [3,3,3,3,5,5,5,2,2,7]
輸出: 2
解釋: 選擇 {3, 5} 可以移除 4 + 3 = 7 個元素，7 ≥ 10/2 = 5
      所以最小集合大小為 2
```

**範例 2：**
```
輸入: arr = [7,7,7,7,7,7]
輸出: 1
解釋: 只需選擇 {7}，移除 6 個元素，6 ≥ 6/2 = 3
```

**範例 3：**
```
輸入: arr = [1,2,3,4,5,6,7,8,9,10]
輸出: 5
解釋: 每個元素出現 1 次，需要選擇任意 5 個不同的元素
```

### 限制條件

- `1 ≤ arr.length ≤ 10⁵`
- `arr.length` 為偶數
- `1 ≤ arr[i] ≤ 10⁵`

---

## 解題概念與出發點

### 問題分析

這道題的核心問題是：**如何用最少的整數種類，移除最多的元素？**

直覺告訴我們：
- 如果一個數字出現 100 次，選擇它可以一次移除 100 個元素
- 如果一個數字只出現 1 次，選擇它只能移除 1 個元素

因此，**優先選擇出現次數最多的元素**是最佳策略。

### 解題思路：貪婪演算法 (Greedy Algorithm)

> [!TIP]
> 貪婪演算法的精髓：每一步都選擇當前最優的選項，最終達到全局最優解。

**為什麼貪婪演算法在這題是正確的？**

假設我們需要移除至少 $k$ 個元素：
- 選擇出現次數最多的元素，能以「1 個選擇」換取「最多的移除數」
- 這是一個典型的「用最少資源完成目標」的最佳化問題
- 由於每個元素的選擇是獨立的，局部最優 → 全局最優

---

## 詳細解法

### 演算法步驟

```
┌─────────────────────────────────────────────────────────────┐
│  步驟 1: 統計頻率                                            │
│  ──────────────────────────────────────────────────────────  │
│  使用 Dictionary 統計每個元素出現的次數                        │
│                                                              │
│  步驟 2: 排序                                                │
│  ──────────────────────────────────────────────────────────  │
│  將元素按出現次數由大到小排序                                   │
│                                                              │
│  步驟 3: 貪婪選擇                                            │
│  ──────────────────────────────────────────────────────────  │
│  從最高頻率開始，累加移除數量，直到達到目標                      │
└─────────────────────────────────────────────────────────────┘
```

### 程式碼實現

```csharp
public int MinSetSize(int[] arr)
{
    // 步驟 1: 建立頻率計數表
    Dictionary<int, int> countMap = new Dictionary<int, int>();
    
    for (int i = 0; i < arr.Length; i++)
    {
        if (countMap.ContainsKey(arr[i]))
            countMap[arr[i]]++;
        else
            countMap[arr[i]] = 1;
    }

    // 步驟 2: 按出現次數由大到小排序
    var countMapOrdered = countMap.OrderByDescending(kv => kv.Value);

    // 步驟 3: 貪婪選擇
    int removedCount = 0;
    int setSize = 0;
    int targetCount = arr.Length / 2;

    foreach (var kv in countMapOrdered)
    {
        removedCount += kv.Value;
        setSize++;
        
        if (removedCount >= targetCount)
            break;
    }

    return setSize;
}
```

### 複雜度分析

| 複雜度 | 數值 | 說明 |
|--------|------|------|
| 時間複雜度 | O(n log n) | 排序為主要開銷 |
| 空間複雜度 | O(n) | Dictionary 儲存頻率 |

---

## 方法比較：MinSetSize vs MinSetSize2

本專案提供了兩種實現方式，核心演算法相同，但在資料結構的使用上有所不同：

### 方法一：MinSetSize（LINQ OrderByDescending）

```csharp
var countMapOrdered = countMap.OrderByDescending(kv => kv.Value);
foreach (var kv in countMapOrdered)
{
    removedCount += kv.Value;
    setSize++;
    if (removedCount >= targetCount) break;
}
```

**特點：**

- 使用 LINQ `OrderByDescending` 進行排序
- 保留完整的鍵值對（Key-Value Pair）
- 程式碼簡潔易讀

### 方法二：MinSetSize2（List 原地排序優化）

```csharp
List<int> frequencies = new List<int>(countMap.Values);
frequencies.Sort((a, b) => b.CompareTo(a)); // 降序排序
foreach (var freq in frequencies)
{
    removedCount += freq;
    setSize++;
    if (removedCount >= targetCount) break;
}
```

**特點：**

- 只提取頻率值（Values），不保留鍵（Keys）
- 使用 `List.Sort()` 原地排序，避免額外記憶體配置
- 迭代時直接存取整數值，減少物件存取開銷

### 效能比較

| 比較項目 | MinSetSize (LINQ) | MinSetSize2 (List) |
| ---------- | ------------------- | --------------------- |
| 時間複雜度 | O(n log n) | O(n log n) |
| 空間複雜度 | O(n) | O(n)，但實際更少 |
| 排序方式 | 延遲執行（Lazy） | 原地排序（In-place） |
| 迭代物件 | KeyValuePair<int, int> | int |
| 記憶體配置 | 較多（LINQ 迭代器） | 較少（單一 List） |
| 程式碼可讀性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 實際效能 | 較慢 | 較快 |

### 選擇建議

```text
┌─────────────────────────────────────────────────────────────┐
│  如果你需要...                         │  建議使用...        │
├─────────────────────────────────────────────────────────────┤
│  程式碼簡潔、易於維護                    │  MinSetSize        │
│  LeetCode 競賽、追求效能                 │  MinSetSize2       │
│  需要知道選擇了哪些元素                   │  MinSetSize        │
│  大規模資料處理                          │  MinSetSize2       │
└─────────────────────────────────────────────────────────────┘
```

> [!NOTE]
> 在 LeetCode 的測試環境中，`MinSetSize2` 通常能獲得更好的執行時間，因為：
>
> 1. 避免了 LINQ 的延遲執行和迭代器開銷
> 2. List.Sort() 使用 IntroSort 演算法，對整數排序效率高
> 3. 直接迭代整數值比迭代 KeyValuePair 更快

---

## 範例演示流程

以 `arr = [3,3,3,3,5,5,5,2,2,7]` 為例：

### 步驟 1: 統計頻率

```
遍歷陣列，建立頻率表：

元素  │ 出現次數
──────┼─────────
  3   │    4
  5   │    3
  2   │    2
  7   │    1
```

### 步驟 2: 按頻率排序

```
排序後（由大到小）：

順位  │ 元素  │ 出現次數
──────┼───────┼─────────
  1   │   3   │    4
  2   │   5   │    3
  3   │   2   │    2
  4   │   7   │    1
```

### 步驟 3: 貪婪選擇

```
目標: 移除至少 10/2 = 5 個元素

┌──────────────────────────────────────────────────────────────┐
│ 第 1 輪: 選擇元素 3                                           │
│ ──────────────────────────────────────────────────────────── │
│ • 移除數量: 0 + 4 = 4                                        │
│ • 集合大小: 1                                                 │
│ • 4 < 5 → 繼續                                               │
├──────────────────────────────────────────────────────────────┤
│ 第 2 輪: 選擇元素 5                                           │
│ ──────────────────────────────────────────────────────────── │
│ • 移除數量: 4 + 3 = 7                                        │
│ • 集合大小: 2                                                 │
│ • 7 ≥ 5 → 達成目標！停止                                      │
└──────────────────────────────────────────────────────────────┘

✅ 答案: 2
```

### 視覺化流程圖

```
原始陣列: [3, 3, 3, 3, 5, 5, 5, 2, 2, 7]
                                        
           ┌───────────────────────────┐
           │   統計頻率 (Dictionary)    │
           └───────────┬───────────────┘
                       ▼
        ┌──────────────────────────────┐
        │  3→4, 5→3, 2→2, 7→1          │
        └───────────┬──────────────────┘
                    ▼
           ┌───────────────────────────┐
           │   按頻率降序排序           │
           └───────────┬───────────────┘
                       ▼
        ┌──────────────────────────────┐
        │  [4, 3, 2, 1]                │
        └───────────┬──────────────────┘
                    ▼
           ┌───────────────────────────┐
           │   貪婪累加                 │
           │   4 < 5 → 繼續            │
           │   4+3=7 ≥ 5 → 停止        │
           └───────────┬───────────────┘
                       ▼
              ┌─────────────┐
              │   答案: 2   │
              └─────────────┘
```

---

## 快速開始

### 執行專案

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run --project leetcode_1338
```

### 預期輸出

```text
測試 1: arr = [3, 3, 3, 3, 5, 5, 5, 2, 2, 7]
結果: 2, 預期: 2

測試 2: arr = [7, 7, 7, 7, 7, 7]
結果: 1, 預期: 1

測試 3: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
結果: 5, 預期: 5

===== MinSetSize2 方法測試 (List 排序優化版本) =====

測試 1: arr = [3, 3, 3, 3, 5, 5, 5, 2, 2, 7]
結果: 2, 預期: 2

測試 2: arr = [7, 7, 7, 7, 7, 7]
結果: 1, 預期: 1

測試 3: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
結果: 5, 預期: 5
```

---

## 相關連結

- 🔗 [LeetCode 題目 (英文)](https://leetcode.com/problems/reduce-array-size-to-the-half/description/)
- 🔗 [LeetCode 題目 (中文)](https://leetcode.cn/problems/reduce-array-size-to-the-half/description/)
