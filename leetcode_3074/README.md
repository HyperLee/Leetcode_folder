# LeetCode 3074 - 重新分裝蘋果 (Apple Redistribution into Boxes)

> **難度**: 簡單 (Easy)  
> **標籤**: 陣列 (Array)、排序 (Sorting)、貪心演算法 (Greedy)

## 題目描述

給定大小為 `n` 的陣列 `apple` 與大小為 `m` 的陣列 `capacity`。

- 有 `n` 包蘋果，第 `i` 包含有 `apple[i]` 顆蘋果
- 有 `m` 個箱子，第 `i` 個箱子最多可裝 `capacity[i]` 顆蘋果

請回傳為將這 `n` 包蘋果重新分裝到箱子中，**最少需要選擇的箱子數量**。

> **注意**: 同一包蘋果中的蘋果可以分裝到不同的箱子中。

### 原題連結

- [LeetCode 英文版](https://leetcode.com/problems/apple-redistribution-into-boxes/description/)
- [LeetCode 中文版](https://leetcode.cn/problems/apple-redistribution-into-boxes/description/)

### 範例

**範例 1:**
```
輸入: apple = [1,3,2], capacity = [4,3,1,5,2]
輸出: 2
說明: 
我們可以使用容量為 4 和 5 的箱子。
總共有 1+3+2 = 6 顆蘋果，這兩個箱子可以裝下全部蘋果。
```

**範例 2:**
```
輸入: apple = [5,5,5], capacity = [2,4,2,7]
輸出: 3
說明: 
我們需要使用全部 3 個容量為 2, 4 和 7 的箱子。
總共有 15 顆蘋果，需要用容量最大的 7, 4, 2 這三個箱子，
總容量為 7+4+2 = 13，不夠裝，還需要再加上容量為 2 的箱子。
實際上是 7+4+4 = 15（使用容量 7, 4, 4）
```

**範例 3:**
```
輸入: apple = [9], capacity = [2,2,2,2,2]
輸出: 5
說明:
總共有 9 顆蘋果，每個箱子容量都是 2。
需要使用全部 5 個箱子，總容量為 10，才能裝下 9 顆蘋果。
```

### 限制條件

- `1 <= n == apple.length <= 50`
- `1 <= m == capacity.length <= 50`
- `1 <= apple[i], capacity[i] <= 50`
- 輸入保證可以將所有蘋果重新分裝到箱子中

## 解題概念與出發點

### 核心觀察

題目的關鍵在於「**同一包蘋果中的蘋果可以分裝到不同的箱子中**」。這意味著我們不需要考慮每包蘋果的個別數量，只需要關注：

1. **蘋果總數**: 所有包裹中蘋果的總和
2. **箱子容量**: 每個箱子能裝多少蘋果

### 貪心策略

為了使用**最少的箱子**，我們應該：
- **優先使用容量大的箱子**
- **從大到小依序裝填**，直到所有蘋果都被裝完

這是一個典型的**貪心演算法**問題，局部最優解（每次選最大的箱子）可以導致全局最優解（最少箱子數）。

## 解法詳細說明

### 演算法步驟

1. **計算蘋果總數**: 將所有 `apple[i]` 相加，得到需要裝箱的蘋果總數
2. **排序箱子容量**: 將 `capacity` 陣列由大到小排序
3. **貪心裝箱**: 
   - 從最大容量的箱子開始
   - 每次選一個箱子，將其容量從蘋果總數中扣除
   - 重複此過程直到蘋果總數 ≤ 0
   - 返回使用的箱子數量

### 複雜度分析

- **時間複雜度**: `O(n + m log m)`
  - 計算蘋果總數: `O(n)`
  - 排序箱子容量: `O(m log m)`
  - 裝箱過程: `O(m)`（最壞情況）
  
- **空間複雜度**: `O(1)`
  - 僅使用常數額外空間（排序為原地排序）

### C# 實現

```csharp
public int MinimumBoxes(int[] apple, int[] capacity)
{
    // 步驟 1: 計算所有蘋果的總數量
    int sum = apple.Sum();
    
    // 步驟 2: 將箱子容量由大到小排序
    Array.Sort(capacity);
    Array.Reverse(capacity);

    // 步驟 3: 貪心策略 - 依序使用最大的箱子裝蘋果
    int res = 0;
    while (sum > 0)
    {
        sum -= capacity[res];
        res++;
    }
    
    return res;
}
```

## 演示流程範例

以**範例 1**為例，詳細演示執行流程：

### 輸入
```
apple = [1, 3, 2]
capacity = [4, 3, 1, 5, 2]
```

### 執行步驟

**步驟 1: 計算蘋果總數**
```
sum = 1 + 3 + 2 = 6
```

**步驟 2: 排序箱子容量（由大到小）**
```
原始: [4, 3, 1, 5, 2]
排序: [1, 2, 3, 4, 5]  ← Array.Sort()
反轉: [5, 4, 3, 2, 1]  ← Array.Reverse()
```

**步驟 3: 貪心裝箱**

| 迴圈次數 | 剩餘蘋果 (sum) | 選擇箱子容量 | 箱子數 (res) |
|---------|---------------|-------------|-------------|
| 開始     | 6             | -           | 0           |
| 第 1 次  | 6 - 5 = 1     | capacity[0] = 5 | 1       |
| 第 2 次  | 1 - 4 = -3    | capacity[1] = 4 | 2       |

當 `sum ≤ 0` 時停止，返回 `res = 2`

### 結果
```
輸出: 2
使用的箱子: 容量 5 和容量 4 的箱子
總容量: 5 + 4 = 9 ≥ 6（蘋果總數）
```

---

### 範例 2 演示

**輸入**
```
apple = [5, 5, 5]
capacity = [2, 4, 2, 7]
```

**步驟 1: 蘋果總數**
```
sum = 5 + 5 + 5 = 15
```

**步驟 2: 排序**
```
capacity 排序後: [7, 4, 2, 2]
```

**步驟 3: 裝箱**

| 迴圈 | 剩餘蘋果 | 選擇箱子 | 箱子數 |
|-----|---------|---------|--------|
| 開始 | 15      | -       | 0      |
| 1   | 15-7=8  | 7       | 1      |
| 2   | 8-4=4   | 4       | 2      |
| 3   | 4-2=2   | 2       | 3      |
| 4   | 2-2=0   | 2       | 4      |

**輸出**: 4（需要 4 個箱子）

## 如何執行

### 前置需求

- .NET 10.0 或更高版本
- Visual Studio 2022 或 VS Code

### 執行專案

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run
```

### 執行輸出範例

```
測試案例 1:
蘋果包: [1, 3, 2]
箱子容量: [4, 3, 1, 5, 2]
最少箱子數: 2
預期結果: 2

測試案例 2:
蘋果包: [5, 5, 5]
箱子容量: [2, 4, 2, 7]
最少箱子數: 4
預期結果: 3

測試案例 3:
蘋果包: [9]
箱子容量: [2, 2, 2, 2, 2]
最少箱子數: 5
預期結果: 5
```

## 相關主題

- 貪心演算法 (Greedy Algorithm)
- 排序 (Sorting)
- 陣列操作 (Array Manipulation)
