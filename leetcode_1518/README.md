# leetcode_1518

題目：1518. Water Bottles

原題連結：

- [LeetCode - English](https://leetcode.com/problems/water-bottles/)
- [LeetCode - 中文](https://leetcode.cn/problems/water-bottles/)

簡短描述

給定兩個整數 `numBottles`（初始滿瓶數）與 `numExchange`（兌換所需的空瓶數），每喝完一瓶滿水會得到一個空瓶。當你累積到 `numExchange` 個空瓶時，可以在商店用這些空瓶換成一瓶滿的水。請回傳你最多可以喝到的水瓶數。

此專案包含一個以 C# 撰寫的簡潔模擬解法，程式檔案為 `leetcode_1518/Program.cs`。

## 重點摘要

- 類型：模擬（Simulation）/ 貪婪。
- 核心想法：追蹤「空瓶數」隨時間的變化，重複兌換與飲用直到無法再兌換為止。
- 時間複雜度：$O(k)$，其中 $k$ 為實際喝到的總瓶數（迴圈每次至少縮減空瓶數 $numExchange-1$）。
- 空間複雜度：$O(1)$。

## 詳細解法說明（中文）

### 直觀思路

一開始有 `numBottles` 瓶滿水。當你喝掉一瓶滿水時，你會得到一個空瓶，因此初始時可以視為你已經喝掉了 `numBottles` 瓶，並且擁有 `numBottles` 個空瓶。

接下來，只要空瓶數 `empty` 大於等於 `numExchange`，你就可以用 `numExchange` 個空瓶換 1 瓶滿水。換到的新滿瓶喝掉之後又會得到新的空瓶，可以繼續參與後續兌換。重複這個過程直到 `empty < numExchange`。

用簡單的遞迴或迴圈模擬即可：

1. totalDrank += numBottles；empty += numBottles
2. while empty >= numExchange:
   - newFull = empty / numExchange（整數除法，代表可兌換到幾瓶）
   - totalDrank += newFull
   - empty = (empty % numExchange) + newFull（兌換後剩下的空瓶 + 喝掉新滿瓶後得到的空瓶）
3. 回傳 totalDrank。

### 為什麼這個模擬是正確的？

每次兌換我們都採取最大可能的兌換數（整數除法），沒有任何延遲或保存空瓶的策略能夠增加最終喝到的瓶數，因為空瓶只能在整數倍的 `numExchange` 才能兌換成新瓶；把可兌換的空瓶分散到後面也不會提高總數。因此貪婪地每次兌換最多瓶數是最優的。

另外，狀態可以由一個整數 `empty` 完全描述：手上目前有多少空瓶可用。把整個過程視為對 `empty` 一次次的變換，直到無法再前進。

### 邊界情況

- `numBottles == 0`：沒有初始的滿瓶，結果為 0。
- `numExchange <= 1`：理論上若 `numExchange == 1`，表示一個空瓶就能換一瓶，會導致無限循環；但依題目條件 `numExchange >= 2`，在此不處理無限的情況。若輸入不受限，可在程式加上保護判斷直接回傳 `int.MaxValue` 或其他處理。

## 程式碼逐行說明（對應 `leetcode_1518/Program.cs` 的 `NumWaterBottles`）

程式採用命名清楚、註解充分的方式撰寫。以下為重點說明（以程式內註解為主）：

- 初始化：
  - `int empty = 0;` 用來追蹤目前手上的空瓶數。
  - `int totalDrank = 0;` 用來累計已喝到的瓶數。

- 先把初始滿瓶喝掉（就等於你直接把初始數量加入結果與空瓶）：
  - `totalDrank += numBottles;`
  - `empty += numBottles;`

- 主要迴圈：`while (empty >= numExchange)`
  - `int newFull = empty / numExchange;`：使用整數除法取得可兌換的新瓶數。
  - `totalDrank += newFull;`：喝掉新兌換到的那幾瓶。
  - `empty = (empty % numExchange) + newFull;`：剩餘空瓶為未被用來兌換的空瓶（餘數）加上喝掉新瓶後得到的空瓶數。

最後回傳 `totalDrank`。

### 範例推演（numBottles=9, numExchange=3）

- 初始：totalDrank=9, empty=9
- 迴圈一：newFull=9/3=3 -> totalDrank=12；empty = 9%3 + 3 = 0 + 3 = 3
- 迴圈二：newFull=3/3=1 -> totalDrank=13；empty = 3%3 + 1 = 0 + 1 = 1
- 無法繼續（empty=1 < numExchange），結果為 13。

## 複雜度分析

- 時間複雜度：$O(k)$，其中 $k$ 為實際喝到的瓶數（也可以視為迴圈執行次數乘以常數操作）。每次迭代至少使得 `empty` 減少 $numExchange - 1$（因為交換後 `empty` = (empty % numExchange) + newFull，newFull = floor(empty/numExchange)，整體會往下收斂）。因此實際執行次數非常少，遠小於線性到初始瓶數的上界時常。

- 空間複雜度：$O(1)$，只使用固定數量的變數來追蹤狀態。

## 其他解法 / 推論

- 數學推導：可以把問題視為不斷把空瓶轉換為新瓶與消耗，最終結果等價於初始瓶數加上從空瓶累積兌換得到的瓶數。模擬法已足夠簡潔且高效。
- 若想要少些迴圈，可用一個公式變形或遞迴式，但程式上回傳的複雜度並不會比模擬顯著改善。

## 解法二（數學推導）— 詳細說明

此方法嘗試用常數時間 O(1) 的方式，直接計算從初始空瓶可以兌換到的額外瓶數，而不需要每次模擬交換的迴圈。

符號約定：令 b = numBottles（初始滿瓶數），e = numExchange（兌換所需空瓶數）。喝掉初始 b 瓶後，我們擁有 b 個空瓶。

觀察：每次用 e 個空瓶換到 1 瓶、喝掉後會再得到 1 個空瓶，等於這次兌換淨消耗了 (e - 1) 個空瓶。

若我們能夠進行 n 次兌換（並把這 n 瓶都喝掉），則空瓶數會變為：

b - n * (e - 1)

當這個數量小於 e 時就不能再進行兌換了，因此我們要找最小的 n 使得：

b - n * (e - 1) < e

解上式得：

n > (b - e) / (e - 1)

因此最小整數 n 為：

n = floor((b - e) / (e - 1)) + 1

（此式在 b >= e 時成立；若 b < e，則 n = 0）

最後總共能喝到的瓶數為初始的 b 加上可額外取得的 n：

total = b + n

範例驗證：b = 9, e = 3

- n = floor((9 - 3) / (3 - 1)) + 1 = floor(6/2) + 1 = 3 + 1 = 4
- total = 9 + 4 = 13（與模擬結果一致）

邊界與輸入檢查：

- 若 b < 0 或 e <= 1：題目條件通常假設 b >= 0 且 e >= 2；e <= 1 會導致無限兌換或不合理情況，程式應額外檢查並視情況拋例外或回傳特殊值。
- 若 b < e：此時 n = 0，直接回傳 b。

優點：

- 常數時間 O(1)、常數空間 O(1)。
- 直接計算，適用於需要大量重複呼叫而想避免迴圈開銷的情況（例如在大量測試或競賽題庫批次評估）。

缺點與注意事項：

- 公式推導需要注意整數運算與邊界條件（例如 b 和 e 的關係、e 為 2 時的處理）。
- 若輸入可能不合法（例如 e <= 1），必須在程式中處理以避免錯誤或無窮迴圈的推論。


## 解法比較：模擬（解法一） vs 數學（解法二）

以下比較幫助選擇在不同情境下採用哪個解法。

- 可讀性與直觀性：
  - 模擬（解法一）：直觀、容易理解。把整個流程具體模擬出來，適合教學或第一次推演問題的人。程式容易撰寫且錯誤率低。
  - 數學（解法二）：需要推導與對不等式的理解，對新手來說不如模擬直觀，但數學推導一旦確認正確，程式非常簡潔。

- 時間複雜度與效能：
  - 模擬：O(k)，k 為實際喝到的瓶數。對於題目常見範圍效能足夠且迴圈收斂快速（每次至少減少 e-1 空瓶），實務上很快。
  - 數學：O(1)，在理論上比模擬更快，特別在 b 很大或需要被頻繁呼叫的情況下更有效。

- 空間複雜度：兩者皆為 O(1)。

- 正確性與邊界：
  - 模擬：直接依規則模擬，處理邊界（例如 b < e、b = 0）時行為直觀，較不容易出現推導錯誤。
  - 數學：在大多數情況都正確，但需小心整數除法與負數情況、以及 e <= 1 的不合理輸入。

- 實作風險：
  - 模擬：低風險。
  - 數學：存在推導錯誤或寫錯公式的風險；若要用於 production，建議用單元測試覆蓋大量輸入以驗證與模擬結果一致。


## 驗證建議

為了確保兩種實作在所有合理範圍內一致，建議做以下驗證：

- 使用小範圍暴力測試：對 b 與 e 在合理小範圍（例如 b = 0..100, e = 2..10）逐一比較 `NumWaterBottles`（模擬）與 `NumWaterBottles2`（數學）結果是否相同。
- 加入邊界案例：b = 0、b = e-1、b = e、e = 2、b 很大（例如接近 int.MaxValue/2）等。

若你需要，我可以幫你把這些驗證加入專案小測試或在 `Program.cs` 中加入比對輸出。

## 如何執行（在此專案）

此專案是以 .NET (C#) 撰寫，請在包含 `leetcode_1518.sln` 的工作目錄下執行：

```bash
# 進入範例專案資料夾
cd leetcode_1518

# 建構
dotnet build

# 執行
dotnet run
```

程式會在主程式內跑幾組示範測試並印出結果。

## 檔案清單

- `leetcode_1518/Program.cs`：C# 範例實作與測試。

## 注意事項

> [!note]
>
> - 本題目假設 `numExchange >= 2`。如果輸入不合法（例如 `numExchange <= 1`），請在呼叫前檢查或在函式內加入額外保護。
> - 本 README 已依專案現況撰寫，不包含授權（LICENSE）或貢獻指南等，這些會另置於專案根目錄的專用檔案。

---

若你想要，我可以：

- 把這份 README 同步加入到 git，而不自動做 commit（由你決定）。
- 將 `Program.cs` 加入更多測試案例或單元測試檔案。
