# 1323. Maximum 69 Number（6 和 9 組成的最大數字）

此專案為 LeetCode 題目 1323 的 C# 解法實作與說明。

## 題目說明

給定一個只包含數字 6 和 9 的正整數 num，最多可以將一個數字由 6 變為 9 或由 9 變為 6，返回可取得的最大數字。

範例：輸入 `9669`，將最左側的 `6` 變成 `9` 可得到 `9969`，為最大可能值，回傳 `9969`。

## 解題要點（繁體中文詳解）

- 輸入的整數只包含數字 `6` 和 `9`。
- 因為高位的數字對整數大小影響較大，採用貪心策略：只要把最左邊（最高位）第一個出現的 `6` 變成 `9` 即可取得最大值。
- 若整數中不存在 `6`（全部為 `9`），則不需要任何變更，答案就是原數。

## 演算法與複雜度

- 方法：
  1. 將整數轉為字串或字元陣列。
  2. 從左到右掃描，遇到第一個 `'6'` 便把它改為 `'9'`，然後停止掃描。
  3. 將修改後的字元陣列轉回整數並回傳。
- 時間複雜度：O(d)，其中 d 為數字的位數（即字串長度）。
- 空間複雜度：O(d)，用於保存字元陣列與臨時字串。

## 程式碼說明

主要實作位於 `Program.cs` 中的 `Maximum69Number(int num)` 方法：

- 將 `num.ToString().ToCharArray()` 取得字元陣列。
- 迴圈從索引 0 開始，尋找第一個 `'6'` 並改為 `'9'`。
- 使用 `int.Parse(new string(digits))` 將結果轉回整數並回傳。

該專案包含簡單的 `Main` 測試，會針對數組 `{9669, 9996, 9999, 6666, 6, 9}` 輸出結果。

## 範例輸出

執行 `Program` 將印出類似以下內容：

輸入: 9669 -> 最大值: 9969

輸入: 9996 -> 最大值: 9999

輸入: 9999 -> 最大值: 9999

輸入: 6666 -> 最大值: 9666

輸入: 6 -> 最大值: 9

輸入: 9 -> 最大值: 9

## 如何執行

在擁有 .NET SDK（建議 .NET 8）與本工作區的環境下：

1. 使用 VS Code 開啟本工作區，或於終端機進入資料夾 `leetcode_1323/`。
2. 使用 dotnet build 建置專案：

```bash
dotnet build leetcode_1323/leetcode_1323.csproj -c Debug
```

3. 執行輸出檔案（或使用 `dotnet run`）：

```bash
dotnet run --project leetcode_1323/leetcode_1323.csproj
```

## 邊界條件與備註

- 輸入皆假設為正整數且只包含 `6` 與 `9`（根據題目條件）。
- 因為僅允許一次變換，該貪心策略是正確且最佳的。
- 若需處理更一般性的輸入（其他數字、負數、零、非數字字串），可額外加入驗證邏輯。

## 方法二：數學運算（不使用字串）

此方法直接使用整數的數學運算來尋找並改變最左邊的 `6`，避免把整數轉為字串或字元陣列。基本想法是從低位（個位）向高位迭代，記錄每次遇到 `6` 時該位對最終答案的潛在增益，最後將最高位的增益加到原數上。

具體步驟：

1. 初始化變數：`orig = num`（工作用複本）、`place = 1`（目前位權，從 1 開始）、`bestGain = 0`（記錄遇到的最大增益）。
2. 當 `orig > 0`：
   - 取得目前位的數字 `digit = orig % 10`。
   - 若 `digit == 6`：計算把該位從 6 變成 9 的增益 `gain = 3 * place`，若 `gain > bestGain`，則更新 `bestGain = gain`。
   - `orig /= 10`，`place *= 10` 繼續檢查下一高位。
3. 結束迴圈後，答案為 `num + bestGain`（如果不存在 `6`，`bestGain` 為 0，返回原數）。

範例（num = 9669）：

- 初始：orig=9669, place=1, bestGain=0

- pos=0: digit=9 -> 非 6，orig -> 966, place -> 10

- pos=1: digit=6 -> gain = 3 * 10 = 30，bestGain = 30，orig -> 96, place -> 100

- pos=2: digit=6 -> gain = 3 * 100 = 300，bestGain 更新為 300，orig -> 9, place -> 1000

- pos=3: digit=9 -> 非 6，結束迴圈

- 答案 = 9669 + 300 = 9969

實作提示：避免使用浮點次方（如 Math.Pow）來計算位權，因為浮點可能帶來精度問題；改用整數累乘（place *= 10）更安全。在 C# 中若擔心溢位，可把 `num`, `place`, `bestGain` 設為 `long` 或使用 `BigInteger`。

優點與缺點：

- 優點：不需字串分配，空間使用量低（O(1) 額外空間）；在記憶體敏感或需避免大量分配的情況下較佳。

- 缺點：實作上較不直觀，需要正確處理位權與可能的整數溢位；可讀性略遜於字串方法。

## 方法比較（優缺點與複雜度）

方法一（字串/字元陣列）

- 優點：實作直覺、程式碼簡潔；直接操作字元，改動單一位元容易理解與驗證。

- 缺點：需將整數轉為字串，進行字串與字元陣列分配，略微增加空間與時間開銷。

- 複雜度：時間 O(d)，空間 O(d)，其中 d 為數字位數。

方法二（數學運算）

- 優點：不需要字串分配，僅使用常數額外空間；對記憶體使用敏感的場景較好。

- 缺點：實作較不直觀，需要額外注意位權計算與整數溢位問題。

- 複雜度：時間 O(d)，空間 O(1)。

綜合建議：若追求可讀性與開發速度，使用方法一（字串法）；若在低記憶體或高效能的情境下，方法二（數學法）提供更低的空間成本。

---

作者：自動產生 README（來源程式在 `Program.cs`）
