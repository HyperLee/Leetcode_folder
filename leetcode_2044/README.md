# LeetCode 2044 - 統計按位或能得到最大值的子集數目

## 專案概述

本專案實作了 LeetCode 2044 題目的三種不同解法，用於解決「統計按位或能得到最大值的子集數目」問題。

### 題目連結

- [英文版 LeetCode](https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/description/?envType=daily-question&envId=2025-07-28)
- [中文版 LeetCode](https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/description/?envType=daily-question&envId=2025-07-28)

## 題目描述

給定一個整數陣列 `nums`，請找出 `nums` 的所有非空子集，其按位或（Bitwise OR）能達到最大值，並返回能達到最大按位或的不同子集數量。

### 重要概念

- **子集定義**：陣列 a 是陣列 b 的子集，若 a 可以透過刪除 b 中的某些（可能為零個）元素得到
- **按位或運算**：陣列 a 的按位或為 `a[0] OR a[1] OR ... OR a[a.length - 1]`
- **最大值特性**：所有元素的按位或就是可能的最大值（因為按位或只會增加或保持位元）

## 解法說明

### 解法一：位遮罩技術（Bit Masking）

#### 核心思想

使用位遮罩技術枚舉所有可能的非空子集，計算每個子集的按位或值，統計等於最大值的子集數量。

#### 演算法步驟

1. **計算最大值**：對所有元素進行按位或運算，得到可能的最大值
2. **枚舉子集**：使用位遮罩從 1 到 2^n-1，每個數字代表一種子集選擇方式
3. **計算OR值**：對每個子集計算按位或值
4. **統計結果**：若等於最大值則計數加一

#### 程式碼實作

```csharp
public int CountMaxOrSubsets(int[] nums)
{
    // 計算最大可能的按位或值
    int maxOr = 0;
    foreach (int num in nums)
    {
        maxOr |= num;
    }

    // 枚舉所有非空子集
    int count = 0;
    int n = nums.Length;
    
    for (int i = 1; i < (1 << n); i++)
    {
        int currOr = 0;
        
        for (int j = 0; j < n; j++)
        {
            if ((i & (1 << j)) != 0)
            {
                currOr |= nums[j];
            }
        }
        
        if (currOr == maxOr)
        {
            count++;
        }
    }
    
    return count;
}
```

#### 時間與空間複雜度

- **時間複雜度**：O(n × 2^n)
- **空間複雜度**：O(1)

### 解法二：回溯法（Backtracking）

#### 回溯法核心思想

使用深度優先搜尋（DFS）配合回溯法遍歷所有子集，透過遞迴的方式避免顯式建立子集陣列。

#### 回溯法演算法步驟

1. **計算最大值**：先計算所有元素的按位或值作為目標
2. **遞迴搜尋**：對每個元素有「選擇」和「不選擇」兩種決策
3. **狀態傳遞**：將當前OR值透過參數傳遞，避免重複計算
4. **基本情況**：當處理完所有元素時，檢查OR值是否等於最大值

#### 回溯法決策樹詳解

回溯法的核心是對陣列中的每個元素都面臨一個**二元決策**：

##### 選擇一：不選擇當前元素

```csharp
int count = Backtrack(nums, index + 1, currentOr, maxOr, hasElement);
```

- 跳過當前索引位置的元素
- 直接處理下一個元素（`index + 1`）
- 當前的按位或值 `currentOr` **保持不變**
- `hasElement` 狀態**保持不變**（因為沒有新增元素）

##### 選擇二：選擇當前元素

```csharp
int newOr = currentOr | nums[index];
count += Backtrack(nums, index + 1, newOr, maxOr, true);
```

- 將當前索引位置的元素加入子集
- 計算新的按位或值：`newOr = currentOr | nums[index]`
- 處理下一個元素（`index + 1`）
- 將 `hasElement` 設為 `true`（因為選擇了一個元素）

##### 決策樹範例：`[3, 1]`

```text
開始: index=0, currentOr=0, hasElement=false
├── 不選 nums[0]=3
│   └── index=1, currentOr=0, hasElement=false
│       ├── 不選 nums[1]=1
│       │   └── index=2 (結束) → currentOr=0, hasElement=false → 不計數 (空集合)
│       └── 選 nums[1]=1
│           └── index=2 (結束) → currentOr=1, hasElement=true → 檢查 1==3? 否 → 不計數
└── 選 nums[0]=3
    └── index=1, currentOr=3, hasElement=true
        ├── 不選 nums[1]=1
        │   └── index=2 (結束) → currentOr=3, hasElement=true → 檢查 3==3? 是 → 計數+1
        └── 選 nums[1]=1
            └── index=2 (結束) → currentOr=3|1=3, hasElement=true → 檢查 3==3? 是 → 計數+1
```

##### 生成的所有子集

1. 不選3，不選1 → `[]` (空集合，不計數)
2. 不選3，選1 → `[1]` (OR值=1，不等於最大值3)
3. 選3，不選1 → `[3]` (OR值=3，等於最大值3) ✓
4. 選3，選1 → `[3,1]` (OR值=3，等於最大值3) ✓

##### 結果說明

符合條件的子集有2個

##### 關鍵理解點

1. **窮舉所有可能性**：每個元素都有「選」或「不選」兩種選擇
2. **狀態傳遞**：每次遞迴都會傳遞當前的OR值和是否有元素的狀態
3. **避免重複計算**：直接在參數中傳遞當前OR值，不需要重新計算
4. **確保非空**：使用 `hasElement` 參數確保只計算非空子集

#### 回溯法程式碼實作

```csharp
public int CountMaxOrSubsetsOptimized(int[] nums)
{
    int maxOr = 0;
    foreach (int num in nums)
    {
        maxOr |= num;
    }

    return Backtrack(nums, 0, 0, maxOr);
}

private int Backtrack(int[] nums, int index, int currentOr, int maxOr, bool hasElement = false)
{
    if (index == nums.Length)
    {
        // 確保只計算非空子集
        return currentOr == maxOr && hasElement ? 1 : 0;
    }

    // 不選擇當前元素
    int count = Backtrack(nums, index + 1, currentOr, maxOr, hasElement);
    
    // 選擇當前元素
    int newOr = currentOr | nums[index];
    count += Backtrack(nums, index + 1, newOr, maxOr, true);

    return count;
}
```

#### 回溯法時間與空間複雜度

- **時間複雜度**：O(2^n)
- **空間複雜度**：O(n)（遞迴堆疊深度）

#### 重要修正說明

**問題：** 原始的回溯法實作在處理包含零元素的案例時會錯誤計算空集合。

**解決方案：** 新增 `hasElement` 參數來追踪當前子集是否包含至少一個元素：

- 在遞迴函式中加入 `bool hasElement = false` 參數
- 修正終止條件為 `currentOr == maxOr && hasElement`
- 當選擇元素時，將 `hasElement` 設為 `true`

**修正效果：** 確保只計算非空子集，避免空集合被錯誤計入結果。

### 解法三：動態規劃（Dynamic Programming）

#### 動態規劃核心思想

使用字典記錄每個可能的OR值對應的子集數量，逐個添加元素更新狀態，避免重複計算相同OR值的子集。

#### 動態規劃演算法步驟

1. **初始化狀態**：建立字典記錄OR值與對應子集數量的對應關係
2. **逐步更新**：對每個新元素，更新所有可能的OR值組合
3. **狀態轉移**：新OR值 = 原OR值 | 當前元素
4. **結果統計**：找到最大OR值並返回對應的子集數量

#### 動態規劃程式碼實作

```csharp
public int CountMaxOrSubsetsDP(int[] nums)
{
    // 使用字典記錄每個OR值對應的子集數量（不包含空集合）
    var orCount = new Dictionary<int, int>();

    foreach (int num in nums)
    {
        var nextStateOrCount = new Dictionary<int, int>(orCount);
        
        // 加入只包含當前元素的子集
        if (nextStateOrCount.TryGetValue(num, out int singleCount))
        {
            nextStateOrCount[num] = singleCount + 1;
        }
        else
        {
            nextStateOrCount[num] = 1;
        }
        
        // 對於每個已存在的OR值，嘗試加入當前數字
        foreach (var kvp in orCount)
        {
            int currentOr = kvp.Key;
            int count = kvp.Value;
            int newOr = currentOr | num;
            
            // 使用 TryGetValue 提高效能和可讀性
            if (nextStateOrCount.TryGetValue(newOr, out int existingCount))
            {
                nextStateOrCount[newOr] = existingCount + count;
            }
            else
            {
                nextStateOrCount[newOr] = count;
            }
        }
        
        orCount = nextStateOrCount;
    }

    // 找到最大OR值並直接返回對應的計數
    int maxOr = orCount.Keys.Max();
    
    return orCount[maxOr];
}
```

#### 動態規劃時間與空間複雜度

- **時間複雜度**：O(n × k)，其中 k 是不同OR值的數量
- **空間複雜度**：O(k)

#### 動態規劃解法改進

**原始問題：** 初始實作包含空集合並在最後嘗試排除，導致邊界條件處理錯誤。

**改進策略：** 採用更清晰的實作方式，從一開始就只處理非空子集：

1. **移除初始空集合**：不在字典中預設 `{0: 1}` 的空集合狀態
2. **先處理單元素子集**：每次迭代首先加入只包含當前元素的子集
3. **再處理組合子集**：對所有現有OR值與當前元素進行組合
4. **使用 TryGetValue**：提高字典操作的效能和可讀性
5. **簡化返回邏輯**：直接返回最大OR值對應的計數，無需複雜的邊界判斷

**優勢：**

- 邏輯更清晰，每個狀態都對應實際的非空子集
- 避免了複雜的空集合排除邏輯
- 程式碼更容易理解和維護
- 減少出錯的可能性

## 三種解法比較分析

### 效能比較表

| 解法 | 時間複雜度 | 空間複雜度 | 實際效能 | 記憶體使用 |
|------|------------|------------|----------|------------|
| 位遮罩技術 | O(n × 2^n) | O(1) | 較慢 | 極少 |
| 回溯法 | O(2^n) | O(n) | 中等 | 適中 |
| 動態規劃 | O(n × k) | O(k) | 最快 | 視k值而定 |

### 詳細優缺點分析

#### 解法一：位遮罩技術

**優點：**

- 🟢 **簡單直觀**：邏輯清晰，容易理解和實作
- 🟢 **空間效率極高**：只使用常數空間
- 🟢 **無遞迴**：避免堆疊溢位風險
- 🟢 **適合小規模**：當 n ≤ 20 時表現良好

**缺點：**

- 🔴 **時間複雜度高**：需要枚舉所有 2^n 個子集
- 🔴 **擴展性差**：當 n 增大時，效能急劇下降
- 🔴 **重複計算**：對每個子集都要重新計算OR值

**適用場景：**

- 陣列長度較小（n ≤ 20）
- 記憶體極度受限的環境
- 需要簡單實作的場合

#### 解法二：回溯法

**優點：**

- 🟢 **記憶體友善**：只使用遞迴堆疊空間
- 🟢 **可剪枝優化**：在某些情況下可以提前終止分支
- 🟢 **邏輯清晰**：遞迴結構易於理解
- 🟢 **無額外資料結構**：不需要建立字典或其他容器

**缺點：**

- 🔴 **仍有指數複雜度**：最壞情況下仍需要 O(2^n) 時間
- 🔴 **堆疊深度限制**：深度遞迴可能導致堆疊溢位
- 🔴 **難以進一步優化**：剪枝效果有限

**適用場景：**

- 中等規模問題（n ≤ 25）
- 需要清晰遞迴邏輯的場合
- 記憶體使用需要可控的情況

#### 解法三：動態規劃

**優點：**

- 🟢 **效能最佳**：時間複雜度通常遠小於 O(2^n)
- 🟢 **避免重複計算**：相同OR值的子集只計算一次
- 🟢 **可擴展性好**：適合較大規模的問題
- 🟢 **狀態清晰**：每個OR值的子集數量一目了然
- 🟢 **邏輯簡潔**：改進後的實作避免了複雜的邊界條件處理
- 🟢 **易於維護**：從設計上就只處理非空子集，降低出錯風險

**缺點：**

- 🔴 **空間使用不穩定**：空間複雜度取決於不同OR值的數量
- 🔴 **實作需要細心**：字典操作需要正確處理，但改進後已大幅簡化
- 🔴 **最壞情況退化**：當所有OR值都不同時，空間複雜度仍為 O(2^n)

**適用場景：**

- 大規模問題（n ≥ 20）
- OR值種類相對較少的情況
- 需要最佳效能的生產環境

### 選擇建議

1. **小規模問題（n ≤ 15）**：選擇位遮罩技術，簡單可靠
2. **中等規模問題（15 < n ≤ 25）**：選擇回溯法，平衡效能與空間
3. **大規模問題（n > 25）**：選擇動態規劃，追求最佳效能
4. **記憶體受限環境**：優先考慮位遮罩技術或回溯法
5. **效能要求極高**：選擇動態規劃解法

## 範例測試

### 測試案例 1

**輸入：** `nums = [3, 1]`

**輸出：** `2`

**解釋：** 最大OR值為3，符合條件的子集有：[3] 和 [3,1]

### 測試案例 2

**輸入：** `nums = [2, 2, 2]`

**輸出：** `7`

**解釋：** 最大OR值為2，所有非空子集都符合條件

### 測試案例 3

**輸入：** `nums = [3, 2, 1, 5]`

**輸出：** `6`

**解釋：** 最大OR值為7，需要包含3和5的子集才能達到

### 測試案例 4（邊界案例）

**輸入：** `nums = [0, 0, 0]`

**輸出：** `7`

**解釋：** 最大OR值為0，所有非空子集都符合條件：{0}×3, {0,0}×3, {0,0,0}×1 = 7個

### 測試案例 5

**輸入：** `nums = [1, 2, 4]`

**輸出：** `1`

**解釋：** 最大OR值為7，只有包含所有元素的子集[1,2,4]能達到

## 如何執行

### 建構專案

```bash
dotnet build
```

### 執行專案

```bash
dotnet run
```

### 執行測試

```bash
dotnet test
```

## 技術棧

- **語言：** C# 12
- **框架：** .NET 8.0
- **開發環境：** Visual Studio Code

## 學習重點

1. **位元操作技巧**：掌握位遮罩和按位或運算
2. **回溯法模式**：理解遞迴搜尋的設計思路和二元決策樹概念
3. **決策樹分析**：學會畫出回溯法的完整執行路徑，理解每個選擇的影響
4. **狀態管理**：掌握如何在遞迴中正確傳遞和更新狀態參數
5. **動態規劃優化**：學習如何避免重複計算
6. **演算法分析**：比較不同解法的時空複雜度
7. **實際應用權衡**：根據具體場景選擇最適合的解法
8. **邊界案例處理**：特別注意空集合的處理和零元素的特殊情況
9. **Bug 調試技巧**：透過測試案例發現問題，分析演算法邏輯錯誤
10. **程式碼一致性**：確保所有解法對相同輸入產生相同輸出
11. **遞迴思維**：理解「選擇」與「不選擇」的回溯法核心概念
12. **程式碼重構技能**：學會識別和修正邏輯錯誤，改進程式碼設計
13. **初始狀態設計**：理解不同初始化策略對演算法邏輯的影響
14. **字典操作最佳化**：使用 TryGetValue 等方法提高效能和可讀性

## 延伸思考

1. **進一步優化**：是否可以結合多種方法的優點？
2. **並行處理**：回溯法是否可以並行化執行？
3. **記憶體效率**：動態規劃解法的空間使用是否可以進一步優化？
4. **其他位元問題**：這些技巧如何應用到其他位元相關問題？
5. **測試驅動開發**：如何設計更全面的測試案例來發現潛在 bug？
6. **程式碼審查**：如何建立檢查清單來確保演算法實作的正確性？
7. **效能基準測試**：如何客觀比較不同解法在真實場景下的效能表現？
8. **回溯法剪枝**：在什麼情況下可以提早終止某些分支以提升效能？
9. **決策樹可視化**：如何建立工具來視覺化回溯法的執行過程？
10. **記憶化回溯**：是否可以結合記憶化技術來優化回溯法？
11. **設計模式應用**：如何運用設計模式來提高程式碼的可維護性？
12. **重構最佳實務**：什麼時候應該優先考慮邏輯清晰性而非效能優化？
13. **演算法驗證**：如何系統性地驗證不同實作版本的正確性？
14. **程式碼演進**：如何在保持向後相容的同時持續改進演算法實作？

---

本專案實作日期：2025年7月28日
