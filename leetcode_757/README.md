# LeetCode 757 - Set Intersection Size At Least Two

> 使用貪心演算法解決集合交集大小至少為 2 的最小化問題

## 問題描述

給定一個二維整數陣列 `intervals`,其中 `intervals[i] = [starti, endi]` 表示從 `starti` 到 `endi`(包含端點)的所有整數。

**包含集合(Containing Set)**:一個數組 `nums`,對於 `intervals` 中的每個區間,都至少有**兩個**整數屬於 `nums` 並且落在該區間內。

**目標**:回傳包含集合的最小可能大小(元素個數)。

### 範例

**範例 1:**

```text
輸入: intervals = [[1,3],[1,4],[2,5],[3,5]]
輸出: 3
解釋: 考慮集合 {2, 3, 4}。每個區間都至少有 2 個元素:
  - [1,3]: {2, 3}
  - [1,4]: {2, 3, 4}
  - [2,5]: {2, 3, 4}
  - [3,5]: {3, 4}
```

**範例 2:**

```text
輸入: intervals = [[1,2],[2,3],[2,4],[4,5]]
輸出: 5
解釋: 集合 {1, 2, 3, 4, 5} 滿足所有區間的要求
```

**範例 3:**

```text
輸入: intervals = [[1,3],[3,7],[8,9]]
輸出: 5
解釋: 
  - [1,3]: 需要至少 2 個元素
  - [3,7]: 需要至少 2 個元素(可以與第一個區間共用元素 3)
  - [8,9]: 此區間只有 2 個整數,必須都選擇
  最小集合可以是 {2, 3, 4, 8, 9} 或 {1, 3, 4, 8, 9}
```

### 約束條件

- `1 <= intervals.length <= 3000`
- `intervals[i].length == 2`
- `0 <= starti < endi <= 10^8`

## 解決方案

### 演算法:貪心策略

這個問題的關鍵在於如何選擇最少的元素來滿足所有區間的要求。我們採用貪心演算法:

#### 核心思路

1. **排序策略**
   - 按區間左端點**升序**排列
   - 當左端點相同時,按右端點**降序**排列
   - 這樣確保較短的區間會優先被處理

2. **從後往前處理**
   - 從最後一個區間開始往前遍歷
   - 對於每個區間,檢查它與交集集合已有多少個相交元素
   - 如果不足 2 個,從該區間的左邊界開始添加元素

3. **貪心選擇**
   - 總是從區間的最左邊開始選擇元素
   - 因為經過排序,左邊的元素更有可能覆蓋到前面的區間
   - 這樣能最小化最終交集集合的大小

#### 為什麼這個策略有效?

以範例 `[[1,3], [3,7], [8,9]]` 為例:

1. **處理 [8,9]**:這個區間只有兩個整數,必須選擇 `{8, 9}`

2. **處理 [3,7]**:需要 2 個元素,從左邊開始選擇 `{3, 4}`

3. **處理 [1,3]**:已經有元素 3 在集合中,只需再添加 1 個元素
   - 從左邊界開始選擇:添加 `{1}` 或 `{2}`

最終集合大小為 5。

#### 詳細流程圖

```text
排序後的區間: [[1,3], [1,4], [2,5], [3,5]]
(左端點相同時,右端點大的排前面)

從後往前處理:
┌─────────────────────────────────────┐
│ 步驟 1: 處理 [3,5]                   │
│ - 相交元素: 0 個                     │
│ - 需要添加: 2 個                     │
│ - 從左邊界開始: 添加 {3, 4}          │
│ - 交集集合: {3, 4}                   │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│ 步驟 2: 處理 [2,5]                   │
│ - 已有相交: {3, 4} (2個)             │
│ - 不需要添加                         │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│ 步驟 3: 處理 [1,4]                   │
│ - 已有相交: {3, 4} (2個)             │
│ - 不需要添加                         │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│ 步驟 4: 處理 [1,3]                   │
│ - 已有相交: {3} (1個)                │
│ - 需要添加: 1 個                     │
│ - 從左邊界開始: 添加 {1}             │
│ - 最終交集集合: {1, 3, 4}            │
└─────────────────────────────────────┘

結果: 3 個元素
```

### 複雜度分析

- **時間複雜度**: O(n log n + n²)
  - 排序: O(n log n)
  - 主迴圈: O(n)
  - Help 函式在最壞情況下: O(n)
  - 總體: O(n²) (當所有區間都重疊時)

- **空間複雜度**: O(n)
  - 需要額外的陣列來記錄每個區間與交集集合的相交元素

### 程式碼實作

主要方法:

- `IntersectionSizeTwo(int[][] intervals)`:主要解題函式
- `Help(int[][] intervals, IList<int>[] temp, int pos, int num)`:輔助函式,用於更新區間的相交元素記錄

詳細實作請參閱 [`Program.cs`](./leetcode_757/Program.cs)

## 執行方式

### 先決條件

- .NET 8.0 或更高版本

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run --project leetcode_757/leetcode_757.csproj
```

### 預期輸出

```text
測試案例 1: [[1,3],[1,4],[2,5],[3,5]]
結果: 3
預期: 3

測試案例 2: [[1,2],[2,3],[2,4],[4,5]]
結果: 5
預期: 5

測試案例 3: [[1,3],[3,7],[8,9]]
結果: 5
預期: 5
```

## 關鍵洞察

1. **排序的重要性**:正確的排序策略讓我們能夠從後往前貪心地選擇元素

2. **從左邊界選擇**:總是從區間的左邊界開始選擇元素,最大化對前面區間的覆蓋效果

3. **記錄相交元素**:使用額外的資料結構記錄每個區間已有的相交元素,避免重複計算

4. **提前終止**:在 Help 函式中,當發現區間不可能包含新元素時提前終止,優化效能

## 相關題目

- [452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/) - 類似的區間貪心問題
- [435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/) - 區間調度問題
- [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/) - 區間合併問題

## 參考資料

- [LeetCode 757 - Set Intersection Size At Least Two](https://leetcode.com/problems/set-intersection-size-at-least-two/)
- [LeetCode 757 - 設置交集大小至少為2 (中文)](https://leetcode.cn/problems/set-intersection-size-at-least-two/)
- [官方解法](https://leetcode.cn/problems/set-intersection-size-at-least-two/solutions/1686623/she-zhi-jiao-ji-da-xiao-zhi-shao-wei-2-b-vuiv/?envType=daily-question&envId=2025-11-20)
