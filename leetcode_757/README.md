# LeetCode 757 - Set Intersection Size At Least Two

> 使用貪心演算法解決集合交集大小至少為 2 的最小化問題

## 問題描述

給定一個二維整數陣列 `intervals`,其中 `intervals[i] = [starti, endi]` 表示從 `starti` 到 `endi`(包含端點)的所有整數。

**包含集合(Containing Set)**:一個數組 `nums`,對於 `intervals` 中的每個區間,都至少有**兩個**整數屬於 `nums` 並且落在該區間內。

**目標**:回傳包含集合的最小可能大小(元素個數)。

### 範例

**範例 1:**

```text
輸入: intervals = [[1,3],[1,4],[2,5],[3,5]]
輸出: 3
解釋: 考慮集合 {2, 3, 4}。每個區間都至少有 2 個元素:
  - [1,3]: {2, 3}
  - [1,4]: {2, 3, 4}
  - [2,5]: {2, 3, 4}
  - [3,5]: {3, 4}
```

**範例 2:**

```text
輸入: intervals = [[1,2],[2,3],[2,4],[4,5]]
輸出: 5
解釋: 集合 {1, 2, 3, 4, 5} 滿足所有區間的要求
```

**範例 3:**

```text
輸入: intervals = [[1,3],[3,7],[8,9]]
輸出: 5
解釋: 
  - [1,3]: 需要至少 2 個元素
  - [3,7]: 需要至少 2 個元素(可以與第一個區間共用元素 3)
  - [8,9]: 此區間只有 2 個整數,必須都選擇
  最小集合可以是 {2, 3, 4, 8, 9} 或 {1, 3, 4, 8, 9}
```

### 約束條件

- `1 <= intervals.length <= 3000`
- `intervals[i].length == 2`
- `0 <= starti < endi <= 10^8`

## 解決方案

本題提供兩種解法，各有其適用場景：

### 解法一：貪心演算法（從左到右排序）

這個問題的關鍵在於如何選擇最少的元素來滿足所有區間的要求。我們採用貪心演算法:

#### 核心思路

1. **排序策略**
   - 按區間左端點**升序**排列
   - 當左端點相同時,按右端點**降序**排列
   - 這樣確保較短的區間會優先被處理

2. **從後往前處理**
   - 從最後一個區間開始往前遍歷
   - 對於每個區間,檢查它與交集集合已有多少個相交元素
   - 如果不足 2 個,從該區間的左邊界開始添加元素

3. **貪心選擇**
   - 總是從區間的最左邊開始選擇元素
   - 因為經過排序,左邊的元素更有可能覆蓋到前面的區間
   - 這樣能最小化最終交集集合的大小

#### 為什麼這個策略有效?

以範例 `[[1,3], [3,7], [8,9]]` 為例:

1. **處理 [8,9]**:這個區間只有兩個整數,必須選擇 `{8, 9}`

2. **處理 [3,7]**:需要 2 個元素,從左邊開始選擇 `{3, 4}`

3. **處理 [1,3]**:已經有元素 3 在集合中,只需再添加 1 個元素
   - 從左邊界開始選擇:添加 `{1}` 或 `{2}`

最終集合大小為 5。

#### 詳細流程圖

```text
排序後的區間: [[1,3], [1,4], [2,5], [3,5]]
(左端點相同時,右端點大的排前面)

從後往前處理:
┌─────────────────────────────────────┐
│ 步驟 1: 處理 [3,5]                   │
│ - 相交元素: 0 個                     │
│ - 需要添加: 2 個                     │
│ - 從左邊界開始: 添加 {3, 4}          │
│ - 交集集合: {3, 4}                   │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│ 步驟 2: 處理 [2,5]                   │
│ - 已有相交: {3, 4} (2個)             │
│ - 不需要添加                         │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│ 步驟 3: 處理 [1,4]                   │
│ - 已有相交: {3, 4} (2個)             │
│ - 不需要添加                         │
└─────────────────────────────────────┘
           ↓
┌─────────────────────────────────────┐
│ 步驟 4: 處理 [1,3]                   │
│ - 已有相交: {3} (1個)                │
│ - 需要添加: 1 個                     │
│ - 從左邊界開始: 添加 {1}             │
│ - 最終交集集合: {1, 3, 4}            │
└─────────────────────────────────────┘

結果: 3 個元素
```

#### 複雜度分析

- **時間複雜度**: O(n²)
  - 排序: O(n log n)
  - 主迴圈: O(n)
  - Help 函式在最壞情況下: O(n)
  - 總體: O(n²) (當所有區間都重疊時)

- **空間複雜度**: O(n)
  - 需要額外的陣列來記錄每個區間與交集集合的相交元素

#### 程式碼實作

主要方法:
- `IntersectionSizeTwo(int[][] intervals)`:主要解題函式
- `Help(int[][] intervals, IList<int>[] temp, int pos, int num)`:輔助函式,用於更新區間的相交元素記錄

---

### 解法二：堆疊 + 二分搜尋法

#### 核心思路

1. **排序策略**：按區間右端點升序排列
   - 優先處理右端點較小的區間，確保貪心選擇的正確性
   - 右端點小的區間限制更強，應該先滿足

2. **堆疊維護已選擇的區間段**：
   - 堆疊中每個元素包含 `[left, right, sum]`
     - `left`：區間段的左端點
     - `right`：區間段的右端點
     - `sum`：從堆疊底到該元素的累積元素總數
   - 使用哨兵 `[-2, -2, 0]` 避免邊界判斷

3. **貪心選擇與區間合併**：
   - 對每個新區間，計算需要額外添加的元素數量 `d`
   - 使用二分搜尋快速找到與當前區間重疊的堆疊位置
   - 從區間右端點往左填充 `d` 個元素（貪心策略）
   - 如果新元素會覆蓋堆疊頂部的區間，則合併它們

#### 詳細流程

**初始化**
```
st = [[-2, -2, 0]]  // 哨兵
```

**處理每個區間 [start, end]**

1. **使用二分搜尋找到重疊位置**
   ```
   找到第一個 left >= start 的位置 pos
   取 e = st[pos - 1]  // 可能與當前區間重疊的最後一個堆疊元素
   ```

2. **計算需要添加的元素數量 d**
   ```
   d = 2 - (st.top.sum - e.sum)  // 扣除已在右側的元素
   if (start <= e.right):
       d -= (e.right - start + 1)  // 扣除重疊部分
   ```

3. **如果 d <= 0，跳過（已滿足）**

4. **貪心填充與合併**
   ```
   從 end 往左填充 d 個元素
   while (end - st.top.right <= d):
       彈出堆疊頂部元素 e
       d += (e.right - e.left + 1)  // 合併區間
   
   將新區間 [end - d + 1, end, st.top.sum + d] 加入堆疊
   ```

#### 範例演示：[[1,3],[1,4],[2,5],[3,5]]

**排序後（按右端點）**
```
[[1,3],[1,4],[2,5],[3,5]]
```

**處理過程**

初始狀態: `st = [[-2, -2, 0]]`

處理 [1,3]:
```
start=1, end=3
e = st[0] = [-2, -2, 0]
d = 2 - (0 - 0) = 2
start > e.right, 無重疊
從右端點填充 2 個元素：[2, 3]
st = [[-2, -2, 0], [2, 3, 2]]
```

處理 [1,4]:
```
start=1, end=4
e = st[0] = [-2, -2, 0]
d = 2 - (2 - 0) = 0
d <= 0，跳過（已有 [2,3] 滿足）
```

處理 [2,5]:
```
start=2, end=5
e = st[1] = [2, 3, 2]
d = 2 - (2 - 2) = 2
start <= e.right (2 <= 3)
d -= (3 - 2 + 1) = 2 - 2 = 0
d <= 0，跳過（已有 [2,3] 滿足）
```

處理 [3,5]:
```
start=3, end=5
e = st[1] = [2, 3, 2]
d = 2 - (2 - 2) = 2
start <= e.right (3 <= 3)
d -= (3 - 3 + 1) = 2 - 1 = 1
需要添加 1 個元素

檢查合併：end - st.top.right = 5 - 3 = 2 > d = 1
不需要合併，直接添加新區間 [5, 5, 3]
st = [[-2, -2, 0], [2, 3, 2], [5, 5, 3]]
```

最終結果：3

#### 開區間二分搜尋（LowerBound）

**算法特點**
- 搜尋範圍：`(left, right)` 開區間
- 循環不變量：
  - `st[left][0] < target`
  - `st[right][0] >= target`
- 最終返回 `right`，即第一個滿足條件的位置

**優勢**
- 不需要處理邊界情況（`left = 0` 或 `right = n-1`）
- 循環條件簡單：`left + 1 < right`
- 不會出現死循環

**範例**
```
st = [[-2, -2, 0], [2, 3, 2], [5, 5, 3]]
尋找第一個 left >= 3

初始：left = -1, right = 3
第一次：mid = 1, st[1][0] = 2 < 3, left = 1
第二次：mid = 2, st[2][0] = 5 >= 3, right = 2
left + 1 = right，結束
返回 right = 2
```

#### 複雜度分析

- **時間複雜度**: O(n log n)
  - 排序：O(n log n)
  - 每個區間處理：
    - 二分搜尋：O(log n)
    - 堆疊操作：平攤 O(1)（每個元素最多入棧出棧一次）
  - 總體：O(n log n)

- **空間複雜度**: O(n)
  - 堆疊最多儲存 O(n) 個區間段

#### 程式碼實作

主要方法:
- `IntersectionSizeTwoStack(int[][] intervals)`:主要解題函式
- `LowerBound(List<int[]> st, int target)`:開區間二分搜尋輔助函式

---

### 兩種方法比較

| 比較項目 | 解法一：貪心（從左排序） | 解法二：堆疊 + 二分搜尋 |
|---------|------------------------|----------------------|
| **排序依據** | 左端點升序，右端點降序 | 右端點升序 |
| **處理方向** | 從後往前 | 從前往後 |
| **核心數據結構** | 陣列（記錄每個區間的相交元素） | 堆疊（維護區間段） |
| **時間複雜度** | O(n²) | O(n log n) |
| **空間複雜度** | O(n) | O(n) |
| **實現難度** | 簡單直觀 | 較複雜，需理解堆疊維護邏輯 |
| **適用場景** | 小規模數據，代碼簡潔優先 | 大規模數據，性能要求高 |

#### 詳細分析

**解法一優勢**
1. 代碼簡潔：邏輯直觀，易於理解和實現
2. 調試容易：可以清楚看到每個區間的相交元素
3. 適合小數據：對於 n < 1000 的情況，性能差異不明顯

**解法一劣勢**
1. 時間複雜度高：每次添加元素需要更新所有前面的區間，最壞情況 O(n²)
2. 大數據性能差：當 n > 10000 時，可能出現超時

**解法二優勢**
1. 時間複雜度優：O(n log n)，適合大規模數據
2. 堆疊維護高效：通過合併區間避免重複計算
3. 二分搜尋加速：快速定位重疊區間

**解法二劣勢**
1. 實現複雜：需要理解堆疊的維護邏輯和區間合併策略
2. 調試困難：堆疊狀態變化複雜，不易追蹤
3. 代碼較長：需要額外實現二分搜尋函式

#### 選擇建議

- **學習階段**：先實現解法一，理解貪心策略的核心思想
- **面試場景**：
  - 時間充足：實現解法二展示算法優化能力
  - 時間緊迫：實現解法一確保正確性
- **實際應用**：
  - n < 1000：兩種方法都可以
  - n > 10000：建議使用解法二

#### 共同點

1. **都使用貪心策略**：
   - 解法一：從區間左端點開始選擇
   - 解法二：從區間右端點開始選擇

2. **都需要排序**：
   - 排序是貪心策略正確性的基礎
   - 不同的排序方式對應不同的處理邏輯

3. **核心目標相同**：
   - 最小化交集集合的大小
   - 確保每個區間至少有 2 個元素在交集中

---

### 程式碼實作

詳細實作請參閱 [`Program.cs`](./leetcode_757/Program.cs)

## 執行方式

### 先決條件

- .NET 8.0 或更高版本

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run --project leetcode_757/leetcode_757.csproj
```

### 預期輸出

```text
測試案例 1: [[1,3],[1,4],[2,5],[3,5]]
結果: 3
預期: 3

測試案例 2: [[1,2],[2,3],[2,4],[4,5]]
結果: 5
預期: 5

測試案例 3: [[1,3],[3,7],[8,9]]
結果: 5
預期: 5

=== 解法二：堆疊 + 二分搜尋法 ===

測試案例 1: [[1,3],[1,4],[2,5],[3,5]]
結果: 3
預期: 3

測試案例 2: [[1,2],[2,3],[2,4],[4,5]]
結果: 5
預期: 5

測試案例 3: [[1,3],[3,7],[8,9]]
結果: 5
預期: 5
```

## 關鍵洞察

1. **排序的重要性**:正確的排序策略讓我們能夠從後往前貪心地選擇元素

2. **從左邊界選擇**:總是從區間的左邊界開始選擇元素,最大化對前面區間的覆蓋效果

3. **記錄相交元素**:使用額外的資料結構記錄每個區間已有的相交元素,避免重複計算

4. **提前終止**:在 Help 函式中,當發現區間不可能包含新元素時提前終止,優化效能

## 相關題目

- [452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/) - 類似的區間貪心問題
- [435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/) - 區間調度問題
- [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/) - 區間合併問題

## 參考資料

- [LeetCode 757 - Set Intersection Size At Least Two](https://leetcode.com/problems/set-intersection-size-at-least-two/)
- [LeetCode 757 - 設置交集大小至少為2 (中文)](https://leetcode.cn/problems/set-intersection-size-at-least-two/)
- [官方解法](https://leetcode.cn/problems/set-intersection-size-at-least-two/solutions/1686623/she-zhi-jiao-ji-da-xiao-zhi-shao-wei-2-b-vuiv/?envType=daily-question&envId=2025-11-20)
