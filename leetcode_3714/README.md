# LeetCode 3714 - Longest Balanced Substring II

> 最長的平衡子字串 II

## 題目描述

給定一個僅包含字元 `'a'`、`'b'` 和 `'c'` 的字串 `s`。若子字串中所有出現的**不同字元出現次數相同**，則稱該子字串為「**平衡**」。回傳 `s` 中最長的平衡子字串的長度。

- [LeetCode 題目連結 (EN)](https://leetcode.com/problems/longest-balanced-substring-ii/description/?envType=daily-question&envId=2026-02-13)
- [LeetCode 題目連結 (CN)](https://leetcode.cn/problems/longest-balanced-substring-ii/description/?envType=daily-question&envId=2026-02-13)

### 範例

| 輸入 | 輸出 | 說明 |
|------|------|------|
| `"abcabc"` | `6` | 整個字串即為平衡子字串，a、b、c 各出現 2 次 |
| `"aaa"` | `3` | 僅包含一種字元，連續 3 個 'a' 即為平衡 |
| `"abab"` | `4` | 包含兩種字元 a、b 各出現 2 次 |
| `"aabbcc"` | `6` | a、b、c 各出現 2 次 |

---

## 解題概念與出發點

本題的核心觀察是：字串中只有三種字元 `a`、`b`、`c`，因此一個**平衡子字串**中的不同字元只可能有 **1 種、2 種或 3 種**。我們可以**分情況討論**，分別求解後取最大值。

此外，「兩種字元個數相等」可以透過**前綴和差值**轉化為經典的**子陣列和問題**，搭配**雜湊表**記錄首次出現位置，達到 $O(n)$ 時間複雜度。

---

## 解法：枚舉 + 前綴和 + 雜湊表

將問題拆分為三種情況：

### 情況一：僅包含一種字元

最簡單的情況 — 計算**最長連續相同字元**的長度。

從左到右掃描字串，維護變數 `last` 記錄當前連續相同字元長度：
- 若 `s[i] == s[i-1]`，則 `last++`
- 否則 `last = 1`

每步以 `last` 更新答案。

### 情況二：包含兩種字元

枚舉所有兩種字元的組合：`(a,b)`、`(b,c)`、`(a,c)`。

以 `(a,b)` 為例，字元 `c` 會將字串分割為若干段，每段內只包含 `a` 和 `b`。

**關鍵推導：** 若子字串 `s[i..j]` 中 `a` 和 `b` 出現次數相等，則：

$$S_a[j] - S_a[i-1] = S_b[j] - S_b[i-1]$$

移項得到：

$$S_a[j] - S_b[j] = S_a[i-1] - S_b[i-1]$$

因此只需用雜湊表記錄每個**前綴差值** $S_a[i] - S_b[i]$ 最早出現的位置，當同一差值再次出現時，中間的區間就是平衡子字串。

### 情況三：包含三種字元

若子字串 `s[i..j]` 中三種字元個數相等，需同時滿足：

$$S_a[j] - S_b[j] = S_a[i-1] - S_b[i-1]$$

$$S_b[j] - S_c[j] = S_b[i-1] - S_c[i-1]$$

用**二元組** $(S_b - S_a,\ S_b - S_c)$ 作為雜湊表的鍵，記錄最早出現位置即可。

> [!NOTE]  
> 為避免差值為負數造成鍵值衝突，實作中將差值加上字串長度 `n` 作為偏移。

### 複雜度分析

| | 複雜度 |
|---|---|
| 時間 | $O(n)$ |
| 空間 | $O(n)$ |

---

## 舉例演示流程

以 `s = "abcabc"` 為例，完整流程如下：

### 情況一：最長連續相同字元

```
a b c a b c
1 1 1 1 1 1  ← 每個字元都不同，最長 = 1
```

結果：`res = 1`

### 情況二：兩種字元組合

以 `(a, b)` 為例，字串被 `c` 分割為 `"ab"` 和 `"ab"` 兩段：

**第一段 `"ab"`（索引 0~1）：**

| 步驟 | 字元 | diff | 雜湊表 | 更新 |
|------|------|------|--------|------|
| 初始 | — | 0 | `{0: -1}` | — |
| i=0 | `a` | +1 | `{0: -1, 1: 0}` | — |
| i=1 | `b` | 0 | `{0: -1, 1: 0}` | `1 - (-1) = 2` |

**第二段 `"ab"`（索引 3~4）：** 同理得到長度 2。

情況二最大結果：`res = 2`

### 情況三：三種字元

使用前綴計數 `pre = [count_a, count_b, count_c]`：

| i | 字元 | pre | 鍵 (Sb-Sa, Sb-Sc) | 雜湊表操作 | 更新 |
|---|------|------|-------------------|-----------|------|
| — | — | [0,0,0] | (0, 0) | 存入 pos=-1 | — |
| 0 | `a` | [1,0,0] | (-1, 0) | 存入 pos=0 | — |
| 1 | `b` | [1,1,0] | (0, 1) | 存入 pos=1 | — |
| 2 | `c` | [1,1,1] | (0, 0) | 已存在 pos=-1 | `2 - (-1) = 3` |
| 3 | `a` | [2,1,1] | (-1, 0) | 已存在 pos=0 | `3 - 0 = 3` |
| 4 | `b` | [2,2,1] | (0, 1) | 已存在 pos=1 | `4 - 1 = 3` |
| 5 | `c` | [2,2,2] | (0, 0) | 已存在 pos=-1 | `5 - (-1) = 6` |

情況三結果：`res = 6`

**最終答案：** `max(1, 2, 6) = 6`

---

## 技術棧

- **語言：** C# 14 / .NET 10
- **框架：** Console Application

## 快速開始

```bash
dotnet build
dotnet run --project leetcode_3714
```
