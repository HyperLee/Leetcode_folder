<!--
  這份 README.md 針對 leetcode_3541 專案（C# 範例）撰寫，內容以繁體中文（zh-TW）呈現，
  重點放在兩個解法的詳細說明、複雜度分析、比較與優缺點。
-->
# 3541 - Find Most Frequent Vowel and Consonant

本專案示範 LeetCode 題目「3541. Find Most Frequent Vowel and Consonant」的兩種 C# 解法。

題目簡述：給定只包含小寫英文字母（`'a'` 到 `'z'`）的字串 `s`，
回傳字串中出現頻率最高的元音（a, e, i, o, u）與出現頻率最高的輔音（其他字母）頻率之和。
若某類別（元音或輔音）不存在，視其頻率為 0。

此專案包含：
- `Program.cs`：主程式與兩個解法 `Solution.MaxFrequencySum` 與 `Solution.MaxFrequencySum2` 的實作。

## 快速開始

> [!NOTE]
> 範例使用 .NET 8（專案已用 .csproj 設定），請先安裝相容的 .NET SDK。

在專案資料夾（含 `leetcode_3541.csproj`）下執行：

```pwsh
dotnet build
dotnet run --project ./leetcode_3541/leetcode_3541.csproj
```

範例輸入（程式內建）：
- `"abcde"`
- `"aaaaa"`
- `"bcdfgh"`
- `"abacaba"`
- `""`（空字串）

範例輸出（程式會印出兩個方法的結果）：

```
s = "abcde", result = 2
s = "abcde", result2 = 2
s = "aaaaa", result = 5
s = "aaaaa", result2 = 5
s = "bcdfgh", result = 2
s = "bcdfgh", result2 = 2
s = "abacaba", result = 4
s = "abacaba", result2 = 4
s = "", result = 0
s = "", result2 = 0
```

## 解法概覽

本專案實作兩種常見策略：

1. 使用固定大小陣列（26 個整數）搭配 `Span<int>` / `stackalloc` 計數字母（在 `MaxFrequencySum`）。
2. 使用 `Dictionary<char,int>` 動態計數（在 `MaxFrequencySum2`）。

下面會針對每種解法做詳細步驟、複雜度分析、實務比較與優缺點。

---

## 解法一（陣列計數，推薦）

實作要點：

1. 使用長度為 26 的整數陣列（`Span<int>` + `stackalloc`）來計數每個字母的出現次數，索引對應 `ch - 'a'`。
2. 先檢查輸入是否為 `null` 或空字串，若是回傳 0。
3. 遍歷字串，對每個字元做範圍檢查（保護性處理），然後將對應索引的計數加一。
4. 使用一個長度為 26 的布林陣列標記哪些是元音（`a,e,i,o,u`）。
5. 再度掃描 26 個計數，分別找出元音與輔音的最大頻率，最後回傳兩者之和。

程式邏輯（步驟化）：

- 驗證輸入（null/empty）→ 回 0
- 建立 `Span<int> counts = stackalloc int[26]`
- 遍歷字串，忽略非 `'a'`..`'z'` 的字元，並累加 `counts[ch - 'a']++`
- 建立 `bool[] isVowel` 並標記 5 個元音
- 遍歷 `counts`，分別更新 `maxVowel` 與 `maxConsonant`
- 回傳 `maxVowel + maxConsonant`

時間複雜度：O(n + 26) = O(n)

空間複雜度：O(1)（固定大小 26 的陣列，且使用 `stackalloc` 分配在堆疊上，避免 GC 產生）

優點：

- 速度最快：陣列存取比 Dictionary 快，沒有 hash 運算與額外的指標開銷。
- 低延遲且低 GC：採用 `stackalloc` / `Span<int>` 時，記憶體分配在堆疊上，沒有額外的堆積分配。
- 明確且可預測的記憶體使用。

缺點與注意事項：

- 程式較為低階（對於初學者，`stackalloc` 與 `Span<T>` 可能不直覺）。
- 如果輸入含有非小寫字母，會被忽略（程式有保護性處理，但題目保證輸入為小寫）。

何時使用：

- 要求最佳效能與最小記憶體開銷時，或在高頻次呼叫的熱路徑上。

---

## 解法二（Dictionary 計數，程式碼可讀性佳）

實作要點：

1. 使用 `Dictionary<char,int>` 來動態計數出現過的字母與其頻率。
2. 遍歷字串，忽略非 `'a'`..`'z'` 的字元。
3. 每次遇到字元就更新字典（若不存在則新增，存在則 ++）。
4. 最後對字典的鍵值對做一次遍歷，判斷字元是否為元音（用 `"aeiou".Contains(letter)`），並更新 `maxVowel` 與 `maxConsonant`。

時間複雜度：平均 O(n)（每次字典存取為 O(1) 平均，但常數因子較大）

空間複雜度：O(k)，k 為字串中實際出現的不同字母數（最多 26）

優點：

- 程式碼直觀、容易閱讀與維護（對於初學者友善）。
- 不需要額外建構 26 長度陣列，對於非常稀疏的字元集合會更節省（但在此題上最多 26，差異有限）。

缺點：

- 相較於陣列，Dictionary 有較高的常數時間開銷（hash 計算、碰撞處理、桶陣列等）。
- 會造成堆積分配，可能增加 GC 壓力（雖然大小受限於最多 26 個鍵）。

何時使用：

- 需要較高可讀性、開發速度優先且效能不是瓶頸時。

---

## 詳細比較（實務導向）

- 性能（速度）：解法一（陣列） > 解法二（Dictionary）
- 記憶體：解法一（使用 `stackalloc` 時）更省且沒有 GC；解法二 需在堆積分配 Dictionary 物件與內部結構。
- 可讀性與維護性：解法二較簡潔直觀；解法一對初學者有少許學習曲線。
- 邊界情況處理：兩者都做了忽略非小寫字元的保護性處理；對於空字串或 null 都會回傳 0（解法一顯式檢查，解法二 在 null 輸入下若未處理會拋例外，實作中建議先檢查）。

選擇建議：

- 若在競賽或時間／空間嚴格的場景下，選擇解法一。
- 若是在一般工程任務、可讀性優先或想快速實作，選擇解法二。

---

## 邊界與測試重點

- 空字串與 `null`：應回傳 0。
- 僅有元音或僅有輔音：另一類別頻率視為 0。
- 多個字元頻率相同：題目允許任意選一個，所以只需回傳最大頻率值。
- 非小寫字元出現：兩個實作皆以保護性處理忽略之（題目保證為小寫，但實務上仍需考量）。

---

## 程式碼設計註記

- 已在 `Program.cs` 中加入註解型文件（XML doc comments）與保護性輸入檢查。
- 在 C# 中，若要追求極致效能，可再加入 `unsafe` 與指標運算，但在這類簡單題目中不建議以可讀性為代價追求微幅效能提升。

---

## 進一步可做的改良

- 在大型系統中，有可能需要考慮本地化（大小寫處理、Unicode 支援等）。
- 若輸入字元範圍擴大到整個 Unicode，可以考慮先標準化字元再採用字典或分區計數策略。

---

## 完成項目與驗證

- 已建立 `README.md`（本檔案）以說明兩個解法與比較。
- 建議在本機執行 `dotnet build` 與 `dotnet run` 驗證輸出（如上範例）。

---

若需要，我可以：
- 為兩個方法各自新增單元測試（xUnit / NUnit 範例）並在 CI 內執行。
- 提供更深入的微基準（BenchmarkDotNet）比較兩種實作的詳細效能資料。
