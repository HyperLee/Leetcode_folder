# LeetCode 2483 - 商店的最小代價 (Minimum Penalty for a Shop)

> **難度**: 中等 (Medium)  
> **來源**: [LeetCode 2483](https://leetcode.com/problems/minimum-penalty-for-a-shop/description/?envType=daily-question&envId=2025-12-26)  
> **類型**: 陣列、動態規劃、前綴和、最佳化

## 📝 題目描述

你是一家商店的老闆，你想確定最佳的關門時間以減少罰款。你有一個由字元 `'Y'` 和 `'N'` 組成的字串 `customers`，其中：
- `customers[i] = 'Y'` 表示在第 i 小時有顧客來到商店
- `customers[i] = 'N'` 表示在第 i 小時沒有顧客

商店可以在第 `j` 小時關門（`0 ≤ j ≤ n`），其中 `n` 是 `customers` 字串的長度。罰款計算規則如下：

- **對於關門前的每個小時**：如果該小時商店開門但沒有顧客（`customers[i] = 'N'`），將被罰款 `1`
- **對於關門後的每個小時**：如果該小時商店關門但有顧客（`customers[i] = 'Y'`），將被罰款 `1`

回傳能讓總罰款最小的**最早**關門時間。

### 範例

**範例 1:**
```
輸入: customers = "YYNY"
輸出: 2
解釋: 
- 第 0 小時關門: 罰款 = 0 + 3 = 3 (0 + 3個Y)
- 第 1 小時關門: 罰款 = 0 + 2 = 2 (0個N + 2個Y)  
- 第 2 小時關門: 罰款 = 1 + 1 = 2 (1個N + 1個Y)
- 第 3 小時關門: 罰款 = 1 + 1 = 2 (1個N + 1個Y)
- 第 4 小時關門: 罰款 = 2 + 0 = 2 (2個N + 0個Y)
最小罰款是 2，最早的關門時間是第 1 小時。
```

**範例 2:**
```
輸入: customers = "NNNNN"
輸出: 0
解釋: 沒有顧客，所以最好立即關門，罰款為 0。
```

**範例 3:**
```
輸入: customers = "YYYY"
輸出: 4
解釋: 每小時都有顧客，所以最好一直開到最後，在第 4 小時關門。
```

## 💡 解題思路

### 核心概念

這是一個**最佳化問題**，我們需要找到一個關門時間點，使得總罰款最小。關鍵觀察：
- **前綴罰款**：關門前的 'N' 字元數量（開門但無顧客）
- **後綴罰款**：關門後的 'Y' 字元數量（關門但有顧客）
- **總罰款** = 前綴罰款 + 後綴罰款

### 方法：枚舉 + 最佳化

不需要預先計算所有 'Y' 的數量，而是以"第 0 小時關門"的代價為基準，動態調整相對代價：

1. **初始化**：假設第 0 小時關門，此時 `pre = 0`，`suf = 0`
2. **遍歷每個可能的關門時間** `i`（0 到 n）
3. **更新最小代價**：如果當前代價更小，更新結果
4. **調整代價**：
   - 如果 `customers[i] = 'N'`：延後關門會增加前綴代價（`pre++`）
   - 如果 `customers[i] = 'Y'`：延後關門會減少後綴代價（`suf--`）

### 時間複雜度
- **時間複雜度**: `O(n)` - 只需要遍歷一次字串
- **空間複雜度**: `O(1)` - 只使用常數額外空間

## 🔍 演算法詳解

### 步驟分解

以 `customers = "YYNY"` 為例：

| 關門時間 | 當前字元 | pre (前綴N) | suf (後綴Y) | 總代價 | 是否更新 |
|---------|---------|------------|------------|--------|---------|
| i=0     | -       | 0          | 0          | 0      | ✓ (res=0) |
| i=1     | Y       | 0          | -1         | -1     | ✓ (res=1) |
| i=2     | Y       | 0          | -2         | -2     | ✓ (res=2) |
| i=3     | N       | 1          | -2         | -1     | ✗       |
| i=4     | Y       | 1          | -3         | -2     | ✗       |

最小代價為 -2，對應的最早關門時間為第 2 小時。

### 程式碼實作

```csharp
public int BestClosingTime(string customers)
{
    int n = customers.Length;
    int suf = 0;      // 後綴代價：關門後有顧客的罰分
    int pre = 0;      // 前綴代價：關門前無顧客的罰分
    int minCost = 0;  // 目前找到的最小代價
    int res = 0;      // 最佳關門時間

    // 枚舉所有可能的關門時間 i (0 ≤ i ≤ n)
    for(int i = 0; i <= n; i++)
    {
        // 如果目前代價比最小代價還小，更新最小代價和結果
        if(minCost > suf + pre)
        {
            minCost = suf + pre;
            res = i;
        }
        
        // 更新下一輪的代價計算
        if(i < n && customers[i] == 'N')
        {
            // 如果第 i 小時沒有顧客，延後關門會增加前綴代價
            pre++;
        }
        else if(i < n)
        {
            // 如果第 i 小時有顧客，延後關門會減少後綴代價
            suf--;
        }
    }
    return res;
}
```

## 🚀 如何執行

1. **編譯專案**：
   ```bash
   dotnet build
   ```

2. **執行程式**：
   ```bash
   dotnet run
   ```

3. **執行結果**：程式會自動測試多個範例案例並顯示結果。

## 📊 測試案例

程式包含以下測試案例：

| 輸入      | 預期輸出 | 說明              |
|-----------|---------|------------------|
| "YYNY"    | 2       | 混合顧客模式      |
| "NNNNN"   | 0       | 全無顧客，立即關門 |
| "YYYY"    | 4       | 全有顧客，最晚關門 |
| "YN"      | 1       | 簡單兩小時案例    |

## 🎯 關鍵要點

> [!IMPORTANT]
> 1. **邊界條件**：關門時間可以是 0 到 n（包含 n），表示可以立即關門或營業到最後
> 2. **最早原則**：當有多個最小代價時，選擇最早的關門時間
> 3. **相對代價**：不需要計算絕對代價值，只需要比較相對大小

> [!TIP]
> 這個問題的核心是理解"延後關門"對兩種罰款的影響：
> - 遇到 'N' → 增加開門無顧客的罰款
> - 遇到 'Y' → 減少關門有顧客的罰款

## 🔗 相關題目

- [LeetCode 121 - 買賣股票的最佳時機](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [LeetCode 53 - 最大子序和](https://leetcode.com/problems/maximum-subarray/)
- [LeetCode 1014 - 最佳觀光組合](https://leetcode.com/problems/best-sightseeing-pair/)
