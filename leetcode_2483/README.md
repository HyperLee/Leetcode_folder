# LeetCode 2483 - 商店的最小代價 (Minimum Penalty for a Shop)

> **難度**: 中等 (Medium)  
> **來源**: [LeetCode 2483](https://leetcode.com/problems/minimum-penalty-for-a-shop/description/?envType=daily-question&envId=2025-12-26)  
> **類型**: 陣列、動態規劃、前綴和、最佳化

## 📝 題目描述

你是一家商店的老闆，你想確定最佳的關門時間以減少罰款。你有一個由字元 `'Y'` 和 `'N'` 組成的字串 `customers`，其中：
- `customers[i] = 'Y'` 表示在第 i 小時有顧客來到商店
- `customers[i] = 'N'` 表示在第 i 小時沒有顧客

商店可以在第 `j` 小時關門（`0 ≤ j ≤ n`），其中 `n` 是 `customers` 字串的長度。罰款計算規則如下：

- **對於關門前的每個小時**：如果該小時商店開門但沒有顧客（`customers[i] = 'N'`），將被罰款 `1`
- **對於關門後的每個小時**：如果該小時商店關門但有顧客（`customers[i] = 'Y'`），將被罰款 `1`

回傳能讓總罰款最小的**最早**關門時間。

### 範例

**範例 1:**
```
輸入: customers = "YYNY"
輸出: 2
解釋: 
- 第 0 小時關門: 罰款 = 0 + 3 = 3 (0 + 3個Y)
- 第 1 小時關門: 罰款 = 0 + 2 = 2 (0個N + 2個Y)  
- 第 2 小時關門: 罰款 = 1 + 1 = 2 (1個N + 1個Y)
- 第 3 小時關門: 罰款 = 1 + 1 = 2 (1個N + 1個Y)
- 第 4 小時關門: 罰款 = 2 + 0 = 2 (2個N + 0個Y)
最小罰款是 2，最早的關門時間是第 1 小時。
```

**範例 2:**
```
輸入: customers = "NNNNN"
輸出: 0
解釋: 沒有顧客，所以最好立即關門，罰款為 0。
```

**範例 3:**
```
輸入: customers = "YYYY"
輸出: 4
解釋: 每小時都有顧客，所以最好一直開到最後，在第 4 小時關門。
```

## 💡 解題思路

### 核心概念

這是一個**最佳化問題**，我們需要找到一個關門時間點，使得總罰款最小。關鍵觀察：
- **前綴罰款**：關門前的 'N' 字元數量（開門但無顧客）
- **後綴罰款**：關門後的 'Y' 字元數量（關門但有顧客）
- **總罰款** = 前綴罰款 + 後綴罰款

### 方法一：枚舉所有關門時間 + 動態調整

不需要預先計算所有 'Y' 的數量，而是以"第 0 小時關門"的代價為基準，動態調整相對代價：

1. **初始化**：假設第 0 小時關門，此時 `pre = 0`，`suf = 0`
2. **遍歷每個可能的關門時間** `i`（0 到 n）
3. **更新最小代價**：如果當前代價更小，更新結果
4. **調整代價**：
   - 如果 `customers[i] = 'N'`：延後關門會增加前綴代價（`pre++`）
   - 如果 `customers[i] = 'Y'`：延後關門會減少後綴代價（`suf--`）

### 方法二：一次遍歷最佳化（推薦）

將問題轉化為尋找**最小前綴和**的問題，只需要一次遍歷：

1. **核心思想**：以第 0 小時關門為基準，計算延後關門的代價變化
2. **代價計算**：
   - 遇到 'N'：延後關門增加代價 +1
   - 遇到 'Y'：延後關門減少代價 -1
3. **追蹤最小值**：記錄遍歷過程中的最小代價及對應位置

### 時間複雜度

- **方法一 (枉舉法)**：
  - 時間複雜度：`O(n)` - 需要遍歷所有可能的關門時間
  - 空間複雜度：`O(1)` - 只使用常數額外空間

- **方法二 (一次遍歷)**：
  - 時間複雜度：`O(n)` - 只需要遍歷一次字串
  - 空間複雜度：`O(1)` - 只使用常數額外空間

## 📊 兩種方法比較

| 比較項目 | 方法一：枚舉法 | 方法二：一次遍歷 |
|---------|-------------|----------------|
| **演算法思想** | 動態調整前綴後綴代價 | 轉化為最小前綴和問題 |
| **遍歷次數** | 一次遍歷 (n+1 個時間點) | 一次遍歷 (n 個字元) |
| **變數個數** | 4 個 (`pre`, `suf`, `minCost`, `res`) | 3 個 (`penalty`, `minPenalty`, `res`) |
| **程式碼簡潔度** | 較複雜，需要分別處理 N/Y | 更簡潔，統一處理 |
| **理解難度** | 直觀，容易理解 | 需要轉化思維，略抽象 |
| **執行效率** | 略慢 (多一次迴圈) | 更快 |
| **推薦指數** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

### 核心差異

**方法一**：直接模擬每個關門時間的代價計算
```csharp
// 枚舉每個時間點，動態調整代價
for(int i = 0; i <= n; i++) {
    if(minCost > suf + pre) { /* 更新結果 */ }
    // 根據 customers[i] 調整 pre 和 suf
}
```

**方法二**：將問題轉化為最小前綴和
```csharp
// 直接追蹤代價變化的最小值
for(int i = 0; i < customers.Length; i++) {
    penalty += customers[i] == 'N' ? 1 : -1;
    if(penalty < minPenalty) { /* 更新結果 */ }
}
```

## 🔍 演算法詳解

### 方法一：枚舉法詳解

以 `customers = "YYNY"` 為例：

| 關門時間 | 當前字元 | pre (前綴N) | suf (後綴Y) | 總代價 | 是否更新 |
|---------|---------|------------|------------|--------|---------|
| i=0     | -       | 0          | 0          | 0      | ✓ (res=0) |
| i=1     | Y       | 0          | -1         | -1     | ✓ (res=1) |
| i=2     | Y       | 0          | -2         | -2     | ✓ (res=2) |
| i=3     | N       | 1          | -2         | -1     | ✗       |
| i=4     | Y       | 1          | -3         | -2     | ✗       |

最小代價為 -2，對應的最早關門時間為第 2 小時。

### 方法二：一次遍歷詳解

同樣以 `customers = "YYNY"` 為例，將延後關門的代價變化視為前綴和：

| 當前位置 | 字元 | 代價變化 | 累積代價 | 最小代價 | 最佳時間 |
|---------|------|---------|---------|---------|---------|
| 初始     | -    | 0       | 0       | 0       | 0       |
| i=0     | Y    | -1      | -1      | -1      | 1       |
| i=1     | Y    | -1      | -2      | -2      | 2       |
| i=2     | N    | +1      | -1      | -2      | 2       |
| i=3     | Y    | -1      | -2      | -2      | 2       |

最小代價為 -2，對應的最早關門時間為第 2 小時。

### 程式碼實作

#### 方法一：枚舉法

```csharp
public int BestClosingTime(string customers)
{
    int n = customers.Length;
    int suf = 0;      // 後綴代價：關門後有顧客的罰分
    int pre = 0;      // 前綴代價：關門前無顧客的罰分
    int minCost = 0;  // 目前找到的最小代價
    int res = 0;      // 最佳關門時間

    // 枚舉所有可能的關門時間 i (0 ≤ i ≤ n)
    for(int i = 0; i <= n; i++)
    {
        // 如果目前代價比最小代價還小，更新最小代價和結果
        if(minCost > suf + pre)
        {
            minCost = suf + pre;
            res = i;
        }
        
        // 更新下一輪的代價計算
        if(i < n && customers[i] == 'N')
        {
            // 如果第 i 小時沒有顧客，延後關門會增加前綴代價
            pre++;
        }
        else if(i < n)
        {
            // 如果第 i 小時有顧客，延後關門會減少後綴代價
            suf--;
        }
    }
    return res;
}
```

#### 方法二：一次遍歷最佳化（推薦）

```csharp
public int BestClosingTime_OneTimes(string customers)
{
    int penalty = 0;      // 目前相對於第 0 小時關門的代價差異
    int minPenalty = 0;   // 遇到的最小代價差異
    int res = 0;          // 最佳關門時間
    
    // 遍歷每個小時，動態計算延後關門的代價變化
    for(int i = 0; i < customers.Length; i++)
    {
        // 更新代價：'N' 增加罰分，'Y' 減少罰分
        penalty += customers[i] == 'N' ? 1 : -1;
        
        // 如果發現更小的代價，更新最佳解
        if(penalty < minPenalty)
        {
            minPenalty = penalty;
            res = i + 1;  // 關門時間為下一小時（i+1）
        }
    }
    return res;
}
```

## 🚀 如何執行

1. **編譯專案**：
   ```bash
   dotnet build
   ```

2. **執行程式**：
   ```bash
   dotnet run
   ```

3. **執行結果**：程式會自動測試多個範例案例並顯示結果。

## 📊 測試案例

程式包含以下測試案例：

| 輸入      | 預期輸出 | 說明              |
|-----------|---------|------------------|
| "YYNY"    | 2       | 混合顧客模式      |
| "NNNNN"   | 0       | 全無顧客，立即關門 |
| "YYYY"    | 4       | 全有顧客，最晚關門 |
| "YN"      | 1       | 簡單兩小時案例    |

## 🎯 關鍵要點

> [!IMPORTANT]
> 1. **邊界條件**：關門時間可以是 0 到 n（包含 n），表示可以立即關門或營業到最後
> 2. **最早原則**：當有多個最小代價時，選擇最早的關門時間
> 3. **相對代價**：不需要計算絕對代價值，只需要比較相對大小

> [!TIP]
> 這個問題的核心是理解"延後關門"對兩種罰款的影響：
> - 遇到 'N' → 增加開門無顧客的罰款
> - 遇到 'Y' → 減少關門有顧客的罰款

## 🔗 相關題目

- [LeetCode 121 - 買賣股票的最佳時機](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [LeetCode 53 - 最大子序和](https://leetcode.com/problems/maximum-subarray/)
- [LeetCode 1014 - 最佳觀光組合](https://leetcode.com/problems/best-sightseeing-pair/)
