# LeetCode 1526 - 形成目標陣列的子陣列最少增加次數

> **LeetCode 1526. Minimum Number of Increments on Subarrays to Form a Target Array**

本專案提供 LeetCode 1526 題的 C# 解法，使用**差分陣列**技巧優雅地解決這個問題。

## 問題描述

給你一個整數陣列 `target`。你有一個與 `target` 大小相同的整數陣列 `initial`，所有元素最初都是零。

在一次操作中，你可以從 `initial` 中選擇任何子陣列，並將每個值增加一。

返回從 `initial` 形成 `target` 陣列所需的最少操作數。

測試案例生成使得答案適合 32 位整數。

### 範例

**範例 1:**

```text
輸入：target = [1,2,3,2,1]
輸出：3
解釋：
第一次操作將 [0,0,0,0,0] 變為 [1,1,1,1,1]
第二次操作將 [1,1,1,1,1] 變為 [1,2,2,2,1]
第三次操作將 [1,2,2,2,1] 變為 [1,2,3,2,1]
```

**範例 2:**

```text
輸入：target = [3,1,1,2]
輸出：4
解釋：
操作 1: [0,0,0,0] → [1,1,1,0]
操作 2: [1,1,1,0] → [1,1,1,1]
操作 3: [1,1,1,1] → [2,1,1,2]
操作 4: [2,1,1,2] → [3,1,1,2]
```

**範例 3:**

```text
輸入：target = [3,1,5,4,2]
輸出：7
```

### 限制條件

- `1 <= target.length <= 10^5`
- `1 <= target[i] <= 10^5`

## 解法說明

### 核心概念：差分陣列

#### 什麼是差分陣列？

對於長度為 n 的陣列 `a[0..n-1]`，其**差分陣列** `d[0..n-1]` 定義為：

```text
d[i] = {
    a[i],           當 i = 0
    a[i] - a[i-1],  當 i > 0
}
```

#### 範例說明

假設 `a = [1, 2, 3, 2, 1]`，則差分陣列為：

```text
d[0] = a[0] = 1
d[1] = a[1] - a[0] = 2 - 1 = 1
d[2] = a[2] - a[1] = 3 - 2 = 1
d[3] = a[3] - a[2] = 2 - 3 = -1
d[4] = a[4] - a[3] = 1 - 2 = -1

所以 d = [1, 1, 1, -1, -1]
```

#### 差分陣列的特性

1. **前綴和還原**：差分陣列的前綴和等於原陣列

   ```text
   a[i] = d[0] + d[1] + ... + d[i]
   ```

2. **區間操作轉點操作**：對原陣列的連續子陣列 `[L, R]` 進行操作，只會影響差分陣列的兩個位置：
   - `d[L]` 會變化
   - `d[R+1]` 會變化（如果存在）

### 解題思路

#### 1. 問題轉換

題目要求：從全零陣列經過若干次操作得到 `target` 陣列（每次操作將連續子陣列的元素 +1）

等價於：從 `target` 陣列經過若干次操作得到全零陣列（每次操作將連續子陣列的元素 -1）

#### 2. 操作對差分陣列的影響

當我們對子陣列 `[L, R]` 執行減 1 操作時：

- 若 `L = 0`：`d[0]` 減少 1
- 若 `L > 0`：`d[L]` 減少 1（因為 `a[L]` 減少了但 `a[L-1]` 沒變）
- 若 `R+1 < n`：`d[R+1]` 增加 1（因為 `a[R]` 減少了但 `a[R+1]` 沒變）
- 若 `R+1 = n`：無需操作（我們可以想像有個「黑洞」`d[n]` 吸收了這個 +1）

**關鍵觀察**：每次操作中，我們只能讓差分陣列中的一個元素減少 1。

#### 3. 推導最少操作數

**結論一**：差分陣列的任意前綴和 ≥ 0

證明：因為差分陣列的前綴和就是原陣列 `a[i]`，而 `target` 中所有元素都是正整數。

**結論二**：如果 `d[R+1] < 0`，則必存在 `0 ≤ L ≤ R` 使得 `d[L] > 0`

證明（反證法）：若對所有 `0 ≤ L ≤ R` 都有 `d[L] ≤ 0`，則前綴和 `Σd[k]` (k=0 to R+1) < 0，與結論一矛盾。

**最終答案**：

```text
最少操作數 = Σ max(d[i], 0) = d[0] + Σ max(0, d[i])  (i從1到n-1)
```

簡化後：

```text
ans = target[0] + Σ max(0, target[i] - target[i-1])  (i從1到n-1)
```

#### 4. 為什麼這個答案可行？

我們可以構造出一種方法：

1. **階段一**：找出所有 `d[R+1] < 0` 的位置，配對一個 `d[L] > 0` 的位置（L ≤ R），執行操作將兩者分別 -1 和 +1，直到沒有負數。

2. **階段二**：剩下的正數元素，每個都配對「黑洞」`d[n]`，執行操作將其變為 0。

總操作數恰好等於所有正數的和。

### 演算法步驟

1. 初始化結果為 `target[0]`（差分陣列的第一個元素）
2. 遍歷 `target[1]` 到 `target[n-1]`
3. 對於每個位置 i，計算差分值 `target[i] - target[i-1]`
4. 如果差分值為正（表示上升），累加到結果中
5. 返回結果

### 複雜度分析

- **時間複雜度**：O(n)，其中 n 是陣列長度，只需遍歷一次
- **空間複雜度**：O(1)，只使用常數額外空間，無需實際建構差分陣列

## 程式碼範例

```csharp
public int MinNumberOperations(int[] target)
{
    int n = target.Length;
    
    // 初始化結果為第一個元素（差分陣列的第一個值）
    int res = target[0];
    
    // 遍歷陣列，計算差分陣列中的正數和
    for (int i = 1; i < n; i++)
    {
        // 計算當前位置的差分值 d[i] = target[i] - target[i-1]
        // 只累加正數部分（即上升的部分）
        res += Math.Max(0, target[i] - target[i - 1]);
    }
    
    return res;
}
```

## 執行結果

```bash
dotnet run
```

輸出範例：

```
測試案例 1: target = [1, 2, 3, 2, 1]
輸出: 3
說明: 第一次操作將 [0,0,0,0,0] 變為 [1,1,1,1,1]，第二次操作將 [1,1,1,1,1] 變為 [1,2,2,2,1]，第三次操作將 [1,2,2,2,1] 變為 [1,2,3,2,1]

測試案例 2: target = [3, 1, 1, 2]
輸出: 4
說明: 操作 1 將 [0,0,0,0] 變為 [1,1,1,0]，操作 2 將 [1,1,1,0] 變為 [1,1,1,1]，操作 3 將 [1,1,1,1] 變為 [2,1,1,2]，操作 4 將 [2,1,1,2] 變為 [3,1,1,2]

測試案例 3: target = [3, 1, 5, 4, 2]
輸出: 7
說明: 最少需要 7 次操作

測試案例 4: target = [1, 1, 1, 1]
輸出: 1
說明: 只需一次操作將整個陣列從 [0,0,0,0] 變為 [1,1,1,1]
```

## 詳細推導範例

### 範例：target = [1, 2, 3, 2, 1]

#### 步驟 1：建構差分陣列

```text
d[0] = 1
d[1] = 2 - 1 = 1
d[2] = 3 - 2 = 1
d[3] = 2 - 3 = -1
d[4] = 1 - 2 = -1

差分陣列 d = [1, 1, 1, -1, -1]
```

#### 步驟 2：計算正數和

```text
正數元素：d[0] = 1, d[1] = 1, d[2] = 1
正數和 = 1 + 1 + 1 = 3
```

#### 步驟 3：驗證可行性

使用差分陣列操作還原的過程：

1. **操作 1**: 選擇 L=0, R=4（整個陣列）
   - `d[0] -= 1` → `d = [0, 1, 1, -1, -1]`
   - 對應 target 變化：`[1,2,3,2,1] → [0,1,2,1,0]`

2. **操作 2**: 選擇 L=1, R=3
   - `d[1] -= 1` → `d = [0, 0, 1, -1, -1]`
   - 對應 target 變化：`[0,1,2,1,0] → [0,0,1,0,0]`

3. **操作 3**: 選擇 L=2, R=2
   - `d[2] -= 1` → `d = [0, 0, 0, -1, -1]`
   - `d[3] += 1` → `d = [0, 0, 0, 0, -1]`
   - 繼續配對黑洞 → `d = [0, 0, 0, 0, 0]`
   - 對應 target 變化：`[0,0,1,0,0] → [0,0,0,0,0]`

總共 3 次操作，與我們的計算一致！

## 專案結構

```text
leetcode_1526/
├── leetcode_1526/
│   ├── Program.cs          # 主程式碼和測試案例
│   └── leetcode_1526.csproj
├── .vscode/
│   ├── launch.json         # 偵錯設定
│   └── tasks.json          # 建置工作
├── .editorconfig           # 程式碼格式設定
└── README.md               # 本文件
```

## 開發環境

- **.NET**: 8.0 或更高版本
- **C#**: 13
- **IDE**: Visual Studio Code 或 Visual Studio

## 偵錯與執行

### 建置專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run --project leetcode_1526/leetcode_1526.csproj
```

### 使用 VS Code 偵錯

按 `F5` 或在偵錯面板中點擊「Launch Program」即可開始偵錯。

## 相關資源

- [LeetCode 1526 題目連結](https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/)
- [LeetCode 1526 中文題目](https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/)
- [差分陣列詳解](https://oi-wiki.org/basic/prefix-sum/#差分)

## 關鍵技巧總結

1. **差分陣列**是解決區間操作問題的利器
2. **問題轉換**：正向思考 → 反向思考，往往能簡化問題
3. **貪心策略**：只需關注「上升」的部分，下降部分可以被之前的操作覆蓋
4. **數學證明**：透過前綴和性質證明解的正確性和最優性

---

**難度**: 困難 (Hard)  
**標籤**: 陣列、貪心、差分陣列  
**每日挑戰**: 2025-10-30
