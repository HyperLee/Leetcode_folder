# 224. Basic Calculator（基本計算器）

本專案在 `leetcode_224` 中提供了一個簡單的 C# 範例，實作 LeetCode 題目 224（Basic Calculator）。此實作支援整數、加減號（+、-）、左右括號與空格，並正確處理負數與多位數情形。

## 專案結構

- `leetcode_224.sln` — 解題專案解決方案
- `leetcode_224/Program.cs` — 主程式與解法實作（`Calculate` 與 `Calc`）

> [!NOTE]
> 這個專案為單一檔案示範程式，使用 .NET（C# 9+/9.0+ 或更新）環境即可編譯與執行。

## 如何執行

在 Windows PowerShell 中（或任何支援 dotnet CLI 的終端機）：

```powershell
# 先在專案根目錄下建構
dotnet build ./leetcode_224/leetcode_224.csproj -c Debug

# 執行（或直接使用 dotnet run）
dotnet run --project ./leetcode_224/leetcode_224.csproj
```

程式在 `Program.cs` 中包含數個測試範例，執行會在主控台輸出每個範例的輸入與結果。

## 題目與目標

給定一個字串表示的算式，只包含非負整數、加減、括號與空格，實作一個基本的計算器，回傳計算結果。需要處理：

- 多位數（例如 `123`）
- 空格
- 括號（含巢狀）
- 負數（例如 `-2` 或 `(-1)`）

本實作的時間複雜度為 O(n)，空間複雜度也為 O(n)，其中 n 為輸入字串長度。

## 解法概述

採用雙堆疊（nums 與 ops）進行單次掃描的算式解析：

- `nums`（堆疊）：用來儲存數字（int）
- `ops`（堆疊）：用來儲存運算符與括號（char）

處理流程（高階）：

1. 預處理：把 `s` 中的空格移除，並先在 `nums` 放入 `0`（方便處理一開始或括號後的 unary minus）。
2. 單趟掃描字元：
   - 遇到數字就讀出整個多位數並 push 到 `nums`。
   - 遇到左括號 `(` 就 push 到 `ops`。
   - 遇到右括號 `)` 就不斷從 `ops` 取運算並呼叫 `Calc(nums, ops)`，直到彈出對應的 `(`。
   - 遇到運算符 `+` 或 `-`：先處理 `ops` 中現有（且非 `(`）的運算，確保左結合性，再把當前運算符 push 到 `ops`。如果當前運算符前面是 `(`、`+` 或 `-`，代表這裡可能是 unary（如 `(-1)` 或 `-2`），先在 `nums` push 一個 `0`，把 unary 變為二元運算（例如 `0 - 1`）。
3. 掃描結束後，若 `ops` 尚有運算符，繼續呼叫 `Calc` 處理至空為止，最終 `nums.Peek()` 即為結果。

## `Calc`（計算子函式）詳解

`Calc` 的責任很單一：從兩個堆疊中彈出一個運算子與兩個操作數，做加或減，然後把結果壓回 `nums`。實作重點：

- 先檢查是否有足夠的操作數（至少兩個）與運算符（至少一個）。
- 由於堆疊是先進後出（LIFO），因此 pop 出來的第一個數字是運算符右邊的數（b），第二個 pop 才是左邊的數（a）。
- 取出運算符後，用三元或 switch 判斷是 `+` 還是 `-`，並把 `a + b` 或 `a - b` push 回 `nums`。

範例（簡化）：

- 如果 `nums` 為底→頂： [1, 2]（1 在底部，2 在頂部），`ops` 的頂端是 `+`：呼叫 `Calc` 後會 pop 出 b=2, a=1, op='+', 並將 3 push 回 `nums`。

> [!TIP]
> `Calc` 的實作目前會把「非 '+' 的運算子」視為 `-`，工程上建議明確處理已知運算子並對未知運算子丟出例外，以利偵錯與未來擴充（例如支援 `*`、`/`）。

## 詳細執行示範（解析範例："(1+(4+5+2)-3)+(6+8)")

下面透過每個重要步驟展示 `nums` 與 `ops` 的狀態變化（堆疊以左為底，右為頂）：

- 初始：

  nums: [0]
  ops:  []

- 讀到 `(` → push `(`：

  nums: [0]
  ops:  ['(']

- 讀到 `1` → push 數字 1：

  nums: [0, 1]
  ops:  ['(']

- 讀到 `+` → ops 頂端為 `(`，直接 push `+`：

  nums: [0, 1]
  ops:  ['(', '+']

- 讀到 `(` → push `(`：

  nums: [0, 1]
  ops:  ['(', '+', '(']

- 讀到 `4`、`+`、`5`、`+`、`2`，在內部括號結束時會用 `Calc` 逐步計算 `4+5+2` → 11：

  在恰當時機，nums 會變成 [0, 1, 11]，ops 會回到 ['(', '+']

- 之後讀到 `- 3`，依序計算 `1 + 11 - 3` → 結果 9：

  nums: [0, 9]
  ops:  []

- 再處理 `+ (6+8)`，最終 push 出 14 並加到 9 → 23：

  最終 nums: [0, 23]
  回傳 nums.Peek() -> 23

這個示範說明了為何需要兩個堆疊：`ops` 用來暫存運算符與括號範圍，`nums` 用來暫存中間數值，並在確定優先順序或遇到右括號時才做真正的計算。

## 時間與空間複雜度

- 時間複雜度：O(n)。每個字元最多被掃描與處理常數次（push/pop/計算）。
- 空間複雜度：O(n)。最壞情況下所有數字與運算符會被暫存在堆疊中。

## 邊界情況與注意事項

- 輸入包含非數字或不合法字元時，目前程式沒有額外的驗證，建議在生產環境加入輸入驗證並回報錯誤。
- `Calc` 若遇到未知運算子應改為丟出例外（目前實作將非 `+` 視為 `-`，可能隱藏錯誤）。
- 若要支援乘除或更複雜的運算優先權，需在 `ops` 處理時納入運算優先權比較，或改用中序轉後序（Shunting-yard）再計算。

## 可改進方向

1. 明確的錯誤處理：當 `ops` 含未知字元時拋出 `InvalidOperationException`。
2. 支援乘除與更完整的運算子集合（加上優先權比較）。
3. 將解析與計算拆成更小的函式，並為主要邏輯新增單元測試（xUnit / NUnit）。

## 參考

- LeetCode 題目：224. Basic Calculator
- 程式內註解引用的中文解析文章（程式中保留原始參考連結）

---

如果你想要我把 `Calc` 改為更嚴謹的 switch 實作、或把程式拆成可測試的函式並加入單元測試，我可以幫你直接修改並執行測試。歡迎告訴我你想要的下一步！
