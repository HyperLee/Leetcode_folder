# Leetcode 3440. 重新安排會議得到最多空餘時間 II

## 題目簡介

給定一個整數 `eventTime` 表示活動總時長，以及兩個長度為 n 的整數陣列 `startTime` 和 `endTime`，分別表示 n 個不重疊會議的開始和結束時間。所有會議發生在 t = 0 到 t = eventTime 之間。你可以將最多一個會議的開始時間重新安排（保持其持續時間不變），且會議之間不能重疊，目標是最大化活動期間內最長的連續空閒時間。

## 專案結構

- `Program.cs`：主程式與解題邏輯，包含測試資料與詳細註解。
- `.editorconfig`：C# 程式碼風格設定。
- `.gitignore`：Git 忽略規則。
- 其他 VSCode 與 .NET 專案相關檔案。

## 解法說明

### 1. 問題建模

- 將每個會議視為一張「桌子」，空閒時間視為「空位」。
- 目標是將一張桌子（會議）移動到另一個空位，使最大連續空閒時間最大化。

### 2. 空位的定義

- 最左側空位：從 0 到第一個會議開始。
- 最右側空位：從最後一個會議結束到 eventTime。
- 中間空位：兩個相鄰會議之間。

### 3. 為什麼不能移動到相鄰空位？

如果只把會議移動到自己相鄰的空位（例如左邊或右邊的空位），那麼移動後只是把原本的兩個小空位合併成一個，這個新空位的長度最多就是「原本左右空位長度的總和」，不會比這兩個空位的總和更大。因此，這種移動方式無法創造出比原本更大的空閒時間。

只有把會議移動到「非相鄰」的空位，才能讓原本會議位置的左右空位合併成一個更大的空位，這樣才有機會產生新的最大空閒時間。

#### 範例

假設有三個會議：
- 會議1：[2, 4]
- 會議2：[6, 10]
- 會議3：[12, 15]
- 活動總時長：20

空位分布：
- 空位0：0~2（長度2）
- 空位1：4~6（長度2）
- 空位2：10~12（長度2）
- 空位3：15~20（長度5）

如果你把會議2移動到空位1（4~6，與自己相鄰），那麼新的最大空閒時間就是空位1+空位2=4，並不會超過原本的最大空位（空位3，長度5）。

但如果你把會議2移動到空位3（15~20，非相鄰），那麼原本會議2的位置（6~10）和它左右的空位（4~6、10~12）會合併成一個大空位（4~12，長度8），這樣最大空閒時間就變成8，明顯比原本的最大空位還大。

### 4. 為什麼要取出前三大空閒時間的 idx？

- 只要知道前三大空位的位置（index），就能針對每個會議判斷是否能移動到這些空位，且不會與自己相鄰（避免重疊）。
- 理論上，最多只有兩個空位會與同一個會議相鄰，因此前三大空位中一定有一個是非相鄰的。
- 這樣可以在 O(n) 時間內完成，效率高。
- 只記錄 index，不需要額外排序或複製空位長度陣列，節省記憶體。

### 5. 演算法步驟

1. 計算所有 n+1 個空位的長度，找出前三大的空位（下標分別為 a, b, c）。
2. 枚舉每一張桌子（會議），嘗試將其移動到不與其相鄰的最大空位（a、b、c之一）。
3. 若能移動（空位長度足夠），新的空位長度為桌子長度加上左右兩側空位長度；否則只能合併左右空位。
4. 最終取所有情況下的最大空閒時間。

### 6. 關鍵程式碼片段

```csharp
// 找出前三大空位的位置 idx
for (int i = 1; i <= n; i++)
{
    int size = Get(i);
    // 條件設計說明：
    // 1. 若目前空位長度大於最大空位（a），則將 a、b、c 依序往下移，a 更新為 i。
    //    這樣能確保 a 永遠是目前最大的空位下標。
    // 2. 若 b 尚未指派（b < 0），或目前空位長度大於次大空位（b），則將 b、c 往下移，b 更新為 i。
    //    這樣能確保 b 永遠是目前次大的空位下標。
    // 3. 若 c 尚未指派（c < 0），或目前空位長度大於第三大空位（c），則 c 更新為 i。
    //    這樣能確保 c 永遠是目前第三大的空位下標。
    if (size > Get(a))
    {
        c = b;
        b = a;
        a = i;
    }
    else if (b < 0 || size > Get(b))
    {
        c = b;
        b = i;
    }
    else if (c < 0 || size > Get(c))
    {
        c = i;
    }
}
```

### 6.1 前三大空位 idx 條件設計說明

```csharp
for (int i = 1; i <= n; i++)
{
    int size = Get(i);
    // 條件設計說明：
    // 1. 若目前空位長度大於最大空位（a），則將 a、b、c 依序往下移，a 更新為 i。
    //    這樣能確保 a 永遠是目前最大的空位下標。
    // 2. 若 b 尚未指派（b < 0），或目前空位長度大於次大空位（b），則將 b、c 往下移，b 更新為 i。
    //    這樣能確保 b 永遠是目前次大的空位下標。
    // 3. 若 c 尚未指派（c < 0），或目前空位長度大於第三大空位（c），則 c 更新為 i。
    //    這樣能確保 c 永遠是目前第三大的空位下標。
    if (size > Get(a))
    {
        c = b;
        b = a;
        a = i;
    }
    else if (b < 0 || size > Get(b))
    {
        c = b;
        b = i;
    }
    else if (c < 0 || size > Get(c))
    {
        c = i;
    }
}
```

### 6.2 移動會議時的條件設計說明

```csharp
for (int i = 0; i < n; i++)
{
    int size = endTime[i] - startTime[i]; // 桌子長度（會議時長）
    // 條件設計說明：
    // 1. (i != a && i + 1 != a && size <= Get(a))
    //    代表目前會議的左右兩側都不是最大空位 a，且最大空位長度足夠放下這個會議，
    //    可以將會議移動到最大空位，並合併原本位置的左右空位。
    // 2. (i != b && i + 1 != b && size <= Get(b))
    //    同理，檢查能否移動到次大空位 b。
    // 3. size <= Get(c)
    //    檢查能否移動到第三大空位 c（此處不判斷相鄰，因為理論上最多只有兩個空位與會議相鄰，
    //    前三大空位中必有一個非相鄰）。
    // 只要有一個條件成立，就代表可以移動到非相鄰的大空位，
    // 新空位長度 = 桌子長度 + 原本左右空位長度。
    // 否則只能合併原本左右空位。
    if ((i != a && i + 1 != a && size <= Get(a)) ||
        (i != b && i + 1 != b && size <= Get(b)) ||
        size <= Get(c))
    {
        res = Math.Max(res, Get(i) + size + Get(i + 1));
    }
    else
    {
        res = Math.Max(res, Get(i) + Get(i + 1));
    }
}
```

### 7. 時間複雜度

- 單次遍歷即可找出前三大空位，主迴圈也是 O(n)，總體時間複雜度為 O(n)。

---

## 參考連結
- [Leetcode 題目連結](https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-ii/)
- [解題討論](https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-ii/solutions/3061629/wei-hu-qian-san-da-de-kong-wei-mei-ju-fe-xm2f/?envType=daily-question&envId=2025-07-10)

---

如需更詳細的程式註解與範例，請參考 `Program.cs` 內的說明。
