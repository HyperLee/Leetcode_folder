# 解法二：改良版拓撲排序 + 動態規劃

這段程式碼展示了一個改良版的拓撲排序演算法實作，與第一個版本相比在幾個關鍵方面進行了最佳化。

## 🔧 資料結構的改良

程式碼使用 `List<List<int>>` 來建立鄰接表，取代了原本的 `int[][]`。這種做法避免了前一版本中每次添加邊時都要建立新陣列的效能問題。

**優勢**：

- 使用 `List` 的 `Add` 方法可以更有效率地動態添加節點
- 當內部陣列容量不足時，系統會自動擴展陣列大小
- 比重複建立新陣列並複製所有元素的方式效率更高

## 🎯 動態規劃初始化策略的調整

在這個版本中，動態規劃陣列 `dp` 的初始化方式發生了重要變化：

- **原版本**：在初始階段就設定每個節點自身的顏色值
- **改良版**：在拓撲排序過程中動態更新

```csharp
// 當處理一個節點時
dp[u][colors[u] - 'a']++;
```

這確保了只有在該節點被實際處理時才會計算其顏色貢獻。

## ⚡ 狀態轉移邏輯的簡化

改良版的狀態轉移邏輯更加簡潔：

```csharp
// 簡潔的狀態轉移
dp[v][c] = Math.Max(dp[v][c], dp[u][c]);
```

**原因**：

- 當前節點的顏色值已經在處理該節點時被正確設定
- 不需要再進行條件判斷
- 程式碼更容易理解且執行效率更高

## 🔍 環檢測機制的一致性

程式碼保持了與原版本相同的環檢測邏輯：

```csharp
// 使用處理節點數來檢測環
if (processedNodes != n) return -1;
```

**檢測原理**：

- 使用 `processedNodes` 變數記錄已處理的節點數
- 如果最終處理的節點數不等於總節點數，說明圖中存在環
- 利用拓撲排序的特性：有環時某些節點的入度永遠不會變為 0

## 📊 結果計算的最佳化

最後的結果計算階段使用 LINQ 進行最佳化：

```csharp
// 使用 LINQ 的 Max() 函式
return graph.Select((_, i) => dp[i].Max()).Max();
```

**優勢**：

- LINQ 的 `Max()` 函式內部使用最佳化的演算法
- 通常比手動遍歷更有效率
- 程式碼更簡潔易讀

## 📈 效能比較

| 方面     | 解法一              | 解法二 (改良版)              |
| ------ | ---------------- | ---------------------- |
| 鄰接表建立  | `int[][]` 重複建立陣列 | `List<List<int>>` 動態擴展 |
| DP 初始化 | 預先設定所有節點         | 動態處理時設定                |
| 狀態轉移   | 需要條件判斷           | 簡潔的 `Math.Max`         |
| 結果計算   | 手動遍歷             | LINQ 最佳化               |

## 💡 總結

整體而言，這個改良版本在保持演算法正確性的同時，提供了更好的執行效能和程式碼可讀性。主要改進包括：

1. ✅ 更高效的資料結構使用
2. ✅ 最佳化的初始化策略
3. ✅ 簡化的狀態轉移邏輯
4. ✅ 利用 LINQ 提升效能