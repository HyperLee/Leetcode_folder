# 解法三：深度優先搜尋 + 記憶化 (DFS + Memoization)

這段程式碼實作了一個使用深度優先搜尋 (DFS) 結合記憶化技術的解法，用來解決有向圖中最大顏色值問題。這種方法相較於拓撲排序具有更強大的環檢測能力，能夠有效處理包括自環在內的各種環結構。

## 🏗️ 圖結構建構與預處理

演算法首先建立鄰接表來表示有向圖，使用 `List<int>[]` 陣列來儲存每個節點的鄰居節點。

```csharp
// 建立鄰接表
List<int>[] g = new List<int>[n];
for (int i = 0; i < n; i++)
{
    g[i] = new List<int>();
}

// 建構圖並檢測自環
foreach (int[] e in edges)
{
    int x = e[0];
    int y = e[1];
    if (x == y) // 自環檢測
    {
        return -1;
    }
    g[x].Add(y);
}
```

**關鍵特點**：

- 在建構圖的過程中，程式碼特別檢查自環的存在 (即 `x == y` 的情況)
- 如果發現任何自環則直接回傳 -1
- 這種預處理步驟能夠快速識別最明顯的環結構，避免不必要的深度搜尋

## 🧠 記憶化機制的設計

記憶化陣列 `memo` 是這個演算法的核心組件，它使用了巧妙的**三態設計**：

| 狀態        | 意義       | 用途    |
| --------- | -------- | ----- |
| `null`    | 該節點尚未被計算 | 初始狀態  |
| `空陣列`     | 該節點正在計算中 | 環檢測標記 |
| `包含資料的陣列` | 該節點的計算結果 | 記憶化結果 |

```csharp
// memo[i] 存儲從節點 i 開始的 DFS 結果
// null 表示未計算，空陣列表示正在計算中(用於環檢測)
int[][] memo = new int[n][];
```

這種設計讓演算法能夠在遞迴過程中即時檢測環的存在。

## 🔄 DFS 遞迴邏輯

DFS 函式採用**自頂向下的遞迴方式**，對每個節點計算從該節點開始的所有路徑中各種顏色的最大出現次數。

```csharp
private int[] Dfs(int x, List<int>[] g, char[] colors, int[][] memo)
{
    if (memo[x] != null) // 節點 x 已經計算過或正在計算中
    {
        return memo[x]; // 如果是空陣列，表示檢測到環
    }

    memo[x] = new int[] { }; // 標記為正在計算中，用於環檢測
    int[] res = new int[26]; // 存儲各顏色的最大數量

    // 遍歷當前節點的所有鄰居...
}
```

**處理流程**：

1. 當函式開始處理一個節點時，會先將其標記為「計算中」狀態
2. 然後遞迴處理所有鄰居節點
3. 如果在遞迴過程中遇到已經標記為「計算中」的節點，表示發現了環
4. 演算法會立即回傳空陣列

## ⚡ 狀態轉移與結果聚合

對於每個節點，演算法會收集所有鄰居節點的計算結果，並使用 `Math.Max` 函式來更新各種顏色的最大值。

```csharp
// 遍歷當前節點的所有鄰居
foreach (int y in g[x])
{
    int[] cy = Dfs(y, g, colors, memo); // 遞歸計算鄰居節點
    if (cy.Length == 0) // 鄰居節點檢測到環
    {
        return cy; // 返回空陣列，表示有環
    }
    // 更新各顏色的最大值
    for (int i = 0; i < 26; i++)
    {
        res[i] = Math.Max(res[i], cy[i]);
    }
}

// 將當前節點的顏色數量 +1
res[colors[x] - 'a']++;
return memo[x] = res; // 記憶化存儲結果
```

**核心概念**：

- 這個過程本質上是**動態規劃的狀態轉移**
- 確保每個節點都記錄了從該點出發能夠達到的各種顏色的最大數量
- 最後，演算法會將當前節點自身的顏色貢獻加入結果中，完成該節點的計算

## 🎯 全域最佳解的計算

主函式會對每個節點執行 DFS，並從返回的結果中提取該節點顏色對應的最大值。

```csharp
// 對每個節點執行 DFS
for (int x = 0; x < n; x++)
{
    int[] res = Dfs(x, g, cs, memo);
    if (res.Length == 0) // 檢測到環
    {
        return -1;
    }
    // 更新以當前節點顏色結尾的路徑最大值
    ans = Math.Max(ans, res[cs[x] - 'a']);
}
```

**演算法保證**：

- ✅ 通過比較所有節點的結果，演算法能夠找到整個圖中任意路徑上相同顏色節點的最大數量
- ✅ 這種方法確保不會遺漏任何可能的最佳路徑
- ✅ 同時透過記憶化避免重複計算，達到  **O(V + E)**   的時間複雜度

## 📊 演算法複雜度分析

| 複雜度類型     | 解法三 (DFS + Memoization) |
| --------- | ----------------------- |
| **時間複雜度** | O(V + E)                |
| **空間複雜度** | O(V)                    |
| **環檢測能力** | 強 (包括自環)                |
| **記憶體使用** | 中等 (需要遞迴棧)              |

## 💡 優勢與特點

1. **🔍 強大的環檢測**：能夠檢測包括自環在內的各種環結構
2. **🧠 記憶化最佳化**：避免重複計算，提升效能
3. **🎯 直觀的遞迴邏輯**：程式碼結構清晰，易於理解
4. **⚡ 高效的狀態管理**：三態記憶化設計巧妙且高效

## 🔗 與其他解法的比較

相較於拓撲排序方法，DFS + 記憶化解法：

- ✅ 具有更強的環檢測能力
- ✅ 能夠處理複雜的環結構
- ✅ 記憶化機制提供了良好的效能保證
- ⚠️ 需要額外的遞迴棧空間
