# LeetCode 1857: 有向圖中最大顏色值

## 題目描述

給定一個有 n 個顏色節點和 m 條邊的有向圖，節點編號為 0 到 n-1。

- `colors` 是一個字串，`colors[i]` 代表第 i 個節點的顏色 (小寫英文字母)
- `edges` 是一個二維陣列，`edges[j] = [aj, bj]` 表示存在一條從 aj 指向 bj 的有向邊
- 合法路徑為 x1 -> x2 -> ... -> xk，且對於每個 1 <= i < k，xi 到 xi+1 有有向邊
- 路徑的顏色值為該路徑上出現次數最多的顏色的節點數

**目標**： 請回傳所有合法路徑中的最大顏色值；如果圖中存在環，則回傳 -1。

## 解法分析

本專案提供三種不同的解法，都能正確解決問題，但各有特點：

### 解法 1：拓撲排序 + 動態規劃

```csharp
public int LargestPathValue(string colors, int[][] edges)
```

**核心思路**：

- 使用拓撲排序遍歷有向圖
- 同時用動態規劃記錄到達每個節點時各種顏色的最大值
- 透過檢查已處理節點數來檢測環

**實作細節**：

- 建立鄰接表和入度陣列
- 將入度為 0 的節點加入佇列
- 逐一處理節點，更新鄰居的 DP 值
- 檢測處理節點數是否等於總節點數

### 解法 2：拓撲排序 + 動態規劃 (改良版)

```csharp
public int LargestPathValue2(string colors, int[][] edges)
```

**核心思路**：

- 與解法 1 類似，但使用不同的資料結構和處理順序
- 更嚴格的環檢測機制

**實作細節**：

- 使用 `List<List<int>>` 建立鄰接表
- 先增加顏色計數，再傳播到鄰居
- 明確的環檢測邏輯



### 解法 3：深度優先搜尋 + 記憶化

```csharp
public int LargestPathValue3(string colors, int[][] edges)
```

**核心思路**：

- 使用 DFS 遍歷每個節點
- 記憶化存儲中間結果，避免重複計算
- 三色標記法檢測環

**實作細節**：

- 自環預檢測
- 使用空陣列標記正在計算的節點
- 遞歸計算並記憶化結果

## 三種解法比較

| 特性        | 解法 1 (拓撲排序)     | 解法 2 (拓撲排序改良)    | 解法 3 (DFS + 記憶化) |
| --------- | --------------- | ---------------- | ---------------- |
| **時間複雜度** | O(V + E)        | O(V + E)         | O(V + E)         |
| **空間複雜度** | O(V)            | O(V)             | O(V)             |
| **圖表示**   | int[][] (陣列) | List<List<int>> | List<int>[]     |
| **環檢測**   | 節點計數檢測          | 節點計數檢測           | 三色標記 + 自環預檢      |
| **DP 更新** | 處理時更新           | 先計數再傳播           | 遞歸回溯時更新          |

### 優缺點分析

#### 解法 1 優缺點

**優點**：

- 經典的拓撲排序實作
- 程式碼結構清晰
- 記憶體使用較為緊湊

**缺點**：

- 需要額外修正環檢測邏輯
- 使用 `Append().ToArray()` 效率較低

#### 解法 2 優缺點

**優點**：

- 更靈活的資料結構
- 清晰的環檢測邏輯
- 處理順序更直觀

**缺點**：

- List 的記憶體開銷略大
- 程式碼稍長

#### 解法 3 優缺點

**優點**：

- 自然的遞歸結構
- 優雅的環檢測機制
- 記憶化避免重複計算
- 能直接檢測自環

**缺點**：

- 遞歸深度可能較大
- 對初學者較難理解

## 效能分析

### 時間複雜度

所有三種解法的時間複雜度都是  **O(V + E)**：

- V：節點數量
- E：邊的數量
- 每個節點和邊都只被訪問一次

### 空間複雜度

所有解法的空間複雜度都是  **O(V)**：

- 圖的存儲：O (V + E)
- DP 陣列：O (V × 26) = O (V)
- 輔助資料結構：O (V)

### 實際效能差異

1. **解法 1**：使用陣列，記憶體連續性好，但 `Append()` 操作較慢
2. **解法 2**：List 動態擴容，插入效率高，但記憶體分散
3. **解法 3**：遞歸呼叫，有函式呼叫開銷，但邏輯最清晰

## 測試資料

```csharp
// 測試資料 1: 正常情況
colors = "abaca", edges = [[0,1],[0,2],[2,3],[3,4]]
// 預期結果: 3

// 測試資料 2: 有環情況
colors = "a", edges = [[0,0]]
// 預期結果: -1

// 測試資料 3: 無邊情況  
colors = "abcde", edges = []
// 預期結果: 1
```

## 執行結果

```
=== 測試資料 1 ===
解法1: 3
解法2: 3
解法3: 3

=== 測試資料 2 (有環) ===
解法1: -1
解法2: -1
解法3: -1

=== 測試資料 3 ===
解法1: 1
解法2: 1
解法3: 1
```

## 建議使用場景

- **解法 1**：適合對記憶體使用有嚴格要求的場景
- **解法 2**：✅ **推薦使用** - 適合一般應用，程式碼清晰，易於維護
- **解法 3**：適合需要深入理解演算法原理的場景，或需要處理複雜環檢測的情況

## 演算法核心概念

### 拓撲排序 (Topological Sort)

- **定義**：對有向無環圖的節點進行線性排序，使得每條邊 (u,v) 中，u 都在 v 之前
- **應用**：檢測環、依賴關係排序、任務調度
- **實作方式**：Kahn 演算法 (使用入度) 或 DFS 後序遍歷

### 動態規劃在圖上的應用

- **狀態定義**：dp[i][c] = 到達節點 i 時顏色 c 的最大數量
- **狀態轉移** ：dp[v][c] = max(dp[v][c], dp[u][c] + (colors[v] == c ? 1 : 0))
- **最佳子結構**：問題的最優解包含子問題的最優解

### 環檢測方法比較

1. **拓撲排序計數法**：處理節點數 ≠ 總節點數 → 有環
2. **三色標記法**：白色 (未訪問)、灰色 (正在處理)、黑色 (已完成)
3. **自環檢測**：edge[0] == edge[1] → 立即判斷有環

## 學習重點

1. **拓撲排序**：理解有向無環圖的遍歷方式
2. **動態規劃**：在圖上進行狀態轉移
3. **環檢測**：多種環檢測方法的實作
4. **記憶化搜尋**：避免重複計算的技巧

## 執行方式

```bash
cd leetcode_1857
dotnet run
```

## 參考連結

- [LeetCode 1857 英文版](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/)
- [LeetCode 1857 中文版](https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/)
