# leetcode_2200 解題方法總結與評比

## 題目簡介

給定一個 0 索引的整數陣列 `nums` 和兩個整數 `key` 及 `k`。
若存在至少一個索引 `j` 滿足 `|i - j| <= k` 且 `nums[j] == key`，
則索引 `i` 為 K 近鄰下標。請回傳所有 K 近鄰下標，並以遞增順序排序。

---

## 三種解法總覽

### 方法一：一遍遍歷 + HashSet 去重排序

- **核心思路**：
  1. 遍歷 `nums`，找出所有 `nums[j]=key` 的下標 j。
  2. 對每個 j，計算區間 `[max(0, j-k), min(n-1, j+k)]`，將區間內所有下標加入 HashSet。
  3. 最後將 HashSet 轉 List 並排序。
- **程式碼可讀性**：高，直觀易懂。
- **可維護性**：高，結構簡單。
- **時間複雜度**：O(nk)（最壞情況每個 key 都覆蓋 k 個範圍，且需排序）。
- **空間複雜度**：O(n)（HashSet 儲存所有下標）。
- **優點**：實作簡單，容易理解。
- **缺點**：有重複加入、需額外排序，效率非最優。

---

### 方法二：枚舉每個下標 i

- **核心思路**：
  1. 外層 for 迴圈依序檢查每個下標 i。
  2. 內層 for 迴圈檢查是否存在某個 j 滿足 `nums[j]=key` 且 `|i-j|<=k`。
  3. 若條件成立，將 i 加入結果 List，並 break。
  4. 因為 i 遞增，結果天然排序好。
- **程式碼可讀性**：高，邏輯清楚。
- **可維護性**：高，容易追蹤每個步驟。
- **時間複雜度**：O(n^2)（雙層 for 迴圈）。
- **空間複雜度**：O(n)（結果 List）。
- **優點**：結果天然排序，無需額外排序，無重複。
- **缺點**：效率最低，適合數據量小時使用。

---

### 方法三：雙指針優化法

- **核心思路**：
  1. 用 last 記錄目前視窗內最右側的 key 下標，初始設為 -k-1。
  2. 先從 0 到 k-1 檢查是否有 key，若有則更新 last。
  3. 依序遍歷每個下標 i：
     - 若 i+k 未超出陣列且 nums[i+k]=key，則 last 更新為 i+k。
     - 若 last >= i-k，代表 i 的視窗內有 key，將 i 加入結果。
  4. 回傳所有 K 近鄰下標（遞增排序）。
- **程式碼可讀性**：中等，需理解視窗與 last 的意義。
- **可維護性**：中等，邏輯較緊湊，需小心邊界。
- **時間複雜度**：O(n)
- **空間複雜度**：O(n)
- **優點**：效率最佳，適合大數據量。
- **缺點**：邏輯較複雜，初學者較難一眼看懂。

---

## 方法比較表

| 方法   | 時間複雜度 | 空間複雜度 | 可讀性 | 可維護性 | 是否需排序 | 適用場景         |
|--------|------------|------------|--------|----------|------------|------------------|
| 方法一 | O(nk)      | O(n)       | 高     | 高       | 需要       | 一般/中等數據量   |
| 方法二 | O(n^2)     | O(n)       | 高     | 高       | 不需要     | 小數據量/教學用   |
| 方法三 | O(n)       | O(n)       | 中     | 中       | 不需要     | 大數據量/高效需求 |

---

## 結論建議

- 若追求**程式碼簡單、易懂**，可選方法一或方法二。
- 若追求**執行效率**，建議使用方法三（雙指針優化法）。
- 若數據量很小，三種方法皆可。

---

## 檔案結構

- `Program.cs`：主程式與三種解法實作
- `README.md`：本說明文件

---

如需更多 Leetcode 題解，歡迎參考原始碼與註解！
