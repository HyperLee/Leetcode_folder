# LeetCode 1625: 執行操作後字典序最小的字串

> Lexicographically Smallest String After Applying Operations

## 問題描述

給定一個由 0 到 9 的數字組成的**偶數長度**字串 `s`，以及兩個整數 `a` 和 `b`。

您可以對 `s` 應用以下兩個操作中的任意一個**任意次數**，並以**任意順序**：

1. **累加操作**：將 `a` 加到 `s` 的所有奇數索引（0-indexed）上。超過 9 的數字循環回到 0。
   - 範例：如果 `s = "3456"` 且 `a = 5`，則 `s` 變為 `"3951"`
   
2. **輪轉操作**：將 `s` 向右旋轉 `b` 個位置。
   - 範例：如果 `s = "3456"` 且 `b = 1`，則 `s` 變為 `"6345"`

返回通過對 `s` 應用上述操作任意次數所能獲得的**字典序最小的字串**。

### 字典序說明

一個字串 `a` 在字典序上小於字串 `b`（長度相同）如果在 `a` 和 `b` 第一次不同的位置，字串 `a` 在該位置的字母在字母表中比字串 `b` 對應的字母出現得更早。

**範例**：`"0158"` 在字典序上小於 `"0190"`，因為它們在第三個字母處第一次不同，且 `'5'` 在 `'9'` 之前。

## 解題思路

### 核心觀察

1. **累加操作和輪轉操作是獨立的**
   - 輪轉操作的次數不影響累加操作的效果
   - 可以分開枚舉這兩種操作

2. **b 的奇偶性決定了可操作的位置**
   - 當 `b` 是**偶數**時：無論輪轉多少次，只能對**奇數位**（索引 1, 3, 5, ...）進行累加操作
   - 當 `b` 是**奇數**時：可以對**奇數位和偶數位**（索引 0, 1, 2, ...）都進行累加操作，且可以做不同次數

3. **操作次數的上限**
   - **輪轉操作**：最多輪轉 `n` 次就會回到原位（`n` 為字串長度）
   - **累加操作**：由於數字範圍是 0-9，最多累加 10 次就會循環

### 枚舉法

基於以上觀察，我們採用**枚舉法**來找出所有可能的字串，然後選擇字典序最小的那個。

#### 步驟

1. **枚舉輪轉次數**
   - 從位置 0 開始，每次向右輪轉 `b` 位
   - 使用 `vis` 陣列記錄已訪問過的輪轉位置
   - 當遇到已訪問過的位置時，停止枚舉（因為會產生循環）

2. **對每個輪轉結果，枚舉累加次數**
   - 枚舉對**奇數位**做累加操作的次數 `j`（0-9 次）
   - 枚舉對**偶數位**做累加操作的次數 `k`
     - 如果 `b % 2 == 0`，則 `k = 0`（無法操作偶數位）
     - 如果 `b % 2 == 1`，則 `k = 0-9`（可以操作偶數位）

3. **比較所有結果**
   - 將每次操作後的字串與目前最小值比較
   - 更新最小值

### 複雜度分析

- **時間複雜度**：`O(n² × 10 × 10) = O(n²)`
  - 枚舉輪轉次數：`O(n)`
  - 對每個輪轉結果，枚舉累加次數：`O(10 × 10) = O(100)`
  - 每次累加操作需要遍歷字串：`O(n)`
  
- **空間複雜度**：`O(n)`
  - `vis` 陣列：`O(n)`
  - 臨時字元陣列：`O(n)`

## 程式碼實現

### 主要邏輯

```csharp
public string FindLexSmallestString(string s, int a, int b)
{
    int n = s.Length;
    bool[] vis = new bool[n]; // 記錄每個輪轉位置是否已訪問過
    string res = s; // 儲存目前找到的最小字串
    s = s + s; // 將字串複製一份接在後面，方便擷取輪轉後的字串

    // 枚舉輪轉操作
    for (int i = 0; !vis[i]; i = (i + b) % n)
    {
        vis[i] = true;
        
        // 枚舉對奇數位做累加操作的次數
        for (int j = 0; j < 10; j++)
        {
            // 根據 b 的奇偶性決定是否可以對偶數位做累加操作
            int kLimit = b % 2 == 0 ? 0 : 9;
            
            // 枚舉對偶數位做累加操作的次數
            for (int k = 0; k <= kLimit; k++)
            {
                char[] t = s.Substring(i, n).ToCharArray();
                
                // 對奇數位進行累加
                for (int p = 1; p < n; p += 2)
                {
                    t[p] = (char)('0' + (t[p] - '0' + j * a) % 10);
                }

                // 對偶數位進行累加
                for (int p = 0; p < n; p += 2)
                {
                    t[p] = (char)('0' + (t[p] - '0' + k * a) % 10);
                }

                // 更新最小值
                string tStr = new string(t);
                if (tStr.CompareTo(res) < 0)
                {
                    res = tStr;
                }
            }
        }
    }
    return res;
}
```

### 關鍵技巧

1. **字串複製技巧**：`s = s + s`
   - 將原字串複製一份接在後面
   - 方便使用 `Substring(i, n)` 擷取輪轉後的字串
   - 避免複雜的索引計算

2. **循環檢測**：使用 `vis` 陣列
   - 記錄已訪問過的輪轉起始位置
   - 避免重複計算

3. **模運算**：`(t[p] - '0' + j * a) % 10`
   - 將字元轉換為數字：`t[p] - '0'`
   - 累加後取模：確保數字在 0-9 範圍內
   - 轉回字元：`(char)('0' + ...)`

### 數學算法詳解

#### 累加操作的核心公式

```csharp
t[p] = (char)('0' + (t[p] - '0' + j * a) % 10);
```

這行程式碼實現了「對數字字元進行累加，超過 9 則循環回到 0」的邏輯。讓我們逐步分解：

#### 🔢 步驟拆解

##### 步驟 1：字元轉數字

```csharp
t[p] - '0'
```

- 利用 ASCII 碼相減將字元轉為數字
- 例如：`'5' - '0'` = 53 - 48 = 5

##### 步驟 2：累加計算

```csharp
(t[p] - '0' + j * a)
```

- `j`：累加操作的次數（0 到 9）
- `a`：每次累加的數值
- 計算總累加量

##### 步驟 3：模運算（循環邏輯）

```csharp
(t[p] - '0' + j * a) % 10
```

- `% 10`：取模運算，確保結果在 0-9 範圍內
- 實現「超過 9 循環回 0」的效果

##### 步驟 4：數字轉字元

```csharp
'0' + (結果)
```

- 將數字加上 `'0'` 的 ASCII 碼
- 例如：`'0' + 5` = 48 + 5 = 53 = `'5'`

##### 步驟 5：強制轉型

```csharp
(char)(...)
```

- 將整數結果轉為 char 型別

#### 📊 完整範例演算

##### 範例 1：基本累加

假設：

- 原字串 `s = "3456"`
- 累加值 `a = 5`
- 累加次數 `j = 1`（累加 1 次）
- 處理位置 `p = 1`（奇數位，字元是 `'4'`）

計算過程：

```text
1. 字元轉數字：'4' - '0' = 4
2. 累加計算：4 + 1 × 5 = 9
3. 模運算：9 % 10 = 9
4. 數字轉字元：'0' + 9 = '9'
5. 結果：t[1] = '9'

完整字串變化：
"3456" → "3956"（位置 1 的 '4' 變成 '9'）
```

##### 範例 2：循環回 0

假設：

- 原字串 `s = "3856"`
- 累加值 `a = 5`
- 累加次數 `j = 1`（累加 1 次）
- 處理位置 `p = 1`（奇數位，字元是 `'8'`）

計算過程：

```text
1. 字元轉數字：'8' - '0' = 8
2. 累加計算：8 + 1 × 5 = 13
3. 模運算：13 % 10 = 3  ← 超過 9，循環回來
4. 數字轉字元：'0' + 3 = '3'
5. 結果：t[1] = '3'

完整字串變化：
"3856" → "3356"（位置 1 的 '8' + 5 = 13，循環變成 '3'）
```

##### 範例 3：多次累加

假設：

- 原字串 `s = "74"`
- 累加值 `a = 5`
- 累加次數 `j = 3`（累加 3 次）
- 處理位置 `p = 1`（奇數位，字元是 `'4'`）

計算過程：

```text
1. 字元轉數字：'4' - '0' = 4
2. 累加計算：4 + 3 × 5 = 4 + 15 = 19
3. 模運算：19 % 10 = 9  ← 19 超過，取餘數
4. 數字轉字元：'0' + 9 = '9'
5. 結果：t[1] = '9'

完整字串變化：
"74" → "79"（位置 1 的 '4' + 15 = 19，循環變成 '9'）
```

#### 🎯 數學原理

##### 模運算的循環特性

數字 0-9 的循環可以用模運算表示：

```text
0 + 5 = 5  → 5 % 10 = 5
5 + 5 = 10 → 10 % 10 = 0  ← 循環回 0
7 + 5 = 12 → 12 % 10 = 2
9 + 5 = 14 → 14 % 10 = 4
```

##### 為什麼枚舉 10 次就夠了？

因為對任意數字 x，累加 a 共 10 次後：

```text
(x + 10 × a) % 10 = (x % 10 + (10 × a) % 10) % 10
                   = (x % 10 + 0) % 10
                   = x % 10
```

所以累加 10 次後會回到原來的數字，形成循環。

#### 💡 設計優勢

1. **效率高**：直接在字元層級操作，避免字串轉換
2. **簡潔**：一行程式碼完成所有轉換和計算
3. **正確性**：模運算保證結果永遠在有效範圍內
4. **可讀性**：遵循標準的字元-數字轉換模式

## 測試範例

### 範例 1

```text
輸入：s = "5525", a = 9, b = 2
輸出："2050"
```

**說明**：

- 執行第一個操作 4 次：`"5525"` → `"5588"` → `"5541"` → `"5504"` → `"5557"`
- 執行第二個操作 3 次：`"5557"` → `"2555"` → `"5525"` → `"5552"`
- 執行第一個操作 13 次：`"5552"` → ... → `"2050"`

### 範例 2

```text
輸入：s = "74", a = 5, b = 1
輸出："24"
```

**說明**：

- 執行第一個操作 3 次：`"74"` → `"79"` → `"24"` → `"29"` → `"24"`

### 範例 3

```text
輸入：s = "0011", a = 4, b = 2
輸出："0011"
```

**說明**：無法獲得更小的字串。

## 執行環境

- **.NET 8.0**
- **C# 13**

## 如何執行

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run
```

## 參考資料

- [LeetCode 1625 - English](https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/)
- [力扣 1625 - 中文](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/)

## 標籤

`字串` `枚舉` `輪轉` `字典序` `中等難度`
