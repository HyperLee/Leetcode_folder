# LeetCode 1625: 執行操作後字典序最小的字串

> Lexicographically Smallest String After Applying Operations

## 問題描述

給定一個由 0 到 9 的數字組成的**偶數長度**字串 `s`，以及兩個整數 `a` 和 `b`。

您可以對 `s` 應用以下兩個操作中的任意一個**任意次數**，並以**任意順序**：

1. **累加操作**：將 `a` 加到 `s` 的所有奇數索引（0-indexed）上。超過 9 的數字循環回到 0。
   - 範例：如果 `s = "3456"` 且 `a = 5`，則 `s` 變為 `"3951"`
   
2. **輪轉操作**：將 `s` 向右旋轉 `b` 個位置。
   - 範例：如果 `s = "3456"` 且 `b = 1`，則 `s` 變為 `"6345"`

返回通過對 `s` 應用上述操作任意次數所能獲得的**字典序最小的字串**。

### 字典序說明

一個字串 `a` 在字典序上小於字串 `b`（長度相同）如果在 `a` 和 `b` 第一次不同的位置，字串 `a` 在該位置的字母在字母表中比字串 `b` 對應的字母出現得更早。

**範例**：`"0158"` 在字典序上小於 `"0190"`，因為它們在第三個字母處第一次不同，且 `'5'` 在 `'9'` 之前。

## 解題思路

### 核心觀察

1. **累加操作和輪轉操作是獨立的**
   - 輪轉操作的次數不影響累加操作的效果
   - 可以分開枚舉這兩種操作

2. **b 的奇偶性決定了可操作的位置**
   - 當 `b` 是**偶數**時：無論輪轉多少次，只能對**奇數位**（索引 1, 3, 5, ...）進行累加操作
   - 當 `b` 是**奇數**時：可以對**奇數位和偶數位**（索引 0, 1, 2, ...）都進行累加操作，且可以做不同次數

3. **操作次數的上限**
   - **輪轉操作**：最多輪轉 `n` 次就會回到原位（`n` 為字串長度）
   - **累加操作**：由於數字範圍是 0-9，最多累加 10 次就會循環

### 枚舉法

基於以上觀察，我們採用**枚舉法**來找出所有可能的字串，然後選擇字典序最小的那個。

#### 步驟

1. **枚舉輪轉次數**
   - 從位置 0 開始，每次向右輪轉 `b` 位
   - 使用 `vis` 陣列記錄已訪問過的輪轉位置
   - 當遇到已訪問過的位置時，停止枚舉（因為會產生循環）

2. **對每個輪轉結果，枚舉累加次數**
   - 枚舉對**奇數位**做累加操作的次數 `j`（0-9 次）
   - 枚舉對**偶數位**做累加操作的次數 `k`
     - 如果 `b % 2 == 0`，則 `k = 0`（無法操作偶數位）
     - 如果 `b % 2 == 1`，則 `k = 0-9`（可以操作偶數位）

3. **比較所有結果**
   - 將每次操作後的字串與目前最小值比較
   - 更新最小值

### 複雜度分析

- **時間複雜度**：`O(n² × 10 × 10) = O(n²)`
  - 枚舉輪轉次數：`O(n)`
  - 對每個輪轉結果，枚舉累加次數：`O(10 × 10) = O(100)`
  - 每次累加操作需要遍歷字串：`O(n)`
  
- **空間複雜度**：`O(n)`
  - `vis` 陣列：`O(n)`
  - 臨時字元陣列：`O(n)`

## 程式碼實現

### 主要邏輯

```csharp
public string FindLexSmallestString(string s, int a, int b)
{
    int n = s.Length;
    bool[] vis = new bool[n]; // 記錄每個輪轉位置是否已訪問過
    string res = s; // 儲存目前找到的最小字串
    s = s + s; // 將字串複製一份接在後面，方便擷取輪轉後的字串

    // 枚舉輪轉操作
    for (int i = 0; !vis[i]; i = (i + b) % n)
    {
        vis[i] = true;
        
        // 枚舉對奇數位做累加操作的次數
        for (int j = 0; j < 10; j++)
        {
            // 根據 b 的奇偶性決定是否可以對偶數位做累加操作
            int kLimit = b % 2 == 0 ? 0 : 9;
            
            // 枚舉對偶數位做累加操作的次數
            for (int k = 0; k <= kLimit; k++)
            {
                char[] t = s.Substring(i, n).ToCharArray();
                
                // 對奇數位進行累加
                for (int p = 1; p < n; p += 2)
                {
                    t[p] = (char)('0' + (t[p] - '0' + j * a) % 10);
                }

                // 對偶數位進行累加
                for (int p = 0; p < n; p += 2)
                {
                    t[p] = (char)('0' + (t[p] - '0' + k * a) % 10);
                }

                // 更新最小值
                string tStr = new string(t);
                if (tStr.CompareTo(res) < 0)
                {
                    res = tStr;
                }
            }
        }
    }
    return res;
}
```

### 關鍵技巧

1. **字串複製技巧**：`s = s + s`
   - 將原字串複製一份接在後面
   - 方便使用 `Substring(i, n)` 擷取輪轉後的字串
   - 避免複雜的索引計算

2. **循環檢測**：使用 `vis` 陣列
   - 記錄已訪問過的輪轉起始位置
   - 避免重複計算

3. **模運算**：`(t[p] - '0' + j * a) % 10`
   - 將字元轉換為數字：`t[p] - '0'`
   - 累加後取模：確保數字在 0-9 範圍內
   - 轉回字元：`(char)('0' + ...)`

## 測試範例

### 範例 1

```text
輸入：s = "5525", a = 9, b = 2
輸出："2050"
```

**說明**：

- 執行第一個操作 4 次：`"5525"` → `"5588"` → `"5541"` → `"5504"` → `"5557"`
- 執行第二個操作 3 次：`"5557"` → `"2555"` → `"5525"` → `"5552"`
- 執行第一個操作 13 次：`"5552"` → ... → `"2050"`

### 範例 2

```text
輸入：s = "74", a = 5, b = 1
輸出："24"
```

**說明**：

- 執行第一個操作 3 次：`"74"` → `"79"` → `"24"` → `"29"` → `"24"`

### 範例 3

```text
輸入：s = "0011", a = 4, b = 2
輸出："0011"
```

**說明**：無法獲得更小的字串。

## 執行環境

- **.NET 8.0**
- **C# 13**

## 如何執行

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run
```

## 參考資料

- [LeetCode 1625 - English](https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/)
- [力扣 1625 - 中文](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/)

## 標籤

`字串` `枚舉` `輪轉` `字典序` `中等難度`
