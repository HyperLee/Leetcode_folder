# LeetCode 3005 - 最大頻率元素計數

> **C# 解決方案** | LeetCode 每日挑戰 2025-09-22

本專案實作了 LeetCode 3005 題「Count Elements With Maximum Frequency」的 C# 解決方案。

## 🎯 題目描述

給定一個由正整數組成的陣列 `nums`，回傳陣列中所有出現次數等於最大頻率的元素的總出現次數。

**元素的頻率**是該元素在陣列中出現的次數。

### 範例

**範例 1:**

```text
輸入: nums = [1,2,2,3,1,4]
輸出: 4
解釋: 
- 元素 1 出現 2 次
- 元素 2 出現 2 次  
- 元素 3 出現 1 次
- 元素 4 出現 1 次
最大頻率為 2，具有最大頻率的元素有 1 和 2
總計: 2 + 2 = 4
```

**範例 2:**

```text
輸入: nums = [1,2,3,4,5]
輸出: 5
解釋: 每個元素都只出現 1 次，最大頻率為 1
總計: 1 + 1 + 1 + 1 + 1 = 5
```

**範例 3:**

```text
輸入: nums = [1,1,1,2,2,3]
輸出: 3
解釋: 元素 1 出現 3 次（最大頻率），總計: 3
```

## 💡 解題思路

### 核心概念

這道題目可以分解為兩個主要步驟：

1. **頻率統計階段**：統計每個元素的出現次數，同時追蹤最大頻率
2. **結果計算階段**：找出所有最大頻率的元素，累加它們的出現次數

### 演算法步驟

#### 步驟 1: 頻率統計與最大頻率追蹤

```csharp
Dictionary<int, int> frequencyMap = new Dictionary<int, int>();
int maxFrequency = 0;

foreach (int value in nums) 
{
    // 更新頻率
    if (frequencyMap.ContainsKey(value))
        frequencyMap[value]++;
    else
        frequencyMap.Add(value, 1);
    
    // 即時更新最大頻率
    maxFrequency = Math.Max(maxFrequency, frequencyMap[value]);
}
```

**關鍵優化**：在統計頻率的同時即時追蹤最大頻率，避免額外的遍歷。

#### 步驟 2: 累加最大頻率元素的出現次數

```csharp
int result = 0;
foreach (var kvp in frequencyMap) 
{
    if (kvp.Value == maxFrequency)
        result += kvp.Value;  // 注意：累加的是出現次數，不是元素種類數
}
```

**重要細節**：累加的是元素的出現次數 (`kvp.Value`)，而不是元素的種類數量。

### 複雜度分析

- **時間複雜度**: O(n)，其中 n 是陣列長度
  - 第一個迴圈：O(n) 統計頻率
  - 第二個迴圈：O(k) 其中 k ≤ n 是不同元素的個數
  - 總時間複雜度：O(n)

- **空間複雜度**: O(k)，其中 k 是陣列中不同元素的個數
  - Dictionary 儲存最多 k 個鍵值對

## 🚀 執行程式

### 前置需求

- .NET 8.0 或更高版本
- C# 13 語言特性支援

### 建構與執行

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run
```

### 預期輸出

```text
測試案例 1: [1,2,2,3,1,4]
結果: 4

測試案例 2: [1,2,3,4,5]
結果: 5

測試案例 3: [1,1,1,2,2,3]
結果: 3
```

## 🔍 程式碼詳解

### 關鍵設計決策

1. **使用 Dictionary 進行頻率統計**
   - 提供 O(1) 的查找和更新操作
   - 自動處理新元素的加入

2. **即時最大頻率追蹤**
   - 在統計頻率的過程中同時更新最大頻率
   - 避免額外的 O(k) 遍歷來找最大值

3. **清晰的變數命名**
   - `frequencyMap`: 頻率對映表
   - `maxFrequency`: 最大頻率值
   - `maxFrequencyElements`: 最大頻率元素的總出現次數

### 邊界情況處理

- **單一元素陣列**：正確回傳該元素的出現次數
- **所有元素頻率相同**：正確累加所有元素的出現次數
- **只有一個最大頻率元素**：正確回傳該元素的出現次數

## 📈 演算法優化

### 當前解法的優點

1. **一次遍歷統計**：在 O(n) 時間內完成頻率統計和最大頻率追蹤
2. **空間效率**：只使用必要的 Dictionary 空間
3. **程式碼清晰**：邏輯分離明確，易於理解和維護

### 可能的替代方案

1. **使用陣列統計**（僅適用於數值範圍較小的情況）
2. **排序後統計**（時間複雜度 O(n log n)，不推薦）
3. **多次遍歷**（程式碼更簡單但效率較低）

## 🧪 測試案例

| 輸入 | 預期輸出 | 說明 |
|------|----------|------|
| `[1,2,2,3,1,4]` | `4` | 兩個元素具有最大頻率 2 |
| `[1,2,3,4,5]` | `5` | 所有元素頻率相同 |
| `[1,1,1,2,2,3]` | `3` | 單一元素具有最大頻率 |
| `[1]` | `1` | 單一元素陣列 |
| `[1,1,1,1]` | `4` | 所有元素相同 |

## 📚 學習重點

這道題目涵蓋了以下重要概念：

1. **雜湊表（Hash Table）應用**：使用 Dictionary 進行頻率統計
2. **一次遍歷優化**：在統計過程中同時維護額外資訊
3. **累加邏輯**：理解累加元素出現次數與累加元素種類的差異
4. **邊界情況處理**：考慮各種特殊輸入情況

## 🔗 相關資源

- [LeetCode 原題連結](https://leetcode.com/problems/count-elements-with-maximum-frequency/)
- [LeetCode 中文連結](https://leetcode.cn/problems/count-elements-with-maximum-frequency/)
- [.NET Dictionary 文件](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2)

---

*本解決方案遵循 C# 編碼最佳實務，包含詳細註解和完整的錯誤處理。*