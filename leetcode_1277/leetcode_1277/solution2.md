我會針對 `CountSquares` 的演算法做深入且系統性的說明，接著給出轉移方程式的推理過程、邊界處理、複雜度與範例推演（不會修改任何檔案）。

- [x] 提供詳細解法說明（動態規劃）
- [x] 給出轉移方程式的推理過程與直觀證明
- [x] 包含邊界、複雜度、空間優化與範例推演

## 高階計畫
我會先定義狀態（dp 的意義），再從圖形/局部條件推導轉移方程，然後說明為何把所有 dp 值相加就得到答案，最後補上邊界處理、複雜度、1D/就地優化及逐格範例推演。

## 狀態定義（Contract）
- 輸入：二維矩陣 `matrix`（元素為 0 或 1）
- 輸出：整數，表示所有全 1 的正方形子矩陣總數
- 定義 dp[i,j]：以格子 (i,j) 為右下角的「最大」全 1 正方形的邊長（若 matrix[i][j]==0 則為 0）

## 為什麼用「以右下角的最大邊長」？
每個位置 (i,j) 若能作為 k×k 的右下角，就同時能代表所有小於等於 k 的正方形（1×1, 2×2, …, k×k）。因此只要知道每個位置的最大邊長 dp[i,j]，把所有 dp[i,j] 加總就得到題目要的「所有不同大小、所有位置的正方形數量」。

## 轉移方程（直觀推導）
設我們已知 (i,j) 的值為 1（否則 dp[i,j]=0），考慮把 (i,j) 當右下角要擴展成更大的正方形時，會受哪些限制？

要在 (i,j) 形成邊長 L (>1) 的正方形，必須滿足下面三個條件：
1. (i-1, j)（上方）能當作右下角至少為 L-1 的正方形（上方區域要有 L-1 行）
2. (i, j-1)（左方）能當作右下角至少為 L-1 的正方形（左方區域要有 L-1 列）
3. (i-1, j-1)（左上）能當作右下角至少為 L-1 的正方形（左上角的內部也要完整）

換句話說，如果上、左、左上三者各自能支撐的最大邊長分別為 A、B、C，那 (i,j) 最多能支撐的就是 min(A, B, C) + 1（再加上自己這一格）。因此轉移式：

若 matrix[i][j] == 0：
  dp[i,j] = 0

若 matrix[i][j] == 1：
  若 i == 0 或 j == 0（第一列或第一行）：
    dp[i,j] = 1
  否則：
    dp[i,j] = 1 + min( dp[i-1,j], dp[i,j-1], dp[i-1,j-1] )

直觀證明要點：
- 若三者最小值為 k，代表上/左/左上都至少能形成 k 的正方形，連同目前的 1 就能形成 k+1。
- 若其中一者小於 k（比方左邊只有 k' < k），那左邊不足以支撐更大的內部填滿，因此整體只能到 k' + 1。取三者最小值就是保守且正確的限制。

也可以用反證法想：若 dp[i,j] > 1 + min(A,B,C)，則至少有一個方向的內部會有 0，導致該更大正方形不可能存在，矛盾。

## 為何把 dp 值相加等於答案？
假設 dp[i,j] = t，那代表以 (i,j) 為右下角可以形成大小為 1..t 的 t 個正方形（不同邊長）。每個合法正方形會由其右下角唯一對應的一個格子被計數一次，因此把所有 dp[i,j] 加總，正好覆蓋所有合法正方形且無重複。

## 邊界與實作要點
- 輸入檢查：若 `matrix == null` 或 `matrix.Length == 0`，回傳 0。
- 第 0 列或第 0 行：若為 1，dp 直接為 1（因為無法再向上或向左擴張）。
- 若想節省空間，可使用：
  - 就地修改原 `matrix`（把 1 改寫為相對應的邊長；注意型別與題目輸入若不可變就不要改）
  - 一維 dp（長度為 n），需要一個暫存變數保存上一列的左上角值（稱為 prev）

1D dp（逐列覆寫）的核心更新式（假設 dp[j] 為上一列的 dp[j]，在處理第 i 列時）：
- 當 matrix[i][j] == 1：
  - temp = dp[j]  // 暫存原來的 dp[j]（即上一列的 dp[j]，用作下一步的 prev）
  - dp[j] = 1 + min(dp[j], dp[j-1], prev)  // dp[j]（原為上一列的值）、dp[j-1]（當前列左格的已更新值）、prev（上一列左格 = 左上）
  - prev = temp
- 當 matrix[i][j] == 0：
  - prev = dp[j]
  - dp[j] = 0

其中 `prev` 始終儲存更新前的 dp[j-1]（上一列的左上格），`dp[j-1]` 在同一列當下是左邊已更新過的值（representing current row left value）。

## 時間與空間複雜度
- 時間複雜度：O(m * n)
- 空間複雜度：
  - 二維 dp：O(m * n)
  - 一維 dp：O(n)
  - 就地改寫原矩陣：O(1) 額外空間（但會破壞原輸入）

## 範例逐格推演（清楚例子）
輸入 mat：
0 1 1 1
1 1 1 1
0 1 1 1

逐格（計算 dp）：
- 第 0 列：dp = [0,1,1,1]
- 第 1 列：先處理 (1,0) -> 1
  - (1,1) -> 1 + min(上=1, 左=1, 左上=0) = 1
  - (1,2) -> 1 + min(上=1, 左=1, 左上=1) = 2
  - (1,3) -> 1 + min(上=1, 左=2, 左上=1) = 2
  結果第 1 列 dp = [1,1,2,2]
- 第 2 列：
  - (2,0) -> 0
  - (2,1) -> 1 + min(上=1, 左=0, 左上=1) = 1
  - (2,2) -> 1 + min(上=2, 左=1, 左上=1) = 2
  - (2,3) -> 1 + min(上=2, 左=2, 左上=2) = 3
  第 2 列 dp = [0,1,2,3]

全部加總：0+1+1+1 + 1+1+2+2 + 0+1+2+3 = 15

## 常見錯誤與注意事項
- 忘記處理第一列/第一行邊界（會導致索引越界）
- 若用就地改寫或 1D dp，注意暫存 prev 的更新時機（順序錯會導致使用到已被覆寫的值）
- 輸入非 0/1 的情況可先驗證或假設題目保證輸入正確

## 小結（一句話）
定義 dp[i,j] 為「以 (i,j) 為右下角的最大全 1 正方形邊長」，利用 dp[i,j] = 1 + min(dp[i-1,j], dp[i,j-1], dp[i-1,j-1])（當 matrix[i][j]==1 且非邊界）來遞推，最後把所有 dp 值加總就能得到答案；時間 O(mn)、空間可優化到 O(n)。

如果你要，我可以再提供
- 一個用一維 `dp` 的具體 `程式碼片段`（C#）並解釋 prev 的細節，或
- 把現有 `Program.cs` 改寫成就地更新版本並跑一次 `dotnet build` 驗證（你允許我修改檔案時才會做）。
