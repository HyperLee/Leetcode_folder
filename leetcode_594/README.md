# LeetCode 594 - 最長和諧子序列 (Longest Harmonious Subsequence)

## 題目描述

我們定義一個**和諧陣列**為其最大值與最小值的差正好為 1 的陣列。

給定一個整數陣列 `nums`，請回傳所有可能子序列中，最長和諧子序列的長度。

**子序列**是指可以透過刪除一些（也可以不刪除）元素而不改變其餘元素順序得到的序列。

## 範例

### 範例 1

```text
輸入: nums = [1,3,2,2,5,2,3,7]
輸出: 5
解釋: 最長和諧子序列是 [3,2,2,2,3]
```

### 範例 2

```text
輸入: nums = [1,2,3,4]
輸出: 2
解釋: 最長和諧子序列是 [1,2], [2,3] 或 [3,4]，長度都是 2
```

### 範例 3

```text
輸入: nums = [1,1,1,1]
輸出: 0
解釋: 沒有和諧子序列存在
```

## 解題思路

### 方法一：哈希表統計法（推薦）

**核心概念**：

- 和諧子序列只能包含兩個相鄰的數值（如 x 和 x+1）
- 統計每個數字的出現次數
- 檢查每個數字 x 與 x+1 的組合

**演算法步驟**：

1. 使用 `Dictionary<int, int>` 統計每個數字的出現次數
2. 遍歷字典中的每個數字 x
3. 檢查 x+1 是否存在於字典中
4. 如果存在，`count[x] + count[x+1]` 就是一個和諧子序列的長度
5. 回傳所有組合中的最大長度

**時間複雜度**：O(n) - 遍歷陣列建立哈希表 + 遍歷哈希表查找  
**空間複雜度**：O(n) - 哈希表存儲不同數字的計數

### 方法二：暴力解法

**核心概念**：

- 對每個數字 x，掃描整個陣列統計 x 和 x+1 的出現次數
- 計算所有可能的和諧子序列長度

**演算法步驟**：

1. 遍歷陣列中的每個數字 x
2. 對於每個 x，再次遍歷整個陣列
3. 統計 x 和 x+1 的出現次數
4. 如果 x+1 存在，計算和諧子序列長度
5. 回傳所有組合中的最大長度

**時間複雜度**：O(n²) - 雙層迴圈遍歷  
**空間複雜度**：O(1) - 只使用常數額外空間

### 解法比較

| 比較項目 | 哈希表解法 | 暴力解法 |
|---------|-----------|---------|
| **時間複雜度** | O(n) | O(n²) |
| **空間複雜度** | O(n) | O(1) |
| **可讀性** | 高 | 中等 |
| **效率** | 優秀 | 較差 |
| **適用場景** | 大型資料集 | 小型資料集 |

**結論**：哈希表解法在時間效率上明顯優於暴力解法，是生產環境的首選方案。

## 程式碼結構

```text
leetcode_594/
├── leetcode_594/
│   ├── Program.cs          # 主程式和解題實作
│   └── leetcode_594.csproj # 專案設定檔
├── .vscode/
│   ├── launch.json         # 偵錯設定
│   └── tasks.json          # 建構任務設定
└── README.md              # 說明文件
```

## 執行方式

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run --project leetcode_594
```

### 偵錯模式

在 VS Code 中按 `F5` 或使用「執行和偵錯」面板

## 測試案例

程式包含以下測試案例：

1. **經典範例**: `[1,3,2,2,5,2,3,7]` → 期望結果: 5
2. **連續數字**: `[1,2,3,4]` → 期望結果: 2  
3. **相同元素**: `[1,1,1,1]` → 期望結果: 0
4. **複雜案例**: `[1,3,2,2,5,2,3,7,1]` → 期望結果: 5

## 程式碼亮點

### 主要實作

#### 方法一：`FindLHS` 方法（哈希表解法）

- 使用 `Dictionary<int, int>` 進行頻率統計
- 雙層迴圈優化為單次遍歷
- 清晰的程式碼註解說明每個步驟
- 時間複雜度：O(n)

#### 方法二：`FindLHS_BruteForce` 方法（暴力解法）

- 直接遍歷陣列進行統計
- 適合理解問題本質
- 展示演算法優化的重要性
- 時間複雜度：O(n²)

### 測試設計

- 涵蓋邊界案例（空陣列、單一元素、相同元素）
- 包含典型案例和複雜案例
- 詳細的輸出說明幫助理解結果
- 兩種解法的效能比較

## 相關連結

- [LeetCode 英文題目](https://leetcode.com/problems/longest-harmonious-subsequence/description/?envType=daily-question&envId=2025-06-30)
- [LeetCode 中文題目](https://leetcode.cn/problems/longest-harmonious-subsequence/description/?envType=daily-question&envId=2025-06-30)

## 技術規格

- **.NET 版本**: 8.0
- **程式語言**: C#
- **專案類型**: 主控台應用程式
- **IDE**: Visual Studio Code (推薦)

## 學習重點

1. **哈希表應用**: 學習如何使用字典進行頻率統計
2. **陣列處理**: 理解子序列與子陣列的差異
3. **演算法優化**: 從暴力解法優化到線性時間複雜度
4. **程式設計**: 良好的程式碼結構和註解習慣
5. **效能分析**: 比較不同解法的時間空間複雜度
6. **解題思維**: 學習如何從問題本質找出最佳資料結構

### 為什麼選擇 Dictionary？

**問題特性分析**：

- 需要快速統計每個數字的出現頻率
- 需要快速查詢特定數字（x+1）是否存在
- 和諧子序列只包含相鄰的兩個數值

**Dictionary 的優勢**：

1. **O(1) 查詢時間** - 快速檢查 x+1 是否存在
2. **頻率統計** - 自然適合 key-value 對應關係
3. **避免重複計算** - 每個數字只統計一次
4. **記憶體效率** - 只存儲實際出現的數字

相比其他資料結構：

- 陣列：需要 O(n) 時間查詢，效率低
- 排序：會破壞子序列的相對順序
- 集合：無法記錄頻率資訊
