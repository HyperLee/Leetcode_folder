# LeetCode 3354 - Make Array Elements Equal to Zero

> 使陣列元素等於零

一個 C# 解決方案，用於解決 LeetCode 每日挑戰題目 3354。

## 問題描述

給定一個整數陣列 `nums`。

首先選擇一個起始位置 `curr`，使得 `nums[curr] == 0`，並選擇一個移動方向（向左或向右）。

之後，重複執行以下過程：

- 如果 `curr` 超出範圍 `[0, n - 1]`，此過程結束。
- 如果 `nums[curr] == 0`，則按照當前方向移動，如果向右移動則 `curr` 加 1，如果向左移動則 `curr` 減 1。
- 否則如果 `nums[curr] > 0`：
  - 將 `nums[curr]` 減 1。
  - 反轉移動方向（左變右，右變左）。
  - 朝新方向移動一步。

如果在過程結束時，`nums` 中的每個元素都變為 0，則初始位置 `curr` 和移動方向的選擇被視為有效。

**返回可能的有效選擇數量。**

## 解題思路

### 方法一：前綴和算法

這個問題可以類比成「打磚塊」遊戲。想像有一個小球從初始位置開始，在陣列中左右彈跳，每次碰到正數就反彈，同時將該正數減 1。

#### 核心概念

為了消除所有的正數，我們需要理解一個關鍵規律：

1. **向右移動的情況**：
   - 如果初始方向向右，小球會先向右移動碰到正數就反彈並減 1
   - 為了讓所有元素都變成 0，需要滿足：
     - `右邊元素和 == 左邊元素和`（小球來回彈跳次數相同，最後剛好消除所有元素）
     - 或 `右邊元素和 == 左邊元素和 + 1`（右邊比左邊多 1，小球會在右邊完成最後一次反彈，並從左邊離開）

2. **向左移動的情況**：
   - 如果初始方向向左，情況與向右對稱
   - 需要滿足：
     - `左邊元素和 == 右邊元素和`（小球來回彈跳次數相同）
     - 或 `左邊元素和 == 右邊元素和 + 1`（左邊比右邊多 1，小球會在左邊完成最後一次反彈，並從右邊離開）

#### 算法步驟

1. **計算陣列總和**：用於初始化右邊元素和
2. **枚舉每個位置**：
   - 維護左邊元素和 `left` 和右邊元素和 `right`
   - 遇到 `nums[i] == 0` 時，檢查是否為有效起始位置
   - 對於每個有效的起始位置，檢查兩個方向（左、右）是否滿足條件
3. **更新前綴和**：將當前元素從右邊移到左邊

#### 複雜度分析

- **時間複雜度**：O(n)，其中 n 是陣列長度。只需遍歷一次陣列。
- **空間複雜度**：O(1)，只使用常數額外空間。

---

### 方法二：模擬法

由於資料量較小，我們可以直接模擬每種方案並判斷是否有效。

#### 核心概念

將陣列 `nums` 中每個為 0 元素的位置作為初始位置，分別向兩個方向進行模擬。模擬時，我們判斷當前元素是否為 0，如果為 0 繼續朝原方向移動，否則將當前值減 1，並將方向反轉，移動到下一個位置。

#### 算法步驟

1. **枚舉初始位置**：找出所有值為 0 的位置作為可能的起始位置
2. **模擬兩個方向**：
   - 對每個初始位置，分別模擬向左（-1）和向右（1）移動
   - 複製原陣列以避免修改原始資料
3. **執行模擬過程**：
   - 如果當前位置為 0，繼續朝當前方向移動
   - 如果當前位置大於 0：
     - 將該值減 1
     - 反轉移動方向
     - 如果該值變為 0，減少非零元素計數
   - 移動到下一個位置
4. **判斷有效性**：
   - 當所有元素變為 0 或移出陣列範圍時停止模擬
   - 如果所有元素都變為 0，則該方案有效

#### 複雜度分析

- **時間複雜度**：O(n² × m)，其中 n 是陣列長度，m 是陣列元素的平均值。最壞情況下，對每個 0 位置都要模擬整個過程。
- **空間複雜度**：O(n)，需要複製陣列進行模擬。

#### 方法比較

| 特性 | 方法一：前綴和 | 方法二：模擬法 |
|------|---------------|---------------|
| 時間複雜度 | O(n) | O(n² × m) |
| 空間複雜度 | O(1) | O(n) |
| 實現難度 | 較高（需要理解規律） | 較低（直接模擬） |
| 適用場景 | 大規模資料 | 小規模資料 |
| 程式碼可讀性 | 需要理解數學原理 | 直觀易懂 |

**建議**：對於本題的資料規模，兩種方法都可行。方法一效能更佳，方法二更直觀易懂。

## 範例

### 範例 1

**輸入**：`nums = [1,0,2,0,3]`

**輸出**：`2`

**說明**：

- 從索引 1 開始向右移動：左邊和 = 1，右邊和 = 2 + 0 + 3 = 5，不滿足條件
- 從索引 1 開始向左移動：左邊和 = 1，右邊和 = 5，不滿足條件
- 從索引 3 開始向右移動：左邊和 = 1 + 0 + 2 = 3，右邊和 = 3，滿足條件 ✓
- 從索引 3 開始向左移動：左邊和 = 3，右邊和 = 3，滿足條件 ✓

有效選擇數量為 2。

### 範例 2

**輸入**：`nums = [2,3,4,0,4,1,0]`

**輸出**：`0`

**說明**：沒有任何起始位置和方向的組合能使所有元素變為 0。

## 專案結構

```text
leetcode_3354/
├── .editorconfig           # 程式碼風格設定
├── .gitignore             # Git 忽略檔案
├── .vscode/               # VS Code 設定
│   ├── launch.json        # 除錯設定
│   └── tasks.json         # 建置任務
├── leetcode_3354/         # 主專案目錄
│   ├── Program.cs         # 解題程式碼
│   └── leetcode_3354.csproj
└── leetcode_3354.sln      # 解決方案檔
```

## 開始使用

### 前置需求

- [.NET 8.0 SDK](https://dotnet.microsoft.com/download/dotnet/8.0) 或更高版本
- [Visual Studio Code](https://code.visualstudio.com/) (推薦)

### 建置專案

```bash
cd leetcode_3354
dotnet build
```

### 執行程式

```bash
cd leetcode_3354
dotnet run
```

### 除錯

在 VS Code 中：

1. 開啟 `Program.cs`
2. 按下 `F5` 或從除錯面板選擇「Launch Program」
3. 程式會自動建置並開始除錯

## 連結

- [LeetCode 英文題目](https://leetcode.com/problems/make-array-elements-equal-to-zero/description/?envType=daily-question&envId=2025-10-28)
- [LeetCode 中文題目](https://leetcode.cn/problems/make-array-elements-equal-to-zero/description/?envType=daily-question&envId=2025-10-28)
