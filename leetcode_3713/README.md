# LeetCode 3713 - 尋找最長的平衡子字串

本專案實作 LeetCode 3713 題目的解決方案，使用 C# 14 (.NET 10) 開發。

## 題目說明

給定一個僅由小寫英文字母組成的字串 `s`，找出**最長的平衡子字串**的長度。

### 平衡子字串的定義

一個子字串被稱為「平衡的」，當且僅當子字串中**所有出現的字符的出現次數都相同**。

### 範例

**範例 1:**
```
輸入: s = "cabbacc"
輸出: 4
說明: 子字串 "abba" 是平衡的，因為 'a' 和 'b' 都出現 2 次
```

**範例 2:**
```
輸入: s = "aabbcc"
輸出: 6
說明: 整個字串 "aabbcc" 是平衡的，因為 'a', 'b', 'c' 都出現 2 次
```

**範例 3:**
```
輸入: s = "aaaa"
輸出: 4
說明: 整個字串 "aaaa" 是平衡的，因為只有 'a' 出現 4 次
```

**範例 4:**
```
輸入: s = "abc"
輸出: 1
說明: 任何單個字符都是平衡的
```

## 解題思路

### 方法一：暴力枚舉

#### 核心概念

這個問題的關鍵在於理解「平衡」的定義：**所有出現的字符必須有相同的出現次數**。我們採用暴力枚舉的方法，檢查所有可能的子字串，找出符合條件且最長的那一個。

#### 解題出發點

1. **枚舉所有子字串**：使用雙層迴圈，外層確定左端點，內層確定右端點
2. **動態統計字符頻率**：在擴展右端點的過程中，即時更新字符出現次數
3. **驗證平衡條件**：檢查所有已出現字符的出現次數是否相同
4. **更新最大長度**：若子字串平衡，則更新答案

### 詳細解法

#### 算法步驟

1. **初始化變量**
   - `n`: 字串長度
   - `res`: 記錄最長平衡子字串的長度，初始為 0
   - `cnt`: 大小為 26 的陣列，統計 26 個小寫字母的出現次數

2. **外層迴圈 (左端點 i)**
   - 遍歷字串的每個位置作為子字串的起始點
   - 每次開始新的左端點時，重置 `cnt` 陣列

3. **內層迴圈 (右端點 j)**
   - 從當前左端點 `i` 開始，逐步擴展到字串末尾
   - 每擴展一個字符，就將該字符的計數加 1

4. **平衡性檢查**
   - 遍歷 `cnt` 陣列中的所有計數值
   - 如果某個字符已出現（計數 > 0），檢查其計數是否與最新加入的字符計數相同
   - 若所有已出現字符的計數都相同，則當前子字串為平衡子字串

5. **更新答案**
   - 若當前子字串平衡，計算其長度 `j - i + 1`
   - 與目前記錄的最長長度比較，取較大值

#### 時間與空間複雜度

- **時間複雜度**: O(n² × 26) = O(n²)
  - 外層迴圈 O(n)，內層迴圈 O(n)
  - 每次檢查平衡性需要遍歷 26 個字母，O(26) = O(1)
  
- **空間複雜度**: O(26) = O(1)
  - 只使用固定大小的計數陣列

## 演示流程

讓我們以 `s = "cabbacc"` 為例，詳細演示算法執行過程。

### 完整執行流程

#### 初始狀態
```
字串: c a b b a c c
索引: 0 1 2 3 4 5 6
n = 7, res = 0
```

#### 當 i = 0 (左端點從 'c' 開始)

| j | 子字串 | cnt 陣列 | 檢查過程 | 是否平衡 | res |
|---|--------|---------|---------|---------|-----|
| 0 | "c" | c:1 | 只有 c (1次) | ✅ 平衡 | 1 |
| 1 | "ca" | c:1, a:1 | c(1) = a(1) | ✅ 平衡 | 2 |
| 2 | "cab" | c:1, a:1, b:1 | c(1) = a(1) = b(1) | ✅ 平衡 | 3 |
| 3 | "cabb" | c:1, a:1, b:2 | c(1) ≠ b(2) | ❌ 不平衡 | 3 |
| 4 | "cabba" | c:1, a:2, b:2 | c(1) ≠ a(2) | ❌ 不平衡 | 3 |
| 5 | "cabbac" | c:2, a:2, b:2 | c(2) = a(2) = b(2) | ✅ 平衡 | 6 |
| 6 | "cabbacc" | c:3, a:2, b:2 | c(3) ≠ a(2) | ❌ 不平衡 | 6 |

#### 當 i = 1 (左端點從 'a' 開始)

| j | 子字串 | cnt 陣列 | 檢查過程 | 是否平衡 | res |
|---|--------|---------|---------|---------|-----|
| 1 | "a" | a:1 | 只有 a (1次) | ✅ 平衡 | 6 |
| 2 | "ab" | a:1, b:1 | a(1) = b(1) | ✅ 平衡 | 6 |
| 3 | "abb" | a:1, b:2 | a(1) ≠ b(2) | ❌ 不平衡 | 6 |
| 4 | "abba" | a:2, b:2 | a(2) = b(2) | ✅ 平衡 | 6 |
| 5 | "abbac" | a:2, b:2, c:1 | c(1) ≠ a(2) | ❌ 不平衡 | 6 |
| 6 | "abbacc" | a:2, b:2, c:2 | a(2) = b(2) = c(2) | ✅ 平衡 | 6 |

#### 關鍵觀察

繼續枚舉 i = 2, 3, 4, 5, 6，不會找到更長的平衡子字串。

**最終答案**: 6 (子字串 "cabbac" 或 "abbacc")

### 簡化範例：s = "aabbcc"

```
步驟展示:
i=0, j=0: "a" → a:1 → ✅ res=1
i=0, j=1: "aa" → a:2 → ✅ res=2
i=0, j=2: "aab" → a:2, b:1 → ❌ (a計數≠b計數)
i=0, j=3: "aabb" → a:2, b:2 → ✅ res=4
i=0, j=4: "aabbc" → a:2, b:2, c:1 → ❌
i=0, j=5: "aabbcc" → a:2, b:2, c:2 → ✅ res=6

答案: 6 (整個字串都是平衡的)
```

## 執行程式

### 前置需求

- .NET 10 SDK

### 建構與執行

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run --project leetcode_3713
```

### 預期輸出

```
測試 1: 輸入 = "cabbacc", 輸出 = 6
測試 2: 輸入 = "aabbcc", 輸出 = 6
測試 3: 輸入 = "aaaa", 輸出 = 4
測試 4: 輸入 = "abc", 輸出 = 1
```

## 程式碼結構

```
leetcode_3713/
├── leetcode_3713/
│   ├── Program.cs          # 主程式及解法實作
│   └── leetcode_3713.csproj
└── README.md
```

## 關鍵程式碼說明

### 平衡性檢查邏輯

```csharp
foreach(int x in cnt)
{
    // 若某字符已出現 (x > 0) 且其出現次數不等於剛加入的字符出現次數
    // 則當前子字串不平衡
    if(x > 0 && x != cnt[c])
    {
        flag = false;
        break;
    }
}
```

這段程式碼是算法的核心：
- 只檢查已出現的字符（`x > 0`）
- 將所有已出現字符的計數與最新加入字符的計數比較
- 若存在不同的計數值，則子字串不平衡

## 優化方向

> [!NOTE]
> 目前實作採用暴力枚舉法，時間複雜度為 O(n²)。對於較大的輸入可能需要優化。

可能的優化方向：
1. 使用滑動窗口技巧
2. 利用哈希表記錄已計算過的狀態
3. 剪枝策略：若當前最長長度已無法超越答案，提前終止

---

> [!TIP]  
> 本解法適合初學者理解問題本質，重點在於清晰的邏輯和正確性，而非最優性能。
