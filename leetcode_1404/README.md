# LeetCode 1404 — 將二進位表示減到 1 的步驟數

> **Number of Steps to Reduce a Number in Binary Representation to One**

[![.NET](https://img.shields.io/badge/.NET-10.0-512BD4?logo=dotnet)](https://dotnet.microsoft.com)
[![Language](https://img.shields.io/badge/language-C%23-239120?logo=csharp)](https://learn.microsoft.com/dotnet/csharp/)
[![Difficulty](https://img.shields.io/badge/difficulty-Medium-orange)](https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/)

---

## 題目描述

給定一個整數的**二進位表示字串** `s`，依照以下規則計算將其化為 `"1"` 所需的**最少步驟數**：

1. 若當前數字為**偶數**，將其除以 2。
2. 若當前數字為**奇數**，將其加 1。

保證所有測試資料最終都能達到 1。

**來源**：[LeetCode 1404](https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/)

### 輸入 / 輸出範例

| 輸入 `s` | 輸出 | 說明 |
|----------|------|------|
| `"1101"` | `6`  | 見下方完整演示 |
| `"10"`   | `1`  | 2 → 1 |
| `"1"`    | `0`  | 已是 1，不需步驟 |
| `"1111"` | `5`  | 特殊進位情況 |

---

## 解題概念與出發點

### 關鍵觀察：直接在二進位字串上操作

與其將字串轉為整數再計算，可以直接對字串進行位元操作，避免大數溢位問題：

| 數學操作 | 對應二進位字串操作 |
|--------|-----------------|
| 偶數 ÷ 2 | 移除字串最右側的 `'0'` |
| 奇數 + 1 | 從最低位進行二進位加法（往高位傳遞進位）|

### 奇數加 1 的細節

奇數的最低位一定是 `'1'`，加 1 後會發生進位傳遞：

- 從最低位（最右端）往最高位掃描。
- 遇到 `'1'` → 該位歸零（`'1'` → `'0'`），進位繼續向左傳遞。
- 遇到 `'0'` → 該位設 1（`'0'` → `'1'`），進位停止。
- **特殊情況**：若整串全為 `'1'`（例如 `"1111"`），進位會超出最高位，需在字串前端插入 `'1'`（例如 `"1111"` → `"10000"`）。

---

## 解法說明

### 方法：模擬（Simulation）

直接依照題意逐步執行，以 `StringBuilder` 代表當前的二進位數值：

```csharp
public int NumSteps(string s)
{
    int steps = 0;
    StringBuilder sb = new StringBuilder(s);

    while (sb.ToString() != "1")
    {
        steps++;

        if (sb[sb.Length - 1] == '0')
        {
            // 偶數：截去末尾 '0'（等同除以 2）
            sb.Length--;
        }
        else
        {
            // 奇數：從最低位往高位模擬二進位加 1
            for (int i = sb.Length - 1; i >= 0; i--)
            {
                if (sb[i] == '1')
                {
                    sb[i] = '0'; // 歸零，進位繼續向左
                    if (i == 0)
                    {
                        sb.Insert(0, '1'); // 全為 1 的特殊進位
                        break;
                    }
                }
                else
                {
                    sb[i] = '1'; // 接收進位，停止傳遞
                    break;
                }
            }
        }
    }

    return steps;
}
```

### 複雜度分析

| 面向 | 複雜度 | 說明 |
|------|--------|------|
| 時間 | O(n²)  | n 為字串長度；每次奇數操作最多掃描整串 |
| 空間 | O(n)   | `StringBuilder` 額外佔用字串大小的記憶體 |

---

## 解法二：遍歷計數（Greedy Count）

### 概念出發點

解法一以模擬方式直接操作字串，最壞情況每次奇數操作需掃描整串，導致 $O(n^2)$ 的時間複雜度。  
解法二的核心思想是：**不實際修改字串，而是直接分析每個字元在整個過程中會「貢獻」幾個操作步驟**，一次遍歷即可得出答案。

**關鍵觀察：除了最初的情況外，最低位始終為 1**

當 $k$ 個連續的 '1' 被一次加一處理後，這 $k$ 個 '1' 全部歸零並向左產生進位，使原本左邊緊鄰的那個 '0' 變成 '1'。  
因此處理後的最低位必然是 '1'，這表示我們只需在一開始考慮低位為 '0' 的情況。

### 每個字元的「命運」與步驟貢獻

從最低位（最右）往最高位（最左）逐一分析，以 `meet` 標記是否已遇到第一個 '1'：

| 位置條件 | 字元 | 命運說明 | 貢獻步驟 |
|----------|------|----------|----------|
| `meet=false`（尚未見 '1'） | `'0'` | 低位原生的 0，只需一次除二刪除 | **+1** |
| `meet=false`，`i != 0` | `'1'` | 需先加一（耗 1 步）使其歸零並產生進位，再被除二刪除（耗 1 步） | **+2**，設 `meet=true` |
| `meet=false`，`i == 0` | `'1'` | 最左側的目標值 "1"，不需任何操作 | **+0**，設 `meet=true` |
| `meet=true` | `'0'` | 右側進位傳到此處先將其變 '1'（加一 1 步），再被除二刪除（1 步） | **+2** |
| `meet=true` | `'1'` | 右側進位使其歸零（加一已由右側 '0' 計入），只需被除二刪除 | **+1** |

### 解法程式碼

```csharp
public int NumSteps2(string s)
{
    int n = s.Length;
    int res = 0;
    bool meet = false;   // 是否已遇到第一個 '1'

    for (int i = n - 1; i >= 0; i--)
    {
        if (s[i] == '0')
        {
            res += meet ? 2 : 1;
        }
        else
        {
            if (!meet)
            {
                if (i != 0) res += 2;
                meet = true;
            }
            else
            {
                res += 1;
            }
        }
    }

    return res;
}
```

### 複雜度分析

| 面向 | 複雜度 | 說明 |
|------|--------|------|
| 時間 | O(n)   | 單次從右到左遍歷，n 為字串長度 |
| 空間 | O(1)   | 僅使用常數額外空間，無需額外資料結構 |

---

## 演示流程

以 `s = "1101"`（十進位 13）為例，逐步追蹤：

```
步驟  目前值        操作                  動作
----  ----------   -------------------   ---------------------------
 0    "1101" (13)  最低位為 '1' → 奇數    +1（二進位進位）
 1    "1110" (14)  最低位為 '0' → 偶數    ÷2（移除末尾 '0'）
 2    "111"  ( 7)  最低位為 '1' → 奇數    +1（全為 '1'，插入進位）
 3    "1000" ( 8)  最低位為 '0' → 偶數    ÷2
 4    "100"  ( 4)  最低位為 '0' → 偶數    ÷2
 5    "10"   ( 2)  最低位為 '0' → 偶數    ÷2
 6    "1"    ( 1)  等於 "1" → 結束
```

共 **6 步**。

---

以 `s = "1111"`（十進位 15）為例，說明全為 `'1'` 的特殊進位情況：

```
步驟  目前值         操作                   動作
----  -----------   --------------------   ---------------------------------
 0    "1111" (15)   最低位為 '1' → 奇數     +1（全為 '1'，往前插入 '1'）
 1    "10000" (16)  最低位為 '0' → 偶數     ÷2
 2    "1000"  ( 8)  最低位為 '0' → 偶數     ÷2
 3    "100"   ( 4)  最低位為 '0' → 偶數     ÷2
 4    "10"    ( 2)  最低位為 '0' → 偶數     ÷2
 5    "1"     ( 1)  等於 "1" → 結束
```

共 **5 步**。

---

以 `s = "1100011100"`（十進位 796）為例，展示解法二的遍歷計數過程：

```
索引  字元   meet    操作說明                            貢獻  累計
----  ----  ------  ---------------------------------   ----  ----
  9    '0'  false   低位原生 0，直接除二刪除              +1     1
  8    '0'  false   低位原生 0，直接除二刪除              +1     2
  7    '1'  false   首個 '1'（非最左位）：加一+除二       +2     4  → meet=true
  6    '1'  true    進位使其歸零，只需除二                +1     5
  5    '1'  true    進位使其歸零，只需除二                +1     6
  4    '0'  true    進位先使其變 '1'，再除二              +2     8
  3    '0'  true    進位先使其變 '1'，再除二              +2    10
  2    '0'  true    進位先使其變 '1'，再除二              +2    12
  1    '1'  true    進位使其歸零，只需除二                +1    13
  0    '1'  true    進位使其歸零，只需除二                +1    14
```

共 **14 步**（與模擬法結果相同，但僅需一次 O(n) 掃描）。

---

## 執行專案

### 環境需求

- [.NET 10 SDK](https://dotnet.microsoft.com/download)

### 建構與執行

```bash
# 建構
dotnet build

# 執行
dotnet run --project leetcode_1404/leetcode_1404.csproj
```

預期輸出：

```
LeetCode 1404 - 將二進位表示減到 1 的步驟數
--------------------------------------------------
[解法一] 模擬（Simulation）
  [PASS] NumSteps("1101") = 6  (預期: 6)
  [PASS] NumSteps("10") = 1  (預期: 1)
  [PASS] NumSteps("1") = 0  (預期: 0)
  [PASS] NumSteps("1111") = 5  (預期: 5)
  [PASS] NumSteps("1100011100") = 14  (預期: 14)

[解法二] 遍歷計數（Greedy Count）
  [PASS] NumSteps2("1101") = 6  (預期: 6)
  [PASS] NumSteps2("10") = 1  (預期: 1)
  [PASS] NumSteps2("1") = 0  (預期: 0)
  [PASS] NumSteps2("1111") = 5  (預期: 5)
  [PASS] NumSteps2("1100011100") = 14  (預期: 14)
```
