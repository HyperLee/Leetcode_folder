# 3432. Count Partitions with Even Sum Difference

## 詳細題目說明

- 給定一個整數陣列 `nums`，長度為 `n`。

- 定義一個 **分割**（partition）為索引 `i`，滿足 `0 <= i < n - 1`，把陣列拆成兩個**非空**子陣列：

  - 左子陣列為 `nums[0..i]`，右子陣列為 `nums[i+1..n-1]`。

- 計算使得左子陣列和與右子陣列和之差為**偶數**的所有分割的數量。

## 問題觀察與出發點（數學推導）

- 設整個陣列的總和為 `S`。令左子陣列和為 `L`，右子陣列和為 `R`，則 `R = S - L`。

- 差值 `D = L - R = L - (S - L) = 2L - S`。

  - 注意 `2L` 在模 2 的情況下一定為 0（偶數），因此 `D` 的奇偶性只取決於 `S` 的奇偶性：

    - 若 `S` 為奇數，則 `D` 為奇數（因為 `D ≡ -S (mod 2)`），所以沒有任何分割會讓 `D` 為偶數。

    - 若 `S` 為偶數，則 `D` 為偶數，任意 `L`（也就是任意分割）都會得到 `D` 為偶數。

因此我們只需要判斷總和 `S` 的奇偶性；如果 `S` 為偶數，所有可能的合法分割都有效；若 `S` 為奇數，答案為 0。

## 為什麼答案是 `n - 1`（而不是 `n`）？

- 分割必須把陣列拆成兩個非空子陣列，意味著我們只能在元素之間的 **縫隙** 做切分。對於 `n` 個元素，內部縫隙數為 `n - 1`（例如：`a | b | c | ...`）。

- 若允許空子陣列（例如把所有元素都留在左或右），那會有 `n + 1` 切分位置（含最左與最右），但題目不允許把某一側空白，因此合法的切分只有 `n - 1` 個。

## 解題步驟（實作說明）

1. 計算整個陣列的總和 `S`。

2. 檢查 `S` 的奇偶性：

   - 若 `S` 為奇數 → 回傳 `0`。

   - 若 `S` 為偶數 → 回傳 `n - 1`。

## C# 範例實作（程式片段）

```csharp
public int CountPartitions(int[] nums)
{
    long totalSum = 0; // 建議用 long 以避免 int 溢位
    foreach (int x in nums)
    {
        totalSum += x;
    }

    return (totalSum % 2 == 0) ? nums.Length - 1 : 0;
}
```

## 範例演示

- 輸入：`[2, 1, 6, 4]` → `S=13`（奇數）→ 回傳 `0`。

- 輸入：`[1, 1, 1, 1]` → `S=4`（偶數）→ `n - 1 = 3` → 回傳 `3`。

- 輸入：`[2]` → `S=2`（偶）但 `n = 1` → `n - 1 = 0`（無任何合法切分）→ 回傳 `0`。

## 時間與記憶體複雜度

- 時間複雜度：O(n) — 需要一趟掃描來計算總和。

- 空間複雜度：O(1) — 只使用常數額外空間。

## 邊界情形與注意事項

- `nums` 假設非空（`n >= 1`）。如果外部輸入有空陣列的情形，應先檢查並處理。

- 為避免因大數值導致 `int` 溢位，建議使用 `long` 來儲存累加的總和（如上程式片段）。

- 負數元素也不會改變奇偶結論：奇偶性仍由 `S` 決定。

## 如何在本專案執行示例

1. 本專案已在 `Program.cs` 的 `Main` 中包含一些簡單測試。

2. 執行範例（在工作目錄中）：

```pwsh
dotnet run --project leetcode_3432/leetcode_3432.csproj -c Debug
```

## 擴充建議（可選）

- 若你想要更完整的驗證，可以新增單元測試（xUnit/NUnit）並加入更多邊界值測試，例如：

  - 包含負數、包含 0、極大數值、長度為 1 的情形等。

- 若題目允許或要求使用其他語言，也可提供 Python/TS/Java 的相同策略實作。

## 作者與參考

- 題目出自 LeetCode: https://leetcode.com/problems/count-partitions-with-even-sum-difference/

