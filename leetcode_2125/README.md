# LeetCode 2125: 銀行中的雷射束數量

> 解決 LeetCode 每日挑戰問題 - 計算銀行安全系統中的雷射束數量

## 問題描述

銀行內部安裝了防盜安全設備。給定一個 0 索引的二進位字串陣列 `bank`，表示銀行的平面圖，這是一個 `m x n` 的二維矩陣。

- `bank[i]` 表示第 `i` 行，由 `'0'` 和 `'1'` 組成
- `'0'` 表示單元格為空
- `'1'` 表示單元格安裝了安全設備

### 雷射束形成條件

如果滿足以下**兩個條件**，則在兩個安全設備之間存在雷射束：

1. **不同行**：兩個設備位於兩個不同的行 `r1` 和 `r2`，其中 `r1 < r2`
2. **中間無設備**：對於 `r1 < i < r2` 的每一行 `i`，該行中都**沒有**安全設備

雷射束是獨立的，即一條雷射束不會干擾或與其他雷射束合併。

**目標**：返回銀行中雷射束的總數。

### 範例

**範例 1:**

```
輸入: bank = ["011001","000000","010100","001000"]
輸出: 8
解釋:
  第 0 行有 3 個設備
  第 1 行沒有設備（跳過）
  第 2 行有 2 個設備
  第 3 行有 1 個設備
  
  雷射束計算：
  - 第 0 行與第 2 行之間: 3 × 2 = 6 條雷射束
  - 第 2 行與第 3 行之間: 2 × 1 = 2 條雷射束
  總計: 6 + 2 = 8
```

**範例 2:**

```
輸入: bank = ["000","111","000"]
輸出: 0
解釋: 只有一行有設備，無法形成雷射束
```

## 解法說明

### 核心思路

這個問題的關鍵在於理解**雷射束只在相鄰的「有設備的行」之間產生**。中間的空行（沒有設備的行）會被自動跳過。

### 演算法步驟

1. **初始化變數**
   - `laser`: 記錄雷射束總數
   - `prevcount`: 記錄前一個有設備的行的設備數量
   - 初始時 `prevcount = 0`（因為還沒有前一行）

2. **遍歷每一行**
   - 計算當前行的設備數量 `currcount`
   - 遍歷該行的每個字元，統計 `'1'` 的數量

3. **計算雷射束**
   - 如果當前行有設備（`currcount > 0`）：
     - 雷射束數量增加 `prevcount × currcount`
     - 更新 `prevcount = currcount`（為下一次計算做準備）
   - 如果當前行沒有設備，直接跳過（不更新 `prevcount`）

4. **返回結果**
   - 返回累計的雷射束總數

### 為什麼這個方法有效？

- **相鄰有設備行**：因為中間沒有設備的行會被跳過，所以 `prevcount` 始終保存的是「上一個有設備的行」的設備數量
- **乘法原理**：兩行之間的雷射束數量等於兩行設備數量的乘積（每個設備都會與另一行的每個設備形成一條雷射束）
- **累加計算**：每次找到新的有設備行時，計算與前一個有設備行之間的雷射束，並累加到總數中

### 複雜度分析

- **時間複雜度**: `O(m × n)`
  - `m` 是行數
  - `n` 是列數
  - 需要遍歷所有單元格一次

- **空間複雜度**: `O(1)`
  - 只使用固定數量的變數（`laser`, `prevcount`, `currcount`）
  - 不需要額外的資料結構

### 範例追蹤

以 `bank = ["011001","000000","010100","001000"]` 為例：

| 行 | 字串 | 設備數 | prevcount | 雷射束計算 | laser 累計 |
|---|------|--------|-----------|-----------|-----------|
| 0 | 011001 | 3 | 0 | 0 × 3 = 0 | 0 |
| 1 | 000000 | 0 | 3 | - (跳過) | 0 |
| 2 | 010100 | 2 | 3 | 3 × 2 = 6 | 6 |
| 3 | 001000 | 1 | 2 | 2 × 1 = 2 | 8 |

最終結果：**8 條雷射束**

## 專案結構

```
leetcode_2125/
├── leetcode_2125.sln          # Visual Studio 解決方案檔案
└── leetcode_2125/
    ├── leetcode_2125.csproj   # C# 專案檔案
    └── Program.cs             # 主程式（包含解法實作）
```

## 執行方式

### 前置需求

- [.NET 8.0 SDK](https://dotnet.microsoft.com/download) 或更新版本

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run --project leetcode_2125
```

### 預期輸出

```
測試案例 1: 8 (預期: 8)
測試案例 2: 0 (預期: 0)
測試案例 3: 0 (預期: 0)
```

## 程式碼實作

主要方法簽名：

```csharp
public int NumberOfBeams(string[] bank)
```

核心邏輯片段：

```csharp
for(int i = 0; i < m; i++)
{
    int currcount = 0;
    
    // 計算當前行的設備數量
    for(int j = 0; j < n; j++)
    {
        if (bank[i][j] == '1')
        {
            currcount++;
        }
    }

    // 如果當前行有設備，計算雷射束
    if (currcount > 0)
    {
        laser += prevcount * currcount;
        prevcount = currcount;
    }
}
```

## 測試案例

專案包含三個測試案例，涵蓋不同情境：

1. **標準情況**：多行有設備，中間有空行
2. **單行情況**：只有一行有設備，無法形成雷射束
3. **間隔情況**：有設備的行之間有空行

## 相關連結

- [LeetCode 問題頁面 (英文)](https://leetcode.com/problems/number-of-laser-beams-in-a-bank/)
- [LeetCode 問題頁面 (中文)](https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/)

## 關鍵概念

- 陣列遍歷
- 字元處理
- 計數邏輯
- 乘法原理
- 狀態追蹤

---

**難度**: Medium  
**主題**: Array, String, Math  
**每日挑戰日期**: 2025-10-27
