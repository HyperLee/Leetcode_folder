# LeetCode 3453 - 分割正方形 I

一個使用二分查找解決正方形分割問題的 C# 實作。

## 題目描述

給定一個 2D 整數陣列 `squares`，每個元素 `squares[i] = [xi, yi, li]` 表示一個與 x 軸平行的正方形，其中：
- `xi`, `yi` 是正方形左下角的座標
- `li` 是正方形的邊長

**目標**：找出一條水平線的 y 座標值，使得該線上方和下方的所有正方形面積總和相等。

**約束條件**：
- 1 ≤ squares.length ≤ 10⁵
- 0 ≤ xi, yi, li ≤ 10⁹
- 答案誤差在 10⁻⁵ 以內視為正確
- 正方形可能重疊，重疊面積需分別計算

**題目連結**：
- [LeetCode (英文)](https://leetcode.com/problems/separate-squares-i/description/?envType=daily-question&envId=2026-01-13)
- [LeetCode (中文)](https://leetcode.cn/problems/separate-squares-i/description/?envType=daily-question&envId=2026-01-13)

## 解題思路

### 核心概念

這個問題的關鍵觀察是：隨著水平分割線 y 的增大，線下方的面積總和是單調不減的。這個性質使我們可以使用二分查找來找到最佳的分割位置。

### 數學公式

設所有正方形的總面積為：

$$\text{totalArea} = \sum_{i=0}^{n-1} l_i^2$$

我們需要找到分割線 y，使得 y 以下的面積 $\text{area}_y$ 滿足：

$$\text{area}_y \times 2 = \text{totalArea}$$

即：

$$\text{area}_y = \frac{\text{totalArea}}{2}$$

### 單調性分析

對於給定的水平線 y，如果正方形 $(x_i, y_i, l_i)$ 滿足 $y_i < y$，則該正方形在 y 以下的面積為：

$$\text{area} = l_i \times \min(y - y_i, l_i)$$

這個公式考慮了兩種情況：
- 當 $y - y_i \geq l_i$ 時：整個正方形都在線下方，面積為 $l_i^2$
- 當 $y - y_i < l_i$ 時：只有部分在線下方，面積為 $l_i \times (y - y_i)$

### 二分查找策略

1. **搜索範圍**：$[\,0, \max_y\,]$，其中 $\max_y = \max(y_i + l_i)$ 是所有正方形頂部的最高點
2. **查找目標**：找到最小的 y 值，使得 $\text{area}_y \times 2 \geq \text{totalArea}$
3. **精度控制**：當搜索區間 $\text{right} - \text{left} \leq 10^{-5}$ 時停止

### 複雜度分析

- **時間複雜度**：$O(n \times \log(L \times 10^5))$
  - $n$ 是正方形數量
  - $L$ 是最大 y 座標（最多 $10^9$）
  - 二分查找次數：$\log_2(10^{14}) \approx 47$ 次
  - 每次二分需要 $O(n)$ 時間計算面積

- **空間複雜度**：$O(1)$
  - 只使用常數額外空間

## 演算法流程

### 步驟說明

1. **初始化階段**
   ```
   計算 totalArea = Σ(li²)
   計算 max_y = max(yi + li)
   設定搜索範圍 left = 0, right = max_y
   ```

2. **二分查找**
   ```
   while |right - left| > 10⁻⁵:
       mid = (left + right) / 2
       if Check(mid):  // mid 以下面積 >= totalArea / 2
           right = mid  // 嘗試更小的 y
       else:
           left = mid   // 需要更大的 y
   return right
   ```

3. **Check 函式**
   ```
   area_y = 0
   for each square (xi, yi, li):
       if yi < limit_y:
           area_y += li × min(limit_y - yi, li)
   return area_y >= totalArea / 2
   ```

### Check 函式詳細說明

Check 函式的核心是計算「水平分割線以下的面積」。對於每個正方形，根據其與分割線的相對位置，有三種情況：

#### 情況 1：正方形完全在線上方
當 $y_i \geq \text{limit\_y}$ 時，正方形完全在分割線上方，貢獻面積為 0。

```
                              ↑
  yi+li →     +-------+       | 正方形完全
              |  ▓▓   |       | 在線上方
     yi →     +-------+       | (不計算面積)
                              ↓
    limit_y →  ────────────────
```

#### 情況 2：正方形完全在線下方
當 $y_i < \text{limit\_y}$ 且 $\text{limit\_y} - y_i \geq l_i$ 時，整個正方形都在分割線下方。

```
              limit_y →  ────────────────
                                        ↑
     yi+li →     +-------+              |
                 |  ▓▓   |              | 高度 = li
        yi →     +-------+              | (整個正方形)
                                        ↓
                 面積 = li × li = li²
```

**計算公式**：
$$\text{height} = \min(\text{limit\_y} - y_i, l_i) = l_i$$
$$\text{area} = l_i \times l_i = l_i^2$$

#### 情況 3：正方形部分在線下方
當 $y_i < \text{limit\_y} < y_i + l_i$ 時，只有部分正方形在分割線下方。

```
     yi+li →     +-------+
                 |       |
                 |  ▓▓   |  ← 這部分在線上方
              limit_y →  ────────────────
                 |  ▓▓   |              ↑
        yi →     +-------+              | 高度 = limit_y - yi
                                        ↓
                 面積 = li × (limit_y - yi)
```

**計算公式**：
$$\text{height} = \min(\text{limit\_y} - y_i, l_i) = \text{limit\_y} - y_i$$
$$\text{area} = l_i \times (\text{limit\_y} - y_i)$$

#### 具體計算範例

假設有正方形 `[x=0, y=1, l=3]`，我們測試不同的 `limit_y` 值：

**範例 1：limit_y = 0.5**（正方形完全在線上方）
```
  4 +-------+
    |       |
  3 |       |
    |       |
  2 +-------+
    |  ▓▓   |
  1 +-------+  ← yi = 1
limit_y → ─────  ← 0.5
  0 
```
- 條件：$y_i = 1 > 0.5$，不計算面積
- 貢獻：0

**範例 2：limit_y = 2.5**（正方形部分在線下方）
```
  4 +-------+
    |  ▓▓   |  ← 這部分在線上方
  3 |  ▓▓   |
limit_y → ─────  ← 2.5
  2 |  ▓▓   |  ← 這部分在線下方
    |  ▓▓   |     高度 = 2.5 - 1 = 1.5
  1 +-------+  ← yi = 1
  0 
```
- 條件：$y_i = 1 < 2.5 < y_i + l_i = 4$
- 高度：$\min(2.5 - 1, 3) = \min(1.5, 3) = 1.5$
- 貢獻：$3 \times 1.5 = 4.5$

**範例 3：limit_y = 5**（正方形完全在線下方）
```
limit_y → ─────  ← 5
  4 +-------+
    |  ▓▓   |
  3 |  ▓▓   |  ← 整個正方形都在線下方
    |  ▓▓   |     高度 = 3
  2 |  ▓▓   |
    |  ▓▓   |
  1 +-------+  ← yi = 1
  0 
```
- 條件：$y_i = 1 < 5$ 且 $5 - 1 = 4 \geq l_i = 3$
- 高度：$\min(5 - 1, 3) = \min(4, 3) = 3$
- 貢獻：$3 \times 3 = 9$

#### 為什麼使用 min() 函式？

公式 `li × min(limit_y - yi, li)` 中的 `min()` 確保我們不會計算超過正方形實際高度的面積：

- 當分割線很高時（$\text{limit\_y} - y_i > l_i$），我們只計算正方形的實際高度 $l_i$
- 當分割線在正方形內部時（$\text{limit\_y} - y_i < l_i$），我們只計算到分割線為止的高度 $\text{limit\_y} - y_i$

這個設計讓我們用**一個統一的公式**處理所有情況，不需要分別判斷正方形是完全在線下還是部分在線下。

## 範例演示

### 範例 1

**輸入**：
```
squares = [[0,0,2], [2,0,2]]
```

**視覺化**：
```
  4 +-------+-------+
    |       |       |
  3 |       |       |
    |       |       |
  2 +-------+-------+ ← 分割線 y = 2
    |   ▓▓  |  ▓▓   |
  1 |   ▓▓  |  ▓▓   |
    |   ▓▓  |  ▓▓   |
  0 +-------+-------+
    0   1   2   3   4
```

**計算過程**：
1. 總面積：$2^2 + 2^2 = 8$
2. 目標：找到 y 使得上下各 4
3. 二分查找過程：
   - 初始：left = 0, right = 4
   - mid = 2：下方面積 = $2 \times 2 + 2 \times 2 = 8$ ✗（太大）
   - mid = 1：下方面積 = $2 \times 1 + 2 \times 1 = 4$ ✓
   - ...繼續收斂到 y = 2

**輸出**：`2.00000`

### 範例 2

**輸入**：
```
squares = [[0,0,3], [0,3,3]]
```

**視覺化**：
```
  6 +-------+
    |  ▓▓   |
  5 |  ▓▓   |
    |  ▓▓   |
  4 +-------+
  3 +-------+ ← 分割線 y = 3
    |  ▓▓   |
  2 |  ▓▓   |
    |  ▓▓   |
  1 |  ▓▓   |
    |  ▓▓   |
  0 +-------+
    0   1   2   3
```

**計算過程**：
1. 總面積：$3^2 + 3^2 = 18$
2. 目標：找到 y 使得上下各 9
3. 第一個正方形：[0,0,3] 在 y=3 以下的面積 = $3 \times 3 = 9$
4. 第二個正方形：[0,3,3] 在 y=3 以下的面積 = $0$

**輸出**：`3.00000`

### 範例 3

**輸入**：
```
squares = [[0,0,4], [4,0,2]]
```

**視覺化**：
```
  4 +-------+---+
    |  ▓▓   |▓▓ |
  3 |  ▓▓   +---+
    |  ▓▓   | ← y ≈ 2.828
  2 |  ▓▓   |
    |  ▓▓   |
  1 |  ▓▓   |
    |  ▓▓   |
  0 +-------+
    0   1   2   3   4   5   6
```

**計算過程**：
1. 總面積：$4^2 + 2^2 = 20$
2. 目標：找到 y 使得上下各 10
3. 設分割線為 y = 2.828：
   - 正方形1：$4 \times 2.828 = 11.312$
   - 正方形2：$2 \times 2 = 4$
   - 但這樣會超過，需要精確計算
4. 實際上 y ≈ 2.82843 時：
   - 下方面積 = $4 \times 2.82843 + 2 \times 2 \approx 15.31372$
   - (這個值會透過二分查找精確找到)

**輸出**：`2.82843`

## 實作細節

### 精度考量

由於計算涉及浮點數運算，我們需要：
- 使用 `double` 型別以保證精度
- 設定 `eps = 1e-5` 作為二分查找的終止條件
- 確保誤差在題目要求範圍內

### 邊界情況

- 所有正方形都在同一高度：分割線正好在頂部
- 正方形完全重疊：需要分別計算每個正方形的面積
- 只有一個正方形：分割線在正方形中間

## 執行專案

### 環境需求

- .NET 10.0 或更高版本
- C# 14

### 建構與執行

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run
```

### 測試輸出

```
測試案例 1: 2.0000000000000004
預期結果: 2.00000

測試案例 2: 3
預期結果: 3.00000

測試案例 3: 2.8284270763397217
預期結果: 2.82843
```

---

## 方法二：掃描線解法

### 掃描線核心概念

掃描線演算法透過從下往上掃描，追蹤每個高度位置的覆蓋寬度，直接計算出精確的分割線位置，避免了二分查找的多次迭代。

### 數學推導

設當前經過正方形上/下邊界的掃描線為 $y = y'$，此時掃描線以下的覆蓋面積為 $\text{area}$；向上移動時下一個需要經過的正方形上/下邊界的掃描線為 $y = y''$，此時被正方形覆蓋的底邊長之和為 $\text{width}$，則此時在掃描線 $y = y''$ 以下覆蓋的面積之和為：

$$\text{area} + \text{width} \times (y'' - y')$$

當滿足以下條件時：

$$\text{area} < \frac{\text{totalArea}}{2}$$

$$\text{area} + \text{width} \times (y'' - y') \geq \frac{\text{totalArea}}{2}$$

則可以知道目標值 $y$ 一定處於區間 $[y', y'']$。

由於兩個掃描線之間的被覆蓋區域中所有的矩形高度相同，我們可以直接求出目標值 $y$ 為：

$$y = y' + \frac{\frac{\text{totalArea}}{2} - \text{area}}{\text{width}} = y' + \frac{\text{totalArea} - 2 \times \text{area}}{2 \times \text{width}}$$

### 事件驅動的掃描線

掃描線演算法使用「事件」來追蹤正方形的邊界：

| 事件類型 | y 座標 | delta | 說明 |
| --------- | -------- | ------- | ------ |
| 開始事件 | $y_i$ | +1 | 進入正方形區域，增加覆蓋寬度 |
| 結束事件 | $y_i + l_i$ | -1 | 離開正方形區域，減少覆蓋寬度 |

### 掃描線演算法流程

```text
1. 計算總面積 totalArea = Σ(li²)
2. 建立事件列表：每個正方形產生兩個事件
   - 下邊界事件 (yi, li, +1)
   - 上邊界事件 (yi + li, li, -1)
3. 按 y 座標排序所有事件
4. 初始化：coveredWidth = 0, currArea = 0, prevHeight = 0
5. 遍歷每個事件：
   - 計算新增面積 = coveredWidth × (y - prevHeight)
   - 如果 currArea + 新增面積 >= totalArea / 2：
     - 返回 prevHeight + (totalArea/2 - currArea) / coveredWidth
   - 更新 coveredWidth += delta × l
   - 更新 currArea += 新增面積
   - 更新 prevHeight = y
```

### 視覺化範例

以 `squares = [[0,0,2], [1,1,2]]` 為例：

```text
事件列表（排序後）：
y=0: 開始事件，邊長=2，delta=+1
y=1: 開始事件，邊長=2，delta=+1
y=2: 結束事件，邊長=2，delta=-1
y=3: 結束事件，邊長=2，delta=-1

掃描過程：
  3 +-------+-------+
    |       |  ▓▓   |  ← y=3: 結束事件（第二個正方形）
  2 +-------+  ▓▓   |  ← y=2: 結束事件（第一個正方形）
    |   ▓▓  |  ▓▓   |
  1 |   ▓▓  +-------+  ← y=1: 開始事件（第二個正方形）
    |   ▓▓  |          width 從 2 變成 4
  0 +-------+          ← y=0: 開始事件（第一個正方形）
    0   1   2   3      width 從 0 變成 2
```

### 掃描線複雜度分析

- **時間複雜度**：$O(n \log n)$
  - 建立事件列表：$O(n)$
  - 排序事件：$O(n \log n)$
  - 遍歷事件：$O(n)$

- **空間複雜度**：$O(n)$
  - 事件列表儲存 $2n$ 個事件

### 與二分查找的比較

| 特性 | 二分查找 | 掃描線 |
| ------ | --------- | -------- |
| 時間複雜度 | $O(n \times \log(L \times 10^5))$ | $O(n \log n)$ |
| 空間複雜度 | $O(1)$ | $O(n)$ |
| 精度控制 | 需要設定 eps | 直接計算精確值 |
| 實作難度 | 較簡單 | 中等 |

---

## 相關主題

- 二分查找 (Binary Search)
- 掃描線演算法 (Sweep Line Algorithm)
- 幾何計算 (Computational Geometry)
- 浮點數精度 (Floating Point Precision)
- 單調性 (Monotonicity)
- 事件驅動處理 (Event-Driven Processing)

## 參考資料

- [二分查找詳解](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)
- [LeetCode 官方題解](https://leetcode.com/problems/separate-squares-i/)
- [掃描線解法圖示說明](https://oi-wiki.org/geometry/scanning/)
