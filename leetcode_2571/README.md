# Minimum Operations to Reduce Binary Number to Zero

[![.NET](https://img.shields.io/badge/.NET-10.0-512BD4?style=flat-square&logo=dotnet)](https://dotnet.microsoft.com/)
[![C#](https://img.shields.io/badge/C%23-14-239120?style=flat-square&logo=csharp)](https://docs.microsoft.com/dotnet/csharp/)
[![License](https://img.shields.io/badge/License-MIT-yellow?style=flat-square)](LICENSE)

經典演算法面試題：使用二進位位元操作，計算將正整數變為零的最少操作次數。

## 題目描述

給定一個正整數 `n`，每次操作可以**加或減** $2^i$（其中 $i \geq 0$），求將 `n` 變為 `0` 的**最少操作次數**。

### 範例

| 輸入 | 輸出 | 說明 |
| ---- | ---- | ---- |
| `n = 7` | `2` | `7 (111)` → `+1` → `8 (1000)` → `-8` → `0` |
| `n = 15` | `2` | `15 (1111)` → `+1` → `16 (10000)` → `-16` → `0` |
| `n = 39` | `3` | `39 (100111)` → `+1` → `40 (101000)` → `-8` → `32` → `-32` → `0` |

## 解題思路

### 核心概念：二進位制位元處理

這道題的關鍵在於理解**二進位表示**與**進位機制**。

### 為什麼從二進位角度思考？

每次操作只能加減 $2^i$，這正好對應二進位制中的某一位。例如：

- $+1$ 或 $-1$ 影響最低位（第 0 位）
- $+2$ 或 $-2$ 影響第 1 位
- $+4$ 或 $-4$ 影響第 2 位

因此，**每個二進位的 `1` 都需要被消除**，問題轉化為：如何用最少的操作消除所有的 `1`？

### 解題策略

從**低位到高位**逐位處理，維護一個「進位」狀態：

```text
當前位值 = 原位值 + 進位
```

| 當前位值 | 處理方式 | 操作數 | 進位 |
| -------- | -------- | ------ | ---- |
| `0` | 不需要操作 | +0 | 0 |
| `1`（下一位是 `0`） | 減法消掉 | +1 | 0 |
| `1`（下一位是 `1`） | 加法產生進位 | +1 | 1 |
| `2` | 直接進位 | +0 | 1 |

### 為什麼連續的 `1` 要用加法？

這是本題最關鍵的優化點。

考慮 `n = 7`（二進位 `111`）：

**方法一：逐位減法** ❌

```text
111 → -1 → 110 → -2 → 100 → -4 → 000
需要 3 次操作
```

**方法二：加法進位** ✅

```text
111 → +1 → 1000 → -8 → 0000
只需要 2 次操作
```

> [!TIP]
> 當遇到連續的 `1` 時，使用加法將它們「合併」成一個更高位的 `1`，然後一次減掉，比逐個減掉更有效率。

## 演算法流程

### 流程圖

```text
開始
  ↓
初始化: operations = 0, carry = 0
  ↓
┌─────────────────────────────────────┐
│ while (n > 0 || carry > 0)          │
│   ↓                                 │
│   currentBit = (n & 1) + carry      │
│   ↓                                 │
│   判斷 currentBit 的值              │
│   ├─ 0: carry = 0                   │
│   ├─ 1 且下一位是 1:                │
│   │     operations++, carry = 1     │
│   ├─ 1 且下一位是 0:                │
│   │     operations++, carry = 0     │
│   └─ 2: carry = 1                   │
│   ↓                                 │
│   n = n >> 1 (右移一位)             │
└─────────────────────────────────────┘
  ↓
回傳 operations
```

## 核心程式碼解析

### `currentBit = (n & 1) + carry` 詳解

這是整個演算法中最關鍵的一行程式碼，很多人會誤以為它在做「int 轉二進制」的轉換，但**實際上不是**。

#### 這行程式碼在做什麼？

它是在**讀取二進制的某一位元並進行計算**。

#### 分解說明

```csharp
int currentBit = (n & 1) + carry;
```

**1. `n & 1` - 位元 AND 運算**

- `&` 是位元運算子，會對兩個數字的每個位元進行 AND 操作
- `1` 的二進制是 `...00001`（最低位是 1，其他都是 0）
- **`n & 1` 的效果：只保留 n 的最低位元，其他位元都變成 0**
- 結果只會是 `0` 或 `1`

**2. `+ carry` - 加上進位**

- `carry` 是從前一個位元傳來的進位值（0 或 1）
- 將當前位元值與進位相加

**3. `currentBit` - 當前位元的總值**

- 可能是 `0`（無位元無進位）
- 可能是 `1`（有位元或有進位）
- 可能是 `2`（有位元且有進位）

#### 實際運作範例

假設 `n = 7`，二進制是 `111`：

**第一次迭代（處理最低位）：**
```text
n = 7 (二進制: 111)
n & 1 = 111 & 001 = 001 = 1
carry = 0
currentBit = 1 + 0 = 1
```

**第二次迭代（n 右移後變成 3）：**
```text
n = 3 (二進制: 011)  
n & 1 = 011 & 001 = 001 = 1
carry = 1（假設上一輪產生進位）
currentBit = 1 + 1 = 2
```

#### 位元 AND 運算原理

| n 的值 | n 的二進制 | n & 1 | 結果 | 說明 |
|--------|-----------|-------|------|------|
| 7 | `111` | `111 & 001` | 1 | 最低位是 1 |
| 6 | `110` | `110 & 001` | 0 | 最低位是 0 |
| 5 | `101` | `101 & 001` | 1 | 最低位是 1 |
| 4 | `100` | `100 & 001` | 0 | 最低位是 0 |

#### 重點整理

- ❌ **不是轉換**：整個 int 一直都以二進制形式存在記憶體中
- ✅ **是提取**：`n & 1` 提取最低位元的值（0 或 1）
- ✅ **是計算**：加上進位後，得到這一位需要處理的總值

> [!NOTE]
> 如果要真正將 int 轉換成二進制字串，應該使用 `Convert.ToString(n, 2)`（如本專案程式碼第 165 行所示）。

## 詳細範例演示

### 範例 1：`n = 7` (二進位 `111`)

| 步驟 | n (二進位) | 當前位 | 進位 | 位值 | 下一位 | 動作 | 操作數 |
| ---- | --------- | ------ | ---- | ---- | ------ | ---- | ------ |
| 1 | `111` | 1 | 0 | 1 | 1 | +1 產生進位 | 1 |
| 2 | `11` | 1 | 1 | 2 | - | 直接進位 | 1 |
| 3 | `1` | 1 | 1 | 2 | - | 直接進位 | 1 |
| 4 | `0` | 0 | 1 | 1 | 0 | -1 消掉 | 2 |

**結果：2 次操作** ✅

實際操作過程：`7` → `+1` → `8` → `-8` → `0`

#### 📝 補充說明：「位值」欄位的意義

**位值 = 當前位 + 進位**，代表在處理當前這一位時，**實際需要處理的數值**。

**逐步拆解：**

**步驟 1：** 處理最右邊的位（第 0 位）
```
n = 111（二進位）
      ↑
      正在處理這一位
```
- **當前位**：`1`（最右邊那個 1）
- **進位**：`0`（一開始沒有進位）
- **位值**：1 + 0 = `1` ← 實際要處理的值
- **下一位**：`1`（往左看，下一位也是 1）
- **決策**：因為下一位也是 1（連續的 1），所以用「+1 產生進位」的策略

**步驟 2：** 處理第 1 位
```
n = 11（右移後）
     ↑
     正在處理這一位
```
- **當前位**：`1`
- **進位**：`1`（上一步產生的進位）
- **位值**：1 + 1 = `2` ← **關鍵！** 當前位是 1，但因為有進位，實際值變成 2
- **決策**：位值是 2，不需要操作，直接把這個 2 進位到下一位

**步驟 3：** 處理第 2 位
```
n = 1（右移後）
    ↑
    正在處理這一位
```
- **當前位**：`1`
- **進位**：`1`（上一步傳來的）
- **位值**：1 + 1 = `2`
- **決策**：同樣，位值是 2，直接進位

**步驟 4：** 處理最後的進位
```
n = 0（已經處理完所有位）
```
- **當前位**：`0`（沒有位了）
- **進位**：`1`（前面累積的進位）
- **位值**：0 + 1 = `1`
- **決策**：用 `-1` 消掉這個進位 ✅

**位值決定處理策略：**

| 位值 | 含義 | 處理方式 |
|------|------|----------|
| `0` | 當前位沒有 1 要處理 | 不需要操作 |
| `1` | 有一個 1 要處理 | 需要 +1 或 -1 操作 |
| `2` | 當前位的 1 + 進位的 1 | 合併成下一位的 1（進位），不需要額外操作 |

---

### 範例 2：`n = 39` (二進位 `100111`)

| 步驟 | n (二進位) | 當前位 | 進位 | 位值 | 下一位 | 動作 | 操作數 |
| ---- | --------- | ------ | ---- | ---- | ------ | ---- | ------ |
| 1 | `100111` | 1 | 0 | 1 | 1 | +1 產生進位 | 1 |
| 2 | `10011` | 1 | 1 | 2 | - | 直接進位 | 1 |
| 3 | `1001` | 1 | 1 | 2 | - | 直接進位 | 1 |
| 4 | `100` | 0 | 1 | 1 | 0 | -1 消掉 | 2 |
| 5 | `10` | 0 | 0 | 0 | - | 無操作 | 2 |
| 6 | `1` | 1 | 0 | 1 | 0 | -1 消掉 | 3 |

**結果：3 次操作** ✅

實際操作過程：`39` → `+1` → `40` → `-8` → `32` → `-32` → `0`

---

### 範例 3：`n = 100` (二進位 `1100100`)

| 步驟 | n (二進位) | 當前位 | 進位 | 位值 | 動作 | 操作數 |
| ---- | --------- | ------ | ---- | ---- | ---- | ------ |
| 1 | `1100100` | 0 | 0 | 0 | 無操作 | 0 |
| 2 | `110010` | 0 | 0 | 0 | 無操作 | 0 |
| 3 | `11001` | 1 | 0 | 1 | 減法消掉 | 1 |
| 4 | `1100` | 0 | 0 | 0 | 無操作 | 1 |
| 5 | `110` | 0 | 0 | 0 | 無操作 | 1 |
| 6 | `11` | 1 | 0 | 1 | +1 產生進位 | 2 |
| 7 | `1` | 1 | 1 | 2 | 直接進位 | 2 |
| 8 | `0` | 0 | 1 | 1 | 減法消掉 | 3 |

**結果：3 次操作** ✅

## 時間與空間複雜度

| 複雜度 | 值 | 說明 |
| ------ | ----- | ------ |
| 時間複雜度 | $O(\log n)$ | 遍歷二進位的每一位 |
| 空間複雜度 | $O(1)$ | 只使用常數額外空間 |

---

## 解法二：Lowbit 貪心法

### 核心觀察

把 `n` 看成二進位數，較高位的位元 `1` 會受到較低位位元 `1` 的加減影響，但**最小的位元 `1`（lowbit）沒有這個約束**。因此，我們優先處理 lowbit。

### Lowbit 計算原理

```csharp
int lb = n & -n;  // 取得 n 的最低位 1 所代表的數值
```

**原理說明：**
- `-n` 是 `n` 的二補數，等於 `~n + 1`（位元取反後加 1）
- `n & -n` 的結果只會保留最低位的 1

**範例：**

| n | n (二進位) | -n (二補數) | n & -n | lowbit |
|---|-----------|-------------|--------|--------|
| 12 | `1100` | `...110100` | `100` | 4 |
| 10 | `1010` | `...110110` | `10` | 2 |
| 7 | `111` | `...111001` | `1` | 1 |

### 貪心策略

消除 lowbit 的方法只有兩種：**加上 lowbit** 或 **減去 lowbit**。

| 情況 | 策略 | 說明 |
|------|------|------|
| 有多個連續的 `1` | 加法（`n += lb`） | 透過進位一次消除多個連續 `1` |
| 單個 `1` | 減法（`n -= lb`） | 直接減掉更優 |

### 判斷連續 `1` 的方法

```csharp
if ((n & (lb << 1)) > 0)  // 檢查 lowbit 左邊一位是否也是 1
```

- `lb << 1` 將 lowbit 左移一位
- 若 `n & (lb << 1) > 0`，代表該位也是 `1`，表示有連續的 `1`

### 終止條件

```csharp
while ((n & (n - 1)) > 0)  // n 不是 2 的冪次時繼續迴圈
```

當 `n & (n - 1) == 0` 時，`n` 是 2 的冪次方（只剩一個 `1`），只需一次減法操作即可歸零。

### 演算法流程圖

```text
開始
  ↓
初始化: ans = 1（最後一次減法）
  ↓
┌─────────────────────────────────────────────┐
│ while (n & (n - 1)) > 0（n 不是 2 的冪次）   │
│   ↓                                         │
│   lb = n & -n（取得 lowbit）                │
│   ↓                                         │
│   判斷 (n & (lb << 1)) > 0？                │
│   ├─ 是（連續 1）: n += lb, ans++           │
│   └─ 否（單個 1）: n -= lb, ans++           │
└─────────────────────────────────────────────┘
  ↓
回傳 ans
```

### 詳細範例演示

#### 範例 1：`n = 7` (二進位 `111`)

| 步驟 | n (二進位) | lowbit | 下一位是 1？ | 動作 | ans |
|------|-----------|--------|-------------|------|-----|
| 初始 | `111` (7) | - | - | 初始化 ans = 1 | 1 |
| 1 | `111` (7) | 1 (`1`) | 是（`11`） | n += 1 → 8 | 2 |
| 2 | `1000` (8) | - | - | n & (n-1) = 0，結束 | 2 |

**結果：2 次操作** ✅

實際操作：`7` → `+1` → `8` → `-8` → `0`

#### 範例 2：`n = 39` (二進位 `100111`)

| 步驟 | n (二進位) | lowbit | 下一位是 1？ | 動作 | ans |
|------|-----------|--------|-------------|------|-----|
| 初始 | `100111` (39) | - | - | 初始化 ans = 1 | 1 |
| 1 | `100111` (39) | 1 (`1`) | 是（`11`） | n += 1 → 40 | 2 |
| 2 | `101000` (40) | 8 (`1000`) | 否 | n -= 8 → 32 | 3 |
| 3 | `100000` (32) | - | - | n & (n-1) = 0，結束 | 3 |

**結果：3 次操作** ✅

實際操作：`39` → `+1` → `40` → `-8` → `32` → `-32` → `0`

#### 範例 3：`n = 100` (二進位 `1100100`)

| 步驟 | n (二進位) | lowbit | 下一位是 1？ | 動作 | ans |
|------|-----------|--------|-------------|------|-----|
| 初始 | `1100100` (100) | - | - | 初始化 ans = 1 | 1 |
| 1 | `1100100` (100) | 4 (`100`) | 否 | n -= 4 → 96 | 2 |
| 2 | `1100000` (96) | 32 (`100000`) | 是（`11`） | n += 32 → 128 | 3 |
| 3 | `10000000` (128) | - | - | n & (n-1) = 0，結束 | 3 |

**結果：3 次操作** ✅

### 程式碼

```csharp
public int MinOperations2(int n)
{
    // 最終 n 會變成 2 的冪次，需要一次操作歸零
    int ans = 1;

    // 當 n & (n - 1) > 0 時，n 不是 2 的冪次（有超過一個位元 1）
    while ((n & (n - 1)) > 0)
    {
        // 取得最低位的 1（lowbit）
        int lb = n & -n;

        // 判斷是否有連續的 1：檢查 lowbit 左邊一位是否為 1
        if ((n & (lb << 1)) > 0)
        {
            // 有多個連續的 1：使用加法，可透過進位一次消除多個連續的 1
            n += lb;
        }
        else
        {
            // 單個 1：直接減掉更優
            n -= lb;
        }

        ++ans;
    }

    return ans;
}
```

### 兩種解法比較

| 特性 | 解法一（逐位處理） | 解法二（Lowbit 貪心） |
|------|-------------------|---------------------|
| 時間複雜度 | $O(\log n)$ | $O(\log n)$ |
| 空間複雜度 | $O(1)$ | $O(1)$ |
| 思路 | 從低位到高位逐位處理 | 優先處理最低位的 1 |
| 進位處理 | 手動維護 carry 變數 | 利用加減法自動進位 |
| 程式碼長度 | 較長 | 較短 |
| 直覺性 | 需理解進位機制 | 更直觀的貪心策略 |

## 快速開始

### 前置需求

- [.NET 10.0 SDK](https://dotnet.microsoft.com/download) 或更高版本

### 執行程式

```bash
# 複製專案
git clone https://github.com/HyperLee/MinimumOperationstoReduceBinaryNumbertoZero.git
cd MinimumOperationstoReduceBinaryNumbertoZero

# 建構並執行
dotnet run --project MinimumOperationstoReduceBinaryNumbertoZero
```

### 執行結果

```text
=== Minimum Operations to Reduce Binary Number to Zero ===

✅ PASS: n=1    -> 操作次數=1  | 1 (1) -> 0，操作：-1
✅ PASS: n=2    -> 操作次數=1  | 2 (10) -> 0，操作：-2
✅ PASS: n=3    -> 操作次數=2  | 3 (11) -> 4 (100) -> 0，操作：+1, -4
✅ PASS: n=7    -> 操作次數=2  | 7 (111) -> 8 (1000) -> 0，操作：+1, -8
✅ PASS: n=15   -> 操作次數=2  | 15 (1111) -> 16 (10000) -> 0，操作：+1, -16
✅ PASS: n=39   -> 操作次數=3  | 39 (100111) -> 40 (101000) -> 32 -> 0
✅ PASS: n=100  -> 操作次數=3  | 100 (1100100) 需要 3 次操作

=== 測試結果：14 通過，0 失敗 ===
```

## 程式碼使用

```csharp
using MinimumOperationstoReduceBinaryNumbertoZero;

// 計算最少操作次數
int result = Solution.MinOperations(7);
Console.WriteLine(result); // 輸出: 2
```

## 相關資源

- [位元運算技巧](https://leetcode.com/problems/sum-of-two-integers/solutions/84278/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently/)
- [二進位數學基礎](https://en.wikipedia.org/wiki/Binary_number)
- [Leetcode 2571. Minimum Operations to Reduce an Integer to 0](https://leetcode.com/problems/minimum-operations-to-reduce-an-integer-to-0/description/)
