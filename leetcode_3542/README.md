# LeetCode 3542 - 將所有元素變為 0 的最少操作次數

> **Minimum Operations to Convert All Elements to Zero**

C# 實作的 LeetCode 每日挑戰解題方案,提供兩種高效的單調堆疊解法。

## 問題描述

給定一個大小為 `n` 的陣列 `nums`,由非負整數組成。你的任務是對陣列應用一些(可能為零)操作,使所有元素變為 0。

在一次操作中,你可以選擇一個子陣列 `[i, j]`(其中 `0 <= i <= j < n`),並將該子陣列中**最小非負整數的所有出現**設為 0。

返回使陣列中所有元素變為 0 所需的**最少操作數**。

### 問題連結

- [LeetCode 英文版](https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/description/?envType=daily-question&envId=2025-11-10)
- [LeetCode 中文版](https://leetcode.cn/problems/minimum-operations-to-convert-all-elements-to-zero/description/?envType=daily-question&envId=2025-11-10)

### 範例

**範例 1:**

```text
輸入: nums = [1,2,1,2,1,2]
輸出: 4
解釋:
- 第一次操作: 選擇整個陣列 [1,2,1,2,1,2],最小值是 1,將所有 1 變成 0 → [0,2,0,2,0,2]
- 接下來需要 3 次操作分別處理被 0 分隔開的三個 2
```

**範例 2:**

```text
輸入: nums = [2,5,3,8,3]
輸出: 4
```

**範例 3:**

```text
輸入: nums = [0]
輸出: 0
解釋: 陣列已經全為 0,不需要任何操作
```

## 解法

本專案提供兩種高效的單調堆疊解法,兩者時間複雜度相同,但在空間使用上有所不同。

### 方法一: 單調遞增堆疊解法

#### 核心思路

維護一個單調遞增堆疊來追蹤當前遞增的非零元素序列。

**關鍵規律:**

1. **規律一**: 把若干相同的最小值同時變為 0,可以節省操作次數
2. **規律二**: 如果兩個相同的數之間有更小的數,則他們一定不能一起被變為 0

#### 演算法流程

1. 初始化一個空堆疊和操作計數器 `res = 0`
2. 遍歷陣列中的每個元素 `a`:
   - **彈出較大元素**: 當堆疊頂元素大於 `a` 時,持續彈出堆疊頂
     - 原因: 根據規律二,堆疊頂元素不可能和之後的元素一起操作
   - **跳過零值**: 如果 `a` 已經為 0,直接跳過
   - **新增操作**: 如果堆疊為空或堆疊頂小於 `a`
     - 將 `a` 加入堆疊
     - 操作次數 `res++`(需要新的一次操作來覆蓋 `a`)
   - **隱含處理**: 如果堆疊頂等於 `a`,不入堆疊(可在同一次操作中處理)
3. 返回 `res`

#### 實作範例

```csharp
public int MinOperations(int[] nums)
{
    var s = new List<int>(); // 單調遞增堆疊
    int res = 0; // 操作次數
    
    foreach (int a in nums)
    {
        // 彈出所有大於當前元素的堆疊頂
        while (s.Count > 0 && s[s.Count - 1] > a)
        {
            s.RemoveAt(s.Count - 1);
        }
        
        // 跳過零值
        if (a == 0)
        {
            continue;
        }
        
        // 需要新操作來處理當前元素
        if (s.Count == 0 || s[s.Count - 1] < a)
        {
            s.Add(a);
            res++;
        }
    }
    
    return res;
}
```

#### 複雜度分析

- **時間複雜度**: `O(n)` - 每個元素最多入堆疊和出堆疊各一次
- **空間複雜度**: `O(n)` - 堆疊最壞情況下儲存所有元素(遞增序列)

---

### 方法二: 優化的單調堆疊解法(空間優化版)

#### 核心思路

結合**分治思想**和**單調堆疊**,直接使用輸入陣列作為堆疊,達到空間優化的目的。

**分治角度理解:**

1. 先通過一次操作,把陣列的最小值都變成 0
2. 此時陣列被這些 0 劃分成若干段,後續操作只能在每段內部進行
3. 每一段是規模更小的子問題,遞迴處理

**實作策略:**

- 從左往右遍歷,只在「**必須要操作**」的時候才將答案加一
- **必須操作的判斷**: 當某個元素左右兩側都有比它小的數時

#### 演算法實作步驟

1. 初始化 `res = 0`(記錄必須操作次數)和 `top = -1`(堆疊頂索引)
2. 遍歷陣列中的每個元素 `a`:
   - **處理必須操作的元素**: 當 `nums[top] > a` 時
     - 說明堆疊頂左邊有更小的數(堆疊倒數第二個元素)
     - 右邊也有更小的數(當前元素 `a`)
     - 因此堆疊頂必須單獨操作: `top--`, `res++`
   - **避免重複入堆疊**: 如果 `a == nums[top]`
     - 可在同一次操作中處理,無需入堆疊
     - 這保證了堆疊中沒有重複元素,形成嚴格遞增堆疊
   - **入堆疊**: 否則 `nums[++top] = a`
3. 返回 `res + top + (nums[0] > 0 ? 1 : 0)`
   - `res`: 遍歷過程中必須操作的次數
   - `top + 1`: 堆疊中剩餘元素的數量(嚴格遞增序列,每個都需要操作)
   - 減去 `1` 如果 `nums[0] == 0`(第一個元素為 0 則不需要初始操作)

#### 程式碼實作

```csharp
public int MinOperations2(int[] nums)
{
    int res = 0;
    int top = -1; // 把 nums 當作堆疊使用
    
    foreach (int a in nums)
    {
        // 堆疊頂左右兩側都有更小的數,必須操作
        while (top >= 0 && nums[top] > a)
        {
            top--;
            res++;
        }
        
        // 避免重複元素入堆疊(可在同一次操作中處理)
        if (top < 0 || a != nums[top])
        {
            nums[++top] = a;
        }
    }
    
    // 堆疊中剩餘的嚴格遞增元素都需要操作
    return res + top + (nums[0] > 0 ? 1 : 0);
}
```

#### 效能分析

- **時間複雜度**: `O(n)` - 每個元素最多入堆疊和出堆疊各一次
- **空間複雜度**: `O(1)` - 直接使用輸入陣列作為堆疊,不需要額外空間

---

## 兩種方法的詳細比較

| 比較項目 | 方法一: 單調堆疊 | 方法二: 空間優化單調堆疊 |
|---------|----------------|---------------------|
| **資料結構** | `List<int>` 作為獨立堆疊 | 直接使用 `nums` 陣列作為堆疊 |
| **空間複雜度** | `O(n)` - 需要額外堆疊空間 | `O(1)` - 原地操作 |
| **時間複雜度** | `O(n)` | `O(n)` |
| **程式碼可讀性** | 較直觀,堆疊操作清晰 | 需要理解 `top` 索引概念 |
| **是否修改輸入** | 否 - 不修改原始陣列 | 是 - 會修改原始陣列 |
| **核心思想** | 單純的單調堆疊維護 | 分治思想 + 單調堆疊 |
| **彈出時的處理** | 僅彈出堆疊,不增加計數 | 彈出時 `res++`(記錄必須操作) |
| **最終計算** | 直接返回 `res` | 返回 `res + top + 調整值` |
| **適用場景** | 不能修改輸入陣列的情況 | 追求極致空間效率 |

### 演算法核心差異

雖然兩種方法都使用單調堆疊,但計數邏輯不同:

**方法一** 的計數時機:

- 當新元素需要入堆疊時(表示需要新的操作)才 `res++`
- 最終 `res` 就是答案

**方法二** 的計數時機:

- 當堆疊頂被彈出時(表示該元素必須單獨操作)才 `res++`
- 最終需要加上堆疊中剩餘元素的數量

### 詳細執行範例: nums = [1,2,3,2,1]

#### 方法一執行過程

| 步驟 | 當前元素 | 堆疊操作 | 堆疊狀態 | res | 說明 |
|-----|---------|---------|---------|-----|------|
| 1 | 1 | 入堆疊 | [1] | 1 | 堆疊空,1 入堆疊 |
| 2 | 2 | 入堆疊 | [1,2] | 2 | 1 < 2,入堆疊 |
| 3 | 3 | 入堆疊 | [1,2,3] | 3 | 2 < 3,入堆疊 |
| 4 | 2 | 彈出 3 | [1,2] | 3 | 3 > 2,彈出;2 = 堆疊頂,不入堆疊 |
| 5 | 1 | 彈出 2 | [1] | 3 | 2 > 1,彈出;1 = 堆疊頂,不入堆疊 |

**結果**: `res = 3`

#### 方法二執行過程

| 步驟 | 當前元素 | 堆疊操作 | 堆疊狀態 | res | 說明 |
|-----|---------|---------|---------|-----|------|
| 1 | 1 | 入堆疊 | [1] (top=0) | 0 | 堆疊空,1 入堆疊 |
| 2 | 2 | 入堆疊 | [1,2] (top=1) | 0 | 1 < 2,入堆疊 |
| 3 | 3 | 入堆疊 | [1,2,3] (top=2) | 0 | 2 < 3,入堆疊 |
| 4 | 2 | 彈出 3,res++ | [1,2] (top=1) | 1 | 3 > 2,彈出 3 並 res++;2 = 堆疊頂,不入堆疊 |
| 5 | 1 | 彈出 2,res++ | [1] (top=0) | 2 | 2 > 1,彈出 2 並 res++;1 = 堆疊頂,不入堆疊 |

**結果**: `res + top + (nums[0] > 0 ? 1 : 0) = 2 + 0 + 1 = 3`

### 為什麼方法二需要加上 `top + 1`?

因為方法二只在彈出時才計數,而堆疊中剩餘的遞增序列(每個元素都需要操作一次)還沒有被計算。例如上面的範例中,堆疊最後剩下 `[1]`,還需要 1 次操作將它變為 0。

### 選擇建議

- ✅ **方法一**: 適合 LeetCode 提交、程式碼審查,或需要保持輸入不變的場景
- ✅ **方法二**: 適合追求極致效能、記憶體受限的環境,或面試中展示優化能力

---

## 專案結構

```text
leetcode_3542/
├── leetcode_3542.sln          # Visual Studio 解決方案檔
├── README.md                   # 本文件
└── leetcode_3542/
    ├── leetcode_3542.csproj   # C# 專案檔
    └── Program.cs              # 主程式(包含兩種解法)
```

## 執行方式

### 先決條件

- .NET 8.0 或更高版本
- Visual Studio 2022 或 Visual Studio Code

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run
```

### 執行結果

程式會執行多組測試案例並顯示兩種方法的結果:

```console
測試案例 1: [1, 2, 1, 2, 1, 2]
方法一結果: 4
方法二結果: 4
預期結果: 4

測試案例 2: [2, 5, 3, 8, 3]
方法一結果: 4
方法二結果: 4
預期結果: 4

...
```

## 核心概念與原理

### 單調堆疊 (Monotonic Stack)

單調堆疊是一種特殊的堆疊資料結構,維護元素的單調性(遞增或遞減):

- **單調遞增堆疊**: 從堆疊底到堆疊頂,元素嚴格遞增
- **單調遞減堆疊**: 從堆疊底到堆疊頂,元素嚴格遞減

**常見應用場景:**

- 尋找下一個更大/更小的元素
- 計算矩形面積(如最大矩形、直方圖中最大矩形)
- 區間問題(如本題的子陣列操作)

### 為什麼單調堆疊適合此題?

1. **維護遞增序列**: 遞增的元素可以在不同的操作中處理
2. **偵測必須操作的元素**: 當遇到更小的元素時,堆疊頂左右兩側都有更小的數
3. **避免重複計算**: 相同元素可以在同一次操作中處理,無需重複入堆疊

## 測試案例說明

| 測試案例 | 輸入 | 輸出 | 特性 |
|---------|------|------|------|
| 1 | `[1,2,1,2,1,2]` | 4 | 交替模式,被最小值分隔 |
| 2 | `[2,5,3,8,3]` | 4 | 混合遞增遞減 |
| 3 | `[0]` | 0 | 已全為零 |
| 4 | `[1,2,3,2,1]` | 3 | 山峰形狀 |
| 5 | `[5,4,3,2,1]` | 5 | 完全遞減(最壞情況) |
| 6 | `[1,1,1,1]` | 1 | 所有元素相同 |

## 複雜度詳細分析

### 時間複雜度: O(n)

雖然有巢狀迴圈(外層 `foreach` + 內層 `while`),但時間複雜度仍是 `O(n)`:

- 每個元素**最多入堆疊一次**
- 每個元素**最多出堆疊一次**
- 總操作次數 ≤ 2n,因此是 `O(n)`

### 空間複雜度

- **方法一**: `O(n)` - 最壞情況(完全遞增陣列)堆疊儲存所有元素
- **方法二**: `O(1)` - 僅使用常數個額外變數

---

## 學習重點

通過這道題,你可以學習到:

1. ✅ 單調堆疊的實作與應用
2. ✅ 分治思想在陣列問題中的運用
3. ✅ 空間優化技巧(原地演算法)
4. ✅ 複雜度分析(特別是分攤分析)
5. ✅ 問題建模與規律發現能力

## 參考資料

- [LeetCode 官方解答](https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/solutions/)
- [單調堆疊詳解](https://oi-wiki.org/ds/monotonous-stack/)

---

**作者**: [HyperLee](https://github.com/HyperLee)  
**最後更新**: 2025年11月10日
