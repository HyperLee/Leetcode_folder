我先建立並標記待辦項目（要開始的工作），接著提供 `MinOperations` 的詳細流程與範例說明，最後會把該待辦標為已完成。現在我先寫入待辦清單並標記為「進行中」。 

已建立 2 個待辦事項

已完成 (1/2) *撰寫 MinOperations 詳細說明*

## 下面我會詳細說明 `MinOperations`（方法一）的流程、核心不變式、計數規則，並用 2 個實際例子逐步展示堆疊的演變（每一步都註明堆疊內容與 res 變化）。最後給出複雜度分析與常見邊界情況說明。

### 方法概觀（TL;DR）
`MinOperations` 使用一個單調遞增的堆疊（以 `List<int> s` 實作）沿陣列左到右掃描，並依下列規則管理堆疊與結果計數 `res`：
- 當遇到比堆疊頂小的數，持續將堆疊頂彈出（因為這些被更小的數「隔開」，無法與右邊一起成為同一次操作的最小值）。
- 遇到 0 跳過（不需任何操作）。
- 當堆疊為空或堆疊頂小於當前元素時，將當前元素入堆疊並把 `res++`（表示我們需要一個新的操作來覆蓋這個更大的值）。
- 若堆疊頂等於當前元素，則不入堆疊（可在同一次操作中處理多個相同值），也不 `res++`。

最後返回 `res`。

---

## 核心不變式（Invariant）
在任意時間點於主迴圈內，以下不變式成立：
1. `s` 是一個嚴格遞增（從底到頂）且只包含非零值的序列。
2. `res` 等於「至今為止需要的操作次數」，並且已計入所有已被確定需要新操作去覆蓋的值。
3. 對於 `s` 中任意元素 x，該元素可被某一次操作（可能是尚未發生的未決操作）覆蓋，使得任何與 x 相等的未來元素若要和 x 一起被覆蓋，必須出現在 x 的右側且在 x 與該未來元素之間不存在更小的值（否則 x 在遇到更小值時會被從堆疊中移除而不增加 res）。

---

## 計數規則（何時增加 res）
- 只有在「當前元素 a 需要一個新的操作覆蓋」時才 `res++`。在程式里，這對應於：當 a != 0 且（堆疊為空 或 堆疊頂 < a）時。直覺上，這表示 a 比當前堆疊中的任何可和它共用操作的前置元素都要大，需要另外一個操作層來處理它。
- 若當前元素等於堆疊頂，則它可以在與堆疊頂相同的操作中被覆蓋，故不增加 `res`。
- 若當前元素小於堆疊頂，先彈出比它大的元素（這些元素已確定不能與右側的元素合併，彈出不直接改變 `res`）；彈出之後若需入堆疊才會視情況 `res++`。

---

## 逐步範例 1： nums = [1, 2, 3, 2, 1]
初始：s = [], res = 0

1. a = 1  
   - s 為空，a != 0，入堆疊，res++  
   - s = [1], res = 1  
   說明：我們需要一層操作來把 1 類的最小值處理掉（例如把整個包含第一個位置的子陣列選一次，之後可一起把其他 1 也變 0）。

2. a = 2  
   - s 頂 = 1 < 2，無彈出；a != 0 且頂 < a，入堆疊，res++  
   - s = [1, 2], res = 2  
   說明：2 比堆疊頂大，需要一個新操作層（例如在更高的數值層次）。

3. a = 3  
   - s 頂 = 2 < 3，入堆疊，res++  
   - s = [1, 2, 3], res = 3

4. a = 2  
   - 現在 a = 2 < s 頂 (3)，因此按邏輯彈出 s 頂直到頂 <= a：
     - 彈出 3（3 > 2），s -> [1, 2]（注意：在此演算法中彈出並不立即改變 res）  
   - 現在 s 頂 = 2 等於 a，則我們不把 a 再入堆疊（同一次操作可以處理兩個 2）  
   - s = [1, 2], res = 3

5. a = 1  
   - a = 1 < s 頂 (2)，彈出 2 -> s = [1]  
   - 現在 s 頂 = 1 等於 a，a 不入堆疊  
   - s = [1], res = 3

結束：返回 res = 3  
這與直覺一致：需要處理 3 層（最底層 1、下一層 2、最高層 3 的操作安排）。

---

## 逐步範例 2： nums = [1, 2, 1, 2, 1, 2]
初始：s = [], res = 0

1. a = 1  
   - s 空且 a != 0 -> 入堆疊，res = 1  
   - s = [1], res = 1

2. a = 2  
   - 1 < 2 -> 入堆疊，res = 2  
   - s = [1, 2], res = 2

3. a = 1  
   - a = 1 < s 頂 (2)，彈出 2 -> s = [1]  
   - 現在 s 頂 = 1 等於 a -> 不入堆疊  
   - s = [1], res = 2

4. a = 2  
   - 1 < 2 -> 入堆疊，res = 3  
   - s = [1, 2], res = 3

5. a = 1  
   - a < s 頂 (2) -> 彈出 2 -> s = [1]  
   - s 頂 = 1 等於 a -> 不入堆疊  
   - s = [1], res = 3

6. a = 2  
   - 1 < 2 -> 入堆疊, res = 4  
   - s = [1, 2], res = 4

結束：返回 res = 4  
說明：第一次把所有的 1 一起當作最小值轉成 0（算作 1 次），但每個被 0 分隔開的 2 需要額外各自的操作，總共 4 次。

---

## 為什麼彈出時不立即增加 res？
在這個方法中，`res` 的意義是「對於遇到的新高度，需要多少個操作層次」。我們在入堆疊的時候代表新增一個層次（res++）。當遇到更小的元素時，把大於它的元素彈出只是說這些較大的元素無法與之後更右側的元素合併成同一次操作，但它們是否已經被計入過 `res`（是的，因為它們曾入堆疊時已加過）因此彈出本身不再改變 `res`。換句話說，入堆疊時計數；彈出是調整「哪些尚在候選集合（堆疊）裡的值」，而非增加新操作。

---

## 邊界情況與注意事項
1. 包含 0 的元素會被跳過，因為 0 本身不需要任何操作。
2. 若陣列全為 0，則 `res = 0`。
3. 若陣列嚴格遞增（例如 [1,2,3,4]），每個元素都會入堆疊並使 `res` 增加，最終 `res = n`（最壞情況）。
4. 若陣列有許多重複值，重複項目不會重複入堆疊（僅第一次入堆疊時增加 res），因此能省操作次數。
5. 這個方法不會改變輸入陣列（如果這點重要，請使用方法一；方法二會原地修改陣列以節省空間）。

---

## 複雜度分析
- 時間複雜度：O(n)。每個元素最多入堆疊一次，出堆疊一次。整體操作 ≤ 2n。
- 空間複雜度：O(n)（用 `List<int>` 當作堆疊，最壞狀況儲存整個陣列中所有非零單調遞增元素）。

---

如果您願意，我可以：
- 把上述詳細流程加入到 `Program.cs` 中 `MinOperations` 的 XML 註解裡（已加入基本註解，但我可以把這個更詳盡的逐步說明放進去），或
- 為更多不同類型的輸入（例如隨機、大量重複、極端遞增/遞減）產生更完整的表格示例與視覺化堆疊演變，方便教學或展示。

要我接著把更詳細的逐步說明寫進 `Program.cs` 的註解嗎？
