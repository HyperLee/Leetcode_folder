# LeetCode 783 — Minimum Distance Between BST Nodes

**題目連結**：[LeetCode 783](https://leetcode.com/problems/minimum-distance-between-bst-nodes/description/) ｜ [LeetCode CN](https://leetcode.cn/problems/minimum-distance-between-bst-nodes/description/)

**難度**：Easy ｜ **標籤**：Tree、DFS、BFS、Binary Search Tree

---

## 題目說明

給定一棵**二元搜尋樹（BST）**的根節點 `root`，請返回樹中**任意兩個不同節點值之間的最小差距**。

### 限制條件

| 限制項目 | 範圍 |
|---------|------|
| 節點數 | `[2, 100]` |
| 節點值 | `[0, 10^5]` |

### 範例

**範例 1**

```
輸入：
        4
       / \
      2   6
     / \
    1   3

輸出：1
說明：節點 2 與 3（差值為 1），或節點 3 與 4（差值為 1），均為最小差距。
```

**範例 2**

```
輸入：
        1
       / \
      0   48
         / \
        12  49

輸出：1
說明：節點 0 與 1 之差為 1，為最小差距。
```

---

## 核心觀念

### BST 中序遍歷的關鍵特性

> BST 的**中序遍歷（Left → Root → Right）**所得到的節點值序列，天然是**遞增有序**的。

這個特性是兩種解法的共同基礎。在已排序的序列中，**最小差距必然出現在相鄰元素之間**，因此只需比對相鄰節點即可，不需兩兩比對全部組合（避免 O(n²) 複雜度）。

---

## 解法一：DFS 朴素排序法

### 出發點

不特別利用 BST 特性，直接把所有節點值收集到陣列，排序後掃描相鄰差值取最小值。

### 實作邏輯

1. 使用中序 DFS（`dfs`）將所有節點值存入 `List<int>`。
   - 由於 BST 特性，中序遍歷的結果已天然有序，無需再排序。
2. 走訪陣列，計算每對相鄰元素的差值，取全域最小值。

```csharp
public int MinDiffInBST(TreeNode root)
{
    List<int> list = new List<int>();
    dfs(root, list);           // 中序遍歷，list 已是遞增序列

    // Array.Sort(list.ToArray()) 排序的是副本，list 本身不受影響；
    // 因 BST 中序已有序，此行為冗餘，保留僅作示意。
    Array.Sort(list.ToArray());

    int n = list.Count;
    int res = int.MaxValue;

    for(int i = 1; i < n; i++)
    {
        res = Math.Min(res, Math.Abs(list[i] - list[i - 1]));
    }
    return res;
}
```

### 複雜度分析

| 項目 | 複雜度 |
|------|--------|
| 時間 | O(n log n) — 主要來自概念上的排序；實際因 BST 已有序為 O(n) |
| 空間 | O(n) — 需要額外陣列儲存所有節點值 |

---

## 解法二：BST 中序遍歷 + 前驅節點即時比較

### 出發點

改善解法一的空間使用：利用 BST 中序有序的特性，在遍歷過程中以 `pre` 變數記錄上一個拜訪到的節點值，**邊遍歷邊比較**，省去額外陣列。

### 實作邏輯

1. 初始化 `res = int.MaxValue`，`pre = -1`（以 -1 標記尚未拜訪任何節點，BST 節點值 ≥ 0 故不衝突）。
2. 中序遍歷 `dfs2`：
   - 若 `pre == -1`（第一個節點）：只記錄值，不計算差值。
   - 若 `pre != -1`（後續節點）：計算 `root.val - pre`（中序遞增，差值為正），更新 `res`，再推進 `pre`。
3. 遍歷完成後回傳 `res`。

```csharp
public void dfs2(TreeNode root)
{
    if(root is null) return;

    dfs2(root.left);   // 先走左子樹

    if(pre == -1)
        pre = root.val;           // 第一個節點，初始化前驅
    else
    {
        res = Math.Min(res, root.val - pre);  // 更新最小差距
        pre = root.val;                        // 推進前驅指標
    }

    dfs2(root.right);  // 再走右子樹
}
```

> [!NOTE]
> 原始程式碼中 `if(pre != -1)` 的判斷邏輯顛倒，導致第一個節點被誤判為有前驅而跳過計算初始化，正確條件應為 `if(pre == -1)`。

### 複雜度分析

| 項目 | 複雜度 |
|------|--------|
| 時間 | O(n) — 每個節點只拜訪一次 |
| 空間 | O(h) — h 為樹高（遞迴堆疊），最壞為 O(n)（退化成鏈狀），平均為 O(log n) |

---

## 演示流程

以範例 1 的 BST 為例：

```
        4
       / \
      2   6
     / \
    1   3
```

### 解法一演示

| 步驟 | 操作 | list 狀態 |
|------|------|-----------|
| 拜訪 1 | 加入 1 | `[1]` |
| 拜訪 2 | 加入 2 | `[1, 2]` |
| 拜訪 3 | 加入 3 | `[1, 2, 3]` |
| 拜訪 4 | 加入 4 | `[1, 2, 3, 4]` |
| 拜訪 6 | 加入 6 | `[1, 2, 3, 4, 6]` |
| 掃描差值 | `2-1=1`, `3-2=1`, `4-3=1`, `6-4=2` | **res = 1** |

### 解法二演示

| 步驟 | 拜訪節點 | pre | res |
|------|---------|-----|-----|
| 1 | 1 | -1 → **1**（第一個節點，初始化） | MAX |
| 2 | 2 | 1 → **2** | min(MAX, 2-1) = **1** |
| 3 | 3 | 2 → **3** | min(1, 3-2) = **1** |
| 4 | 4 | 3 → **4** | min(1, 4-3) = **1** |
| 5 | 6 | 4 → **6** | min(1, 6-4) = **1** |
| 結束 | — | — | **1** |

---

## 兩種解法比較

| 比較項目 | 解法一（DFS + 排序） | 解法二（中序前驅比較） |
|---------|---------------------|----------------------|
| 核心技術 | 中序收集 → 掃描相鄰差值 | 中序遍歷 + 前驅變數即時比較 |
| 時間複雜度 | O(n log n)（含概念上排序） | **O(n)** |
| 空間複雜度 | O(n)（額外陣列） | **O(h)**（只需遞迴堆疊） |
| 利用 BST 特性 | 部分（中序有序，Array.Sort 為冗餘） | 完整利用 |
| 程式碼可讀性 | 較高，邏輯直覺 | 中等，需注意 pre 初始值語意 |
| 適用場景 | 快速理解、通用樹型問題 | 追求效能、BST 特定優化 |

> [!TIP]
> 解法二是此類 BST 最小差值問題的最優解，實際面試中建議直接採用解法二，並能清楚說明 `pre` 的初始值設計。

---

## 執行環境

- .NET 10
- C# 14
- 測試框架：Console 手動驗證
