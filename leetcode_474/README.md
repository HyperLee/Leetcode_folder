# LeetCode 474 - 一和零 (Ones and Zeroes)

這是 LeetCode 474 題「一和零」的 C# 解題實作，使用動態規劃方法解決 0/1 背包問題的變體。

## 題目描述

給定一個二進位字串陣列 `strs` 和兩個整數 `m` 和 `n`。

返回 `strs` 中**最大子集的大小**，使得子集中最多有 `m` 個 0 和 `n` 個 1。

如果集合 `x` 是集合 `y` 的子集，則 `x` 中的所有元素也是 `y` 中的元素。

### 範例

**範例 1:**

```text
輸入：strs = ["10","0001","111001","1","0"], m = 5, n = 3
輸出：4
解釋：最多有 5 個 0 和 3 個 1 的最大子集是 {"10","0001","1","0"}，因此答案是 4。
     其他滿足條件的子集包括 {"0001","1","0"} 和 {"10","1","0"}。
```

**範例 2:**

```text
輸入：strs = ["10","0","1"], m = 1, n = 1
輸出：2
解釋：最大子集是 {"0", "1"}，因此答案是 2。
```

### 約束條件

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 僅由 `'0'` 和 `'1'` 組成
- `1 <= m, n <= 100`

## 問題連結

- [LeetCode 英文版](https://leetcode.com/problems/ones-and-zeroes/description/)
- [LeetCode 中文版](https://leetcode.cn/problems/ones-and-zeroes/description/)

## 解題思路

### 核心概念：0/1 背包問題

這道題是經典 **0/1 背包問題**的變體。在理解本題之前，先了解什麼是 0/1 背包問題：

#### 什麼是 0/1 背包問題？

0/1 背包問題是動態規劃中的經典問題：

- **問題描述**：給定 `n` 個物品，每個物品有重量 `weight[i]` 和價值 `value[i]`，以及一個容量為 `W` 的背包。每個物品只能選擇一次（0 或 1），求在不超過背包容量的情況下，能獲得的最大價值。

- **核心特徵**：
  - **0/1 選擇**：每個物品要麼選（1），要麼不選（0），不能選擇部分
  - **單一約束**：只有一個容量限制（背包重量）
  - **最優子結構**：最優解可由子問題的最優解構成

- **狀態轉移方程**：

  ```text
  dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])
  ```

  其中 `dp[i][w]` 表示前 `i` 個物品在容量為 `w` 時的最大價值。

#### 本題與 0/1 背包的關係

本題是 **雙約束的 0/1 背包問題**：

| 項目 | 經典 0/1 背包 | 本題（LeetCode 474） |
|------|--------------|---------------------|
| **物品** | n 個物品 | n 個二進位字串 |
| **價值** | value[i] | 1（每個字串價值相同） |
| **約束維度** | 1 個（重量） | 2 個（0 的數量、1 的數量） |
| **容量限制** | 背包容量 W | m 個 0，n 個 1 |
| **目標** | 最大價值 | 最大字串數量 |

本題的特殊之處在於：

1. **雙重容量限制**：需要同時滿足 0 和 1 的數量限制
2. **價值相同**：每個字串的價值都是 1，目標是最大化字串數量
3. **三維 DP**：需要三個維度（字串索引、0 的容量、1 的容量）

### 解題方法：動態規劃

#### 1. 狀態定義

定義三維陣列 `dp[i,j,k]`：

- `i`：前 i 個字串（範圍：0 到 l，l 為字串陣列長度）
- `j`：使用 j 個 0（範圍：0 到 m）
- `k`：使用 k 個 1（範圍：0 到 n）
- **值**：在上述條件下，最多可以選擇的字串數量

最終答案為 `dp[l,m,n]`。

#### 2. 邊界條件

當 `i = 0` 時（沒有任何字串可用）：

```text
dp[0,j,k] = 0  (對所有 0 ≤ j ≤ m, 0 ≤ k ≤ n)
```

#### 3. 狀態轉移方程

對於第 `i` 個字串，假設它包含 `zeros` 個 0 和 `ones` 個 1：

```text
dp[i,j,k] = 
  ⎧ dp[i-1,j,k]                                    如果 j < zeros 或 k < ones (無法選擇)
  ⎨
  ⎩ max(dp[i-1,j,k], dp[i-1,j-zeros,k-ones] + 1)  如果 j ≥ zeros 且 k ≥ ones (可以選擇)
```

**狀態轉移含義**：

- `dp[i-1,j,k]`：不選擇第 i 個字串
- `dp[i-1,j-zeros,k-ones] + 1`：選擇第 i 個字串，消耗相應的 0 和 1

#### 4. 計算順序

按照以下順序計算：

1. 外層迴圈：遍歷每個字串（i = 1 到 l）
2. 中層迴圈：遍歷 0 的容量（j = 0 到 m）
3. 內層迴圈：遍歷 1 的容量（k = 0 到 n）

## 複雜度分析

- **時間複雜度**：O(l × m × n)
  - l：字串陣列長度
  - m：0 的數量上限
  - n：1 的數量上限
  - 需要填滿整個三維 DP 表格

- **空間複雜度**：O(l × m × n)
  - 三維 DP 陣列的空間開銷
  - 可以優化到 O(m × n)（使用滾動陣列）

## 解題步驟詳解

### 步驟 1：初始化 DP 陣列

```csharp
int length = strs.Length;
int[,,] dp = new int[length + 1, m + 1, n + 1];
```

建立 `(length+1) × (m+1) × (n+1)` 的三維陣列，預設值為 0（符合邊界條件）。

### 步驟 2：計算每個字串的 0 和 1 數量

```csharp
int[] zerosOnes = GetZerosOnes(strs[i - 1]);
int zeros = zerosOnes[0];  // 0 的數量
int ones = zerosOnes[1];   // 1 的數量
```

使用輔助函式 `GetZerosOnes` 統計當前字串中 0 和 1 的數量：

```csharp
public int[] GetZerosOnes(string str)
{
    int[] zerosOnes = new int[2];
    for (int i = 0; i < str.Length; i++)
    {
        zerosOnes[str[i] - '0']++;  // '0' -> index 0, '1' -> index 1
    }
    return zerosOnes;
}
```

**技巧說明**：

- `str[i] - '0'` 將字元轉換為數字：`'0'` → 0，`'1'` → 1
- 直接使用計算結果作為陣列索引,簡潔高效

### 步驟 3：填充 DP 表格

```csharp
for (int j = 0; j <= m; j++)
{
    for (int k = 0; k <= n; k++)
    {
        // 預設不選擇當前字串
        dp[i, j, k] = dp[i - 1, j, k];
        
        // 如果容量足夠，考慮選擇當前字串
        if (j >= zeros && k >= ones)
        {
            dp[i, j, k] = Math.Max(dp[i, j, k], dp[i - 1, j - zeros, k - ones] + 1);
        }
    }
}
```

**邏輯說明**：

1. 先假設不選擇當前字串，繼承上一個狀態
2. 如果容量足夠（`j >= zeros && k >= ones`），比較兩種選擇：
   - 不選：`dp[i-1,j,k]`
   - 選：`dp[i-1,j-zeros,k-ones] + 1`
3. 取兩者中的較大值

### 步驟 4：返回結果

```csharp
return dp[length, m, n];
```

返回使用所有字串、m 個 0 和 n 個 1 的最大字串數量。

## 範例追蹤

以**範例 1** 為例：`strs = ["10","0001","111001","1","0"]`, `m = 5`, `n = 3`

### 初始狀態

| 字串 | 0 的數量 | 1 的數量 |
|------|---------|---------|
| "10" | 1 | 1 |
| "0001" | 3 | 1 |
| "111001" | 2 | 4 |
| "1" | 0 | 1 |
| "0" | 1 | 0 |

### DP 計算過程（關鍵狀態）

當 `i=2, j=5, k=3` 時（考慮前 2 個字串 "10" 和 "0001"）：

- 選擇 "10"：消耗 1 個 0 和 1 個 1，`dp[1,4,2] + 1 = 1 + 1 = 2`
- 不選擇 "0001"（會超出容量）
- 結果：`dp[2,5,3] = 2`

當 `i=5, j=5, k=3` 時（考慮所有字串）：

- 最優子集：{"10", "0001", "1", "0"}
- 消耗：(1+3+0+1) 個 0 = 5 個 0，(1+1+1+0) 個 1 = 3 個 1
- 結果：`dp[5,5,3] = 4`

### 為何不選 "111001"？

"111001" 有 2 個 0 和 4 個 1：

- 如果選擇它，會消耗 4 個 1（超過限制 n=3）
- 因此無法被選入最優子集

## 執行方式

### 前置需求

- .NET 8.0 SDK 或更高版本

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run
```

### 預期輸出

```text
測試案例 1:
輸入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
輸出：4
預期：4

測試案例 2:
輸入：strs = ["10", "0", "1"], m = 1, n = 1
輸出：2
預期：2

測試案例 3:
輸入：strs = ["10", "0001", "111001", "1", "0"], m = 3, n = 4
輸出：3
預期：3

===== 使用滾動陣列優化版本測試 =====

優化測試案例 1:
輸入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
輸出：4
預期：4
結果：✓ 與原版本一致

優化測試案例 2:
輸入：strs = ["10", "0", "1"], m = 1, n = 1
輸出：2
預期：2
結果：✓ 與原版本一致

優化測試案例 3:
輸入：strs = ["10", "0001", "111001", "1", "0"], m = 3, n = 4
輸出：3
預期：3
結果：✓ 與原版本一致
```

## 專案結構

```text
leetcode_474/
├── leetcode_474.sln          # Visual Studio 解決方案檔
├── README.md                  # 專案說明文件（本文件）
└── leetcode_474/
    ├── leetcode_474.csproj    # 專案檔
    └── Program.cs             # 主程式（包含解題程式碼）
```

## 進階優化

### 空間優化：滾動陣列

當前實作的空間複雜度為 O(l × m × n)。可以使用滾動陣列優化到 O(m × n)：

**核心思想**：

- 每次計算 `dp[i]` 只依賴 `dp[i-1]`
- 可以用二維陣列代替三維陣列，從後往前更新

**優化程式碼**：

```csharp
public int FindMaxFormOptimized(string[] strs, int m, int n)
{
    int[,] dp = new int[m + 1, n + 1];
    
    foreach (string str in strs)
    {
        int[] zerosOnes = GetZerosOnes(str);
        int zeros = zerosOnes[0];
        int ones = zerosOnes[1];
        
        // 從後往前更新，避免覆蓋未使用的狀態
        for (int j = m; j >= zeros; j--)
        {
            for (int k = n; k >= ones; k--)
            {
                dp[j, k] = Math.Max(dp[j, k], dp[j - zeros, k - ones] + 1);
            }
        }
    }
    
    return dp[m, n];
}
```

**優化說明**：

- 省略第一維（字串索引）
- **從後往前**遍歷，確保 `dp[j-zeros, k-ones]` 是上一輪的值
- 空間複雜度降為 O(m × n)

**為什麼要從後往前遍歷？**

如果從前往後遍歷，當計算 `dp[j, k]` 時，`dp[j-zeros, k-ones]` 可能已經被本輪更新過，導致使用了本輪的值而非上一輪的值。從後往前遍歷可確保：

- 計算 `dp[j, k]` 時，所有 `j < j'` 和 `k < k'` 的位置都還是上一輪的值
- 這樣就能正確模擬三維 DP 中 `dp[i-1, j-zeros, k-ones]` 的效果

**效能對比**：

| 方案 | 時間複雜度 | 空間複雜度 | 實作 |
|------|-----------|-----------|------|
| 三維 DP（原版本） | O(l × m × n) | O(l × m × n) | `FindMaxForm` |
| 滾動陣列（優化版本） | O(l × m × n) | O(m × n) | `FindMaxFormOptimized` |

優化版本在保持相同時間複雜度的前提下，大幅降低了空間使用，特別適合處理較大的測試資料。

## 關鍵要點

1. **三維 DP 建模**：字串索引 + 兩個容量維度
2. **狀態轉移**：選或不選，取最大值
3. **巧妙統計**：`str[i] - '0'` 直接作為陣列索引
4. **空間優化**：可使用滾動陣列減少空間開銷

## 相關題目

- [LeetCode 416 - 分割等和子集](https://leetcode.com/problems/partition-equal-subset-sum/)
- [LeetCode 494 - 目標和](https://leetcode.com/problems/target-sum/)
- [LeetCode 1049 - 最後一塊石頭的重量 II](https://leetcode.com/problems/last-stone-weight-ii/)

## 參考資料

- [動態規劃 - 背包問題](https://oi-wiki.org/dp/knapsack/)
- [LeetCode 官方題解](https://leetcode.com/problems/ones-and-zeroes/solutions/)
