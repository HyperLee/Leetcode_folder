<user>
#sym:FindMaxFormOptimized  詳細解釋此方法 且說明為什麼是優化以及為什麼是 從後往前更新
</user>
<assistant>
我要先建立一個 todo 列表並把第一項標記為 in-progress，方便追蹤我接下來要撰寫的詳細說明（期望結果：todo 包含一項，狀態為 in-progress）。接下來我會撰寫完整說明並標記完成。 ## 計畫更新（簡短）
我會針對 `FindMaxFormOptimized` 方法提供詳細中文說明，包含演算法流程、為何是優化、為何要從後往前更新、時間/空間複雜度、逐步範例（包含 DP 表）、邊界與注意事項，以及如何在 `Program.cs` 呼叫/驗證結果。接下來我會直接給出完整說明。

## FindMaxFormOptimized 詳細說明

契約（Contract）
- 輸入（inputs）
  - `strs: string[]`：二進位字串陣列，每個字串只包含字符 '0' 和 '1'。
  - `m: int`：最多可使用的 '0' 的數量（容量）。
  - `n: int`：最多可使用的 '1' 的數量（容量）。
- 輸出（output）
  - `int`：可以從 `strs` 中選出的最大子集大小，使得所選子集中 '0' 的總數 ≤ m 且 '1' 的總數 ≤ n。
- 錯誤模式 / 邊界
  - 若 `strs` 為空陣列，回傳 0。
  - 若任一字串包含非 '0' 或 '1' 字元：目前實作假設不會發生（LeetCode 題目保證），否則可能引發索引錯誤。
  - 若 m 或 n 為負：不合理輸入，實作未特別處理（可視情況新增參數驗證）。

演算法摘要（What / How）
- 這是 0/1 背包問題的變形：每個字串有「成本」(zeros, ones) 與「價值」1（選一個字串計數 +1），我們要在雙維容量 (m, n) 下最大化總價值。
- 原始直觀 DP 是三維：dp[i,j,k] 表示前 i 個字串在 j 個 0、k 個 1 容量下的最大選取數量。這會花 O(L*m*n) 的時間，但空間為 O(L*m*n)（L 為字串數量）。
- 優化關鍵：dp[i] 只依賴 dp[i-1]（上一個字串的狀態），因此可以捨棄字串索引維度，只用二維 dp[j,k] 來表示「目前考慮到某個字串為止」的狀態。這把空間從 O(L*m*n) 降到 O(m*n)。
- 為了防止在同一輪迭代中使用到剛更新過的狀態（即將當前字串選入多次），我們必須「從後往前」迭代容量 j 和 k。這確保 dp[j-zeros, k-ones] 在被讀取時，仍然是上一輪（未包含當前字串）的值。

為什麼是優化（Space 優化）
- 三維 dp 用到前一個字串的全部狀態。若用二維 dp 保存「當前最大值」，就能用更少的記憶體。
- 時間複雜度不變（仍為 O(L*m*n)），但空間複雜度由 O(L*m*n) → O(m*n)。在 m,n 和字串數量較大時，記憶體節省很可觀。

為什麼要從後往前更新（核心理由）
- 若我們改用從小到大（前往後）更新 dp，當更新 dp[j,k] 時，可能會讀到剛在本輪被更新的 dp[j-zeros, k-ones]（該值已包含當前字串），這等於在一輪之內重複選取同一個字串多次（違反 0/1 背包的「每件物品最多選一次」限制）。
- 從後往前保證：當我們處理 dp[j,k] 時，dp[j-zeros, k-ones] 對於索引較小，尚未在本輪被改寫，因此仍為上一輪（上一個字串集合）的值。這模擬了「使用 dp[i-1] 去推導 dp[i]」的效果，但只用一塊陣列。

逐步範例（小範例展示 DP 表如何更新）
- 輸入：strs = ["10","0","1"]，m = 1, n = 1
- 先計算每個字串的 (zeros, ones)：
  - "10" -> (1,1)
  - "0"  -> (1,0)
  - "1"  -> (0,1)
- dp 初始：大小 (m+1) x (n+1) = 2 x 2，初值全 0
  - dp 表格索引為 dp[j][k]（j: 0..1, k: 0..1）
- 處理 "10" (zeros=1, ones=1)
  - 迴圈 j 從 1 到 1（倒序），k 從 1 到 1（倒序）
  - 更新 dp[1,1] = max(dp[1,1], dp[0,0] + 1) => max(0, 0+1) = 1
  - dp 現在：
    - dp[0,0]=0, dp[0,1]=0
    - dp[1,0]=0, dp[1,1]=1
- 處理 "0" (zeros=1, ones=0)
  - j 從 1 到 1，k 從 1 到 0（倒序）
  - 當 j=1,k=1: dp[1,1] = max(1, dp[0,1] + 1) => dp[0,1]=0 => 1
  - 當 j=1,k=0: dp[1,0] = max(0, dp[0,0] + 1) => 1
  - dp 現在：
    - dp[0,0]=0, dp[0,1]=0
    - dp[1,0]=1, dp[1,1]=1
- 處理 "1" (zeros=0, ones=1)
  - j 從 1 到 0（倒序），k 從 1 到 1（倒序）
  - 當 j=1,k=1: dp[1,1] = max(1, dp[1,0] + 1) => dp[1,0]=1 => max(1,2) = 2
  - 當 j=0,k=1: dp[0,1] = max(0, dp[0,0] + 1) => 1
  - 最終 dp：
    - dp[0,0]=0, dp[0,1]=1
    - dp[1,0]=1, dp[1,1]=2
- 結果 dp[m,n] = dp[1,1] = 2（正確）

注意：如果我們用正向（從小到大）更新，就可能在處理 "1" 時讀到 dp[1,0] 已被本輪更新（導致錯誤雙重計數）。倒序保證 dp[j-zeros,k-ones] 還是上一輪的值。

時間與空間複雜度
- 時間複雜度：O(L * m * n)，L 為字串數量。每個字串需要掃過 m*n 的 dp 表。
- 空間複雜度：O(m * n)，使用二維陣列大小為 (m+1)*(n+1)。

3–5 個可能的邊界情況（與處理建議）
1. strs 為空陣列：直接回傳 0。當前實作會 return dp[m,n]，初始為 0，行為正確。
2. m 或 n 為 0：只允許使用單一類型的字元（全部 1 或全部 0），演算法仍然正確，但要注意索引界限（循環條件 j >= zeros / k >= ones 會阻擋不合法更新）。
3. 某些字串成本超過容量（例如 zeros > m 或 ones > n）：該字串永遠不會被選入；迴圈 j 或 k 的起點（從 m down to zeros）會自動跳過這種字串，無需特殊處理。
4. 大量字串且 m,n 中一個很小：演算法仍然有效，但時間取決於 L*m*n；可在 prefilter（剔除成本超出兩者之一的字串）減少 L。
5. 非二元字元（不是 '0' 或 '1'）：目前實作透過 zerosOnes[str[i] - '0']++ 假設有效。若輸入可能不保證，應加入驗證或 try/catch。

實作細節重點（與 Program.cs 對照）
- 先用 `GetZerosOnes` 計算每個字串的 (zeros, ones)。
- 初始化 dp 為 int[m+1, n+1]。
- 對每個字串使用雙重倒序迴圈：
  - for (int j = m; j >= zeros; j--)
  -   for (int k = n; k >= ones; k--)
  -     dp[j,k] = Math.Max(dp[j,k], dp[j-zeros,k-ones] + 1);
- 最後回傳 dp[m,n]。

實作範例（如何驗證）
- 在 `Program.cs` 的 `Main` 已有數個測試案例，直接執行專案：
  - macOS (zsh)：
    - dotnet build
    - dotnet run --project leetcode_474.csproj
- 檢查 `FindMaxForm` 與 `FindMaxFormOptimized` 輸出是否一致（Main 已比較並列印結果）。

小結（結論）
- `FindMaxFormOptimized` 是以二維滾動陣列優化三維 DP 的空間使用，維持時間複雜度不變。
- 從後往前更新是防止在同一輪中重複選取同一個字串的必要技巧，模擬 dp[i] 只依賴 dp[i-1] 的情形。
- 本方法在 m、n、L 三者皆不太小時會有最明顯的空間優勢。
</assistant>