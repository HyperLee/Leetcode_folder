<user>
#sym:FindMaxForm   詳細解釋此方法 
</user>
<assistant>
我要先建立並登記一個 todo 清單（標記我正在進行的項目），以便追蹤交付內容與狀態，然後給出詳細說明。預期結果：todo 建立完成後回報，接著提供完整的 FindMaxForm 解說。 ## 進度更新
我已建立並登記 todo 清單，項目 1（說明 `FindMaxForm`）標記為進行中，接下來我會提供 `FindMaxForm` 的完整詳細解說，包含每行邏輯、狀態轉移、變數意義、步驟走例子、邊界情況與複雜度分析，之後會接著完成 todo 項目 2（補充範例與比較）。以下是 `FindMaxForm` 的詳細解說。

## FindMaxForm 詳細解說

函式簽名與目標
- 方法：public int FindMaxForm(string[] strs, int m, int n)
- 目標：在給定的二進位字串陣列 `strs` 中，挑選出最大數量的字串，使得選中的字串總共包含不超過 `m` 個 '0' 與不超過 `n` 個 '1'。這是 0/1 背包的變形：每個字串有兩種「重量」(zeros, ones)，價值固定為 1（計算字串數量）。

輸入/輸出契約（小契約）
- 輸入：`strs`（只含 '0' 和 '1' 的字串陣列），`m`（可用的 '0' 容量），`n`（可用的 '1' 容量）。
- 輸出：能選的最大字串數（整數）。
- 錯誤/邊界：當 `strs` 為空陣列應回傳 0；`m` 或 `n` 若為 0，僅能選擇全由另一類位元形成的字串（或 0 個）；此實作假設輸入合法（非負 m,n，字串僅包含 '0'/'1'）。

程式碼逐段說明（對應程式碼片段）
1) int length = strs.Length;
- 取得字串陣列長度 l（方便建立 DP 陣列與迭代）。

2) int[,,] dp = new int[length + 1, m + 1, n + 1];
- 建立三維動態規劃（DP）陣列。
- 解釋維度：
  - 第一維 i：考慮前 i 個字串（0..length），使用「前 i 個」是常見技巧，便於初始條件 dp[0,*,*] = 0。
  - 第二維 j：使用的 0 的數量上限（0..m）。
  - 第三維 k：使用的 1 的數量上限（0..n）。
- dp[i,j,k] 的語意：在前 i 個字串可選的狀況下，當仍可用 j 個 0、k 個 1（或解釋為容量 j,k），所能選到的最大字串數量（或最多有多少個字串）。
- 初始值：陣列預設為 0，代表不選任何字串時數量為 0（dp[0,*,*] = 0）。

3) 外層迴圈：for (int i = 1; i <= length; i++)
- 逐個考慮每個字串，索引用 i，程式中取 strs[i-1]。

4) 計算當前字串 zeros, ones：
- int[] zerosOnes = GetZerosOnes(strs[i - 1]);
- zeros = zerosOnes[0]; ones = zerosOnes[1];
- 每個字串有兩個「成本」：需要消耗 zeros 個 0、ones 個 1。

5) 內層雙迴圈：for (int j = 0; j <= m; j++) { for (int k = 0; k <= n; k++) { ... } }
- 對每一個可能的 (j,k) 容量組合 計算 dp[i,j,k]。
- 注意：這裡循序從小到大走容量（與優化版本不同，原始 3D 實作可以從小到大，因為 dp[i] 只讀 dp[i-1] 而不會覆寫）。

6) 預設不選：dp[i, j, k] = dp[i - 1, j, k];
- 初始化為上一層（不包括第 i 個字串）的最大值：即不選第 i 個字串時的結果。

7) 如果容量足夠則考慮選擇：
- if (j >= zeros && k >= ones)
    dp[i, j, k] = Math.Max(dp[i, j, k], dp[i - 1, j - zeros, k - ones] + 1);
- 含意：如果目前的 (j,k) 容量能放下當前字串，則比較不選與選擇兩個方案：
  - 不選：已設為 dp[i-1,j,k]
  - 選擇：看 dp[i-1, j-zeros, k-ones]（上一層、減去這個字串的成本後的最大值）加上 1（選這個字串數量 +1）。
- 取最大值：保留最佳方案。

8) return dp[length, m, n];
- 最後答案是考慮所有字串（i = length）且整體容量為 (m,n) 時最大字串數。

狀態轉移總結（數學式）
- dp[0, j, k] = 0（沒有字串可選）
- 對 i >= 1:
  - 若 j < zeros(i) 或 k < ones(i): dp[i,j,k] = dp[i-1,j,k]
  - 否則: dp[i,j,k] = max(dp[i-1,j,k], dp[i-1,j-zeros(i),k-ones(i)] + 1)

為何這樣正確？
- 典型 0/1 背包：每個物品（字串）只能選或不選，價值為 1，雙維重量限制（zeros, ones）。使用 i 表示已考慮哪些物品能把「選與不選」拆成上一層與當前選擇兩種來源，因此遞推正確且無重複計數。

例子手動走一次（小例）
- strs = ["10", "0", "1"]，m = 1, n = 1（程式範例2）
- length = 3。建立 dp[4,2,2]（i:0..3, j:0..1, k:0..1）
- i = 1, str = "10": zeros=1, ones=1
  - j=0,k=0: dp[1,0,0]=dp[0,0,0]=0
  - j=0,k=1: dp[1,0,1]=dp[0,0,1]=0
  - j=1,k=0: dp[1,1,0]=dp[0,1,0]=0
  - j=1,k=1: 可以選或不選：dp[0,1,1]=0, dp[0,0,0]+1=1 => dp[1,1,1]=1
- i = 2, str = "0": zeros=1, ones=0
  - j=0,k=0: dp[2,0,0]=dp[1,0,0]=0
  - j=1,k=0: 可以選：dp[1,1,0]=0, dp[1,0,0]+1=1 => dp[2,1,0]=1
  - j=1,k=1: dp[2,1,1] = max(dp[1,1,1]=1, dp[1,0,1]+1=1) => 1
  - j=0,k=1: dp[2,0,1]=dp[1,0,1]=0
- i = 3, str = "1": zeros=0, ones=1
  - j=0,k=0: dp[3,0,0]=0
  - j=0,k=1: 可以選：dp[2,0,1]=0, dp[2,0,0]+1=1 => dp[3,0,1]=1
  - j=1,k=0: dp[3,1,0] = dp[2,1,0] = 1
  - j=1,k=1: 可以從不選 dp[2,1,1]=1 或選 dp[2,1,0]+1=2 => dp[3,1,1]=2
- 最終 dp[3,1,1] = 2，與預期相符（選 "0" 與 "1"）。

時間與空間複雜度
- 時間複雜度：O(l * m * n)，l 為字串數量。每個字串需要掃描 m*n 個狀態。
- 空間複雜度：O(l * m * n)，程式使用三維陣列保存歷史所有 i 的狀態。這在 m,n 或 l 較大時成本高。

常見優化
- 使用滾動陣列把空間從 O(lmn) 降到 O(mn)。因為 dp[i] 僅依賴 dp[i-1]，可以使用二維陣列更新。但必須注意更新順序：
  - 如果用 2D dp 並從小到大更新，會造成本輪覆寫影響後續判斷（重複選同一個字串多次）。正確做法是從後往前（j 從 m 到 zeros，k 從 n 到 ones）更新，確保讀到的是上一輪的值。你的程式中 `FindMaxFormOptimized` 已正確實作此策略。

邊界與實作注意事項（edge cases）
- m 或 n 為 0：只能選擇不需要該位元的字串（若 zeros==0 或 ones==0）。
- 字串為空（長度 0）：zeros = 0, ones = 0。若存在這種字串，理論上可以無限加入，但實際問題中字串只包含 '0'/'1' 且不會是空，但若出現，選或不選都不消耗容量且價值為 1，則最終會把所有這類空字串全部選上，這種情況應在輸入規格中避免或特別處理（例如把空字串過濾掉）。
- 非法字元：GetZerosOnes 假設字串只含 '0' 或 '1'；否則索引會越界或出錯。可在入口處驗證字串。

程式碼可讀性與註解建議（依 csharp.instructions.md）
- 公開 API 應有 XML 文件註解（你的方法已有 summary/params/returns，符合建議）。
- 使用 PascalCase（方法已符合），私有變數用 camelCase（無此情況）。
- 如果需要更高版本 C# 功能，可使用記錄或範例。
- 每個方法適當加入為何這樣設計的註解（你的註解已做得很好）。

驗證方式（如何測試）
- 已在 `Main` 中放三個範例測試，並與優化版本進行比對。建議再加入極端值測試（空陣列，大 m,n，包含大量字串但 m,n 很小）。

總結（精簡）
- `FindMaxForm` 使用三維 DP 解法，正確實作了狀態定義與轉移，時間 O(lmn)，空間 O(lmn)。
- 若要節省空間，使用二維滾動陣列（`FindMaxFormOptimized`），但需從後往前更新以避免覆蓋上一次狀態。

下一步
- 我已登記 todo 項目 2（補充範例與比較），若你要我接著完成，我會把 todo 1 標為已完成，然後針對 `FindMaxFormOptimized` 做更詳細的比較與例子走一遍，並示範如何把 `GetZerosOnes` 做簡單防錯或效能微優化。要我繼續嗎？
</assistant>