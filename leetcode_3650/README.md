# LeetCode 3650 - 邊反轉的最小路徑總成本

## 題目描述

給你一個有向加權圖，節點標號為 `0` 到 `n - 1`，`edges` 陣列中 `edges[i] = [ui, vi, wi]` 表示從節點 `ui` 到節點 `vi` 的有向邊，權重（成本）為 `wi`。

每個節點 `ui` 都有一個開關且**最多可使用一次**：當你抵達 `ui` 且尚未使用過其開關時，你可以在其中一條指向 `ui` 的入邊 `vi → ui` 上啟動開關，將該邊反向為 `ui → vi` 並立即沿此邊移動。

> [!NOTE]
> - 該反轉僅對那一次移動有效
> - 使用反轉邊的成本為 `2 * wi`

**目標**：返回從節點 `0` 到節點 `n - 1` 的最小總成本；若無法到達則返回 `-1`。

### 題目連結

- [LeetCode (英文)](https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/)
- [力扣 (中文)](https://leetcode.cn/problems/minimum-cost-path-with-edge-reversals/)

## 解題思路

### 關鍵觀察

本題的關鍵洞察是：**Dijkstra 演算法中每個節點最多只會被處理一次**（第一次出堆即為最短距離），因此我們不需要額外追蹤：

1. 每個節點的開關是否已使用
2. 邊反轉的有效性範圍

### 核心轉換

將問題轉換為標準的單源最短路徑問題：

對於每條原始邊 `[x, y, w]`，在圖中加入兩條邊：

| 邊類型 | 方向 | 成本 | 說明 |
|--------|------|------|------|
| 正向邊 | x → y | w | 正常走此邊 |
| 反向邊 | y → x | 2w | 在 y 點使用開關，反轉邊後走 |

```
原始圖：                    轉換後的圖：
    w                           w
x ────→ y               x ────────→ y
                          ←────────
                            2w
```

這樣，問題就轉化為在新圖上求從節點 `0` 到節點 `n-1` 的最短路徑。

## 解法比較

本專案提供兩種 Dijkstra 演算法實作，方便學習與對比：

| 項目 | 解法一：優化版（堆優化） | 解法二：標準版（無堆優化） |
|------|------------------------|-------------------------|
| **核心差異** | 使用 PriorityQueue 快速找最小距離節點 | 使用線性搜尋找最小距離節點 |
| **時間複雜度** | O(m log m) | O(n²) |
| **空間複雜度** | O(n + m) | O(n + m) |
| **適用場景** | 稀疏圖（邊數較少） | 稠密圖（邊數接近 n²） |
| **實作難度** | 需要理解堆結構 | 簡單易懂，適合學習 |
| **程式碼長度** | 較短 | 較長（需手動尋找最小值） |

> [!TIP]
> - 若 **m ≈ n**（稀疏圖），使用解法一更高效
> - 若 **m ≈ n²**（稠密圖），兩者性能相近，但解法二更易理解
> - 學習階段建議先掌握解法二，再學習解法一的優化技巧

---

## 解法一：優化版 Dijkstra（堆優化）

### 演算法流程

#### 步驟說明

1. **建圖**：建立鄰接表，對每條邊同時加入正向邊和反向邊
2. **初始化**：設定距離陣列，起點距離為 0，其餘為無限大
3. **Dijkstra**：使用最小堆進行鬆弛操作
4. **返回結果**：到達終點時返回距離，否則返回 -1

### 流程圖

```
┌─────────────────────────────────────────────────────────────────┐
│                         開始                                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 1：建立鄰接表                                              │
│  - 對每條邊 [x,y,w]，加入 x→y (成本w) 和 y→x (成本2w)            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 2：初始化                                                  │
│  - dist[0] = 0，其餘為 ∞                                        │
│  - 將 (0, 0) 加入最小堆                                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 3：取出堆頂元素 (currentDist, x)                           │
└─────────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              ▼                               ▼
     ┌─────────────────┐            ┌─────────────────┐
     │ x == n-1？      │            │ 堆為空？         │
     │ 是 → 返回結果   │            │ 是 → 返回 -1    │
     └─────────────────┘            └─────────────────┘
              │ 否                            │ 否
              ▼                               │
┌─────────────────────────────────────────────────────────────────┐
│  步驟 4：若 x 已訪問則跳過，否則標記為已訪問                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 5：對 x 的所有鄰居進行鬆弛                                 │
│  - 若 dist[x] + w < dist[y]，更新 dist[y] 並加入堆              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              └─────────────→ 回到步驟 3
```

## 範例演示

### 範例 1：基本情況

**輸入**：`n = 3`, `edges = [[0,1,1], [1,2,2]]`

```
原始圖：
0 ──(1)──→ 1 ──(2)──→ 2

轉換後：
0 ──(1)──→ 1 ──(2)──→ 2
  ←─(2)──   ←─(4)──
```

**執行過程**：

| 步驟 | 處理節點 | 當前距離 | dist 陣列 | 說明 |
|------|---------|---------|-----------|------|
| 初始 | - | - | [0, ∞, ∞] | 起點 dist[0] = 0 |
| 1 | 0 | 0 | [0, 1, ∞] | 更新鄰居 dist[1] = 0+1 = 1 |
| 2 | 1 | 1 | [0, 1, 3] | 更新鄰居 dist[2] = 1+2 = 3 |
| 3 | 2 | 3 | [0, 1, 3] | 到達終點！ |

**輸出**：`3`

### 範例 2：需要反轉邊

**輸入**：`n = 3`, `edges = [[1,0,5], [1,2,3]]`

```
原始圖：
1 ──(5)──→ 0
1 ──(3)──→ 2

轉換後：
0 ←──(5)── 1 ──(3)──→ 2
  ──(10)─→   ←─(6)──
```

**執行過程**：

| 步驟 | 處理節點 | 當前距離 | dist 陣列 | 說明 |
|------|---------|---------|-----------|------|
| 初始 | - | - | [0, ∞, ∞] | 起點 dist[0] = 0 |
| 1 | 0 | 0 | [0, 10, ∞] | 更新鄰居 dist[1] = 0+10 = 10（透過反向邊） |
| 2 | 1 | 10 | [0, 10, 13] | 更新鄰居 dist[2] = 10+3 = 13 |
| 3 | 2 | 13 | [0, 10, 13] | 到達終點！ |

**輸出**：`13`

### 複雜度分析（解法一）

| 類型 | 複雜度 | 說明 |
|------|--------|------|
| 時間 | O(m log m) | m 為邊的數量；每條邊最多被處理一次，堆操作為 O(log m) |
| 空間 | O(n + m) | 鄰接表 O(n + m)，距離陣列 O(n)，堆最壞 O(m) |

---

## 解法二：標準 Dijkstra（無堆優化）

### 核心差異

標準 Dijkstra 是最基礎的實作方式，不使用優先佇列（堆），而是在每次迭代時**線性搜尋**所有未訪問節點來找出距離最小的節點。

#### 與優化版的關鍵區別

| 操作 | 標準版（解法二） | 優化版（解法一） |
|------|----------------|----------------|
| 找最小距離節點 | 遍歷所有未訪問節點 O(n) | 從堆中取出 O(log n) |
| 更新鄰居距離 | 直接更新 dist 陣列 | 更新 dist 並加入堆 |
| 迭代次數 | 固定 n 次 | 最多處理所有邊 |
| 提前終止 | 可在找到終點後終止 | 可在首次到達終點時返回 |

### 演算法步驟

**標準 Dijkstra 的執行流程：**

1. **初始化階段**
   - 建立鄰接表（同解法一，正向邊 + 反向邊）
   - 初始化 `dist` 陣列，起點為 0，其餘為 ∞
   - 初始化 `visited` 陣列，所有節點標記為未訪問

2. **主迴圈**（執行 n 次迭代）
   ```
   for iteration = 1 to n:
       a. 線性搜尋找出未訪問且距離最小的節點 u
       b. 若找不到可達節點，跳出迴圈
       c. 標記 u 為已訪問
       d. 對 u 的所有鄰居進行鬆弛操作
   ```

3. **返回結果**
   - 檢查 `dist[n-1]`，若為 ∞ 則返回 -1，否則返回該距離

### 流程圖（標準版）

```text
┌─────────────────────────────────────────────────────────────────┐
│                         開始                                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 1：建立鄰接表（同解法一）                                  │
│  - 對每條邊 [x,y,w]，加入 x→y (成本w) 和 y→x (成本2w)            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 2：初始化                                                  │
│  - dist[0] = 0，其餘為 ∞                                        │
│  - visited[] 全部為 false                                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 3：開始 n 次迭代                                           │
│  iteration = 0, 1, 2, ..., n-1                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 4：【線性搜尋】找最小距離節點                               │
│  for v in 0 to n-1:                                             │
│      if !visited[v] && dist[v] < minDist:                       │
│          u = v, minDist = dist[v]                               │
└─────────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              ▼                               ▼
     ┌─────────────────┐            ┌─────────────────┐
     │ 找到節點 u？    │            │ 找不到節點       │
     │ (u != -1)       │            │ → 跳出迴圈       │
     └─────────────────┘            └─────────────────┘
              │ 是                            │
              ▼                               │
┌─────────────────────────────────────────────────────────────────┐
│  步驟 5：標記 u 為已訪問                                         │
│  visited[u] = true                                              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 6：鬆弛操作（同解法一）                                     │
│  for each neighbor (v, w) of u:                                 │
│      if dist[u] + w < dist[v]:                                  │
│          dist[v] = dist[u] + w                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              └─────────────→ 回到步驟 3（下一次迭代）
                                              │
                                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 7：返回結果                                                │
│  return dist[n-1] == ∞ ? -1 : dist[n-1]                         │
└─────────────────────────────────────────────────────────────────┘
```

### 範例演示（標準版）

#### 範例 1：基本情況

**輸入**：`n = 3`, `edges = [[0,1,1], [1,2,2]]`

```text
轉換後的圖：
0 ──(1)──→ 1 ──(2)──→ 2
  ←─(2)──   ←─(4)──
```

**標準版執行過程**：

| 迭代 | 線性搜尋找最小節點 | 選中節點 u | visited 狀態 | dist 陣列 | 鬆弛操作 |
|------|-------------------|-----------|-------------|-----------|---------|
| 初始 | - | - | [F, F, F] | [0, ∞, ∞] | - |
| 1 | 掃描 0,1,2 → 選 0 (dist=0) | 0 | [T, F, F] | [0, 1, ∞] | 更新 dist[1]=1 |
| 2 | 掃描 1,2 → 選 1 (dist=1) | 1 | [T, T, F] | [0, 1, 3] | 更新 dist[2]=3 |
| 3 | 掃描 2 → 選 2 (dist=3) | 2 | [T, T, T] | [0, 1, 3] | 無鄰居需更新 |

**輸出**：`dist[2] = 3`

---

#### 範例 2：需要反轉邊

**輸入**：`n = 3`, `edges = [[1,0,5], [1,2,3]]`

```text
轉換後的圖：
0 ←──(5)── 1 ──(3)──→ 2
  ──(10)─→   ←─(6)──
```

**標準版執行過程**：

| 迭代 | 線性搜尋找最小節點 | 選中節點 u | visited 狀態 | dist 陣列 | 鬆弛操作 |
|------|-------------------|-----------|-------------|-----------|---------|
| 初始 | - | - | [F, F, F] | [0, ∞, ∞] | - |
| 1 | 掃描 0,1,2 → 選 0 (dist=0) | 0 | [T, F, F] | [0, 10, ∞] | 更新 dist[1]=10（反向邊）|
| 2 | 掃描 1,2 → 選 1 (dist=10) | 1 | [T, T, F] | [0, 10, 13] | 更新 dist[2]=13 |
| 3 | 掃描 2 → 選 2 (dist=13) | 2 | [T, T, T] | [0, 10, 13] | 無鄰居需更新 |

**輸出**：`dist[2] = 13`

---

#### 兩種解法執行對比

以範例 1 為例，比較兩種解法在「找最小距離節點」這一步的差異：

**解法一（優化版）：**
```text
迭代 1: pq.Dequeue() → 直接取出 (0, node=0)，時間 O(log n)
迭代 2: pq.Dequeue() → 直接取出 (1, node=1)，時間 O(log n)
迭代 3: pq.Dequeue() → 直接取出 (3, node=2)，時間 O(log n)
```

**解法二（標準版）：**
```text
迭代 1: 掃描 [0,∞,∞] → 找到 0，時間 O(n)
迭代 2: 掃描 [已訪問,1,∞] → 找到 1，時間 O(n)
迭代 3: 掃描 [已訪問,已訪問,3] → 找到 2，時間 O(n)
```

### 複雜度分析（解法二）

| 類型 | 複雜度 | 說明 |
|------|--------|------|
| 時間 | O(n²) | n 次迭代，每次線性搜尋需 O(n)；鬆弛操作總計 O(m) |
| 空間 | O(n + m) | 鄰接表 O(n + m)，距離陣列 O(n)，visited 陣列 O(n) |

#### 時間複雜度詳細分析

- **外層迴圈**：固定執行 n 次
- **線性搜尋**：每次 O(n)，總計 O(n²)
- **鬆弛操作**：所有迭代中，每條邊最多被鬆弛一次，總計 O(m)
- **總時間**：O(n²) + O(m) = **O(n²)**（n² 主導）

#### 何時使用標準版？

- ✅ **學習目的**：理解 Dijkstra 的核心邏輯
- ✅ **稠密圖**：當 m ≈ n² 時，O(n²) 與 O(m log m) 相近
- ✅ **節點數少**：n < 100 時，性能差異不明顯
- ❌ **稀疏圖**：m << n² 時，優化版明顯更快

---

## 兩種解法的程式碼對比

### 關鍵程式碼片段比較

**找最小距離節點：**

```csharp
// 解法一：優化版（O(log n)）
var current = pq.Dequeue();
int currentDist = current.dist;
int u = current.node;

// 解法二：標準版（O(n)）
int u = -1;
int minDist = int.MaxValue;
for (int v = 0; v < n; v++)
{
    if (!visited[v] && dist[v] < minDist)
    {
        minDist = dist[v];
        u = v;
    }
}
```

**更新鄰居距離：**

```csharp
// 解法一：需要將更新後的節點加入堆
if (currentDist + w < dist[y])
{
    dist[y] = currentDist + w;
    pq.Enqueue((dist[y], y), dist[y]);  // 加入堆
}

// 解法二：只更新陣列，下次迭代會重新掃描
if (dist[u] + w < dist[v])
{
    dist[v] = dist[u] + w;  // 僅更新，不需入堆
}
```

---

## 複雜度分析總覽

### 兩種解法的複雜度對比

| 解法 | 時間複雜度 | 空間複雜度 | 說明 |
|------|-----------|-----------|------|
| 解法一（優化版） | O(m log m) | O(n + m) | 堆操作為 O(log m)，每條邊最多處理一次 |
| 解法二（標準版） | O(n²) | O(n + m) | 每次迭代線性搜尋 O(n)，共 n 次 |

### 性能選擇建議

**選擇解法一（優化版）當：**
- 圖為稀疏圖（m << n²）
- 需要最佳性能
- 已熟悉堆資料結構

**選擇解法二（標準版）當：**
- 學習 Dijkstra 演算法的基本原理
- 圖為稠密圖（m ≈ n²）
- 節點數較少（n < 100）

---

## 補充：Dijkstra 演算法

### 演算法簡介

**Dijkstra 演算法**是由荷蘭電腦科學家 Edsger W. Dijkstra 於 1956 年提出的經典圖論演算法，用於解決**單源最短路徑問題**（Single Source Shortest Path, SSSP）。

### 適用條件

- 圖可以是有向或無向
- **邊的權重必須為非負數**
- 適用於稠密圖或稀疏圖

> [!WARNING]
> Dijkstra 演算法不適用於含有負權邊的圖。對於負權邊的情況，應使用 Bellman-Ford 演算法。

### 核心思想：貪心策略

Dijkstra 的核心思想是**貪心**：每次選擇當前未訪問節點中距離最小的節點，確定其最短路徑，然後用它來更新其鄰居的距離。

### 正確性證明

**為什麼貪心策略是正確的？**

假設當前從堆中取出距離最小的未訪問節點 `u`，其距離為 `d[u]`。

反證法：假設存在一條更短的路徑從起點到 `u`。
- 這條路徑必然經過某個尚未訪問的中間節點 `v`
- 但根據貪心選擇，`d[v] >= d[u]`
- 又因為邊權非負，所以經過 `v` 再到 `u` 的距離 `>= d[v] >= d[u]`
- 矛盾！

因此，第一次訪問節點時的距離就是最短距離。

### 優化版本比較

| 實作方式 | 時間複雜度 | 適用場景 |
|---------|-----------|---------|
| 樸素版（陣列） | O(n²) | 稠密圖 |
| 最小堆優化 | O(m log n) | 稀疏圖 |
| 斐波那契堆 | O(m + n log n) | 理論最優，實際較少使用 |

### 程式碼模板

```csharp
public int[] Dijkstra(int n, List<(int node, int weight)>[] graph, int start)
{
    int[] dist = new int[n];
    Array.Fill(dist, int.MaxValue);
    dist[start] = 0;
    
    var pq = new PriorityQueue<(int dist, int node), int>();
    pq.Enqueue((0, start), 0);
    
    bool[] visited = new bool[n];
    
    while (pq.Count > 0)
    {
        var (d, u) = pq.Dequeue();
        
        if (visited[u]) continue;
        visited[u] = true;
        
        foreach (var (v, w) in graph[u])
        {
            if (d + w < dist[v])
            {
                dist[v] = d + w;
                pq.Enqueue((dist[v], v), dist[v]);
            }
        }
    }
    
    return dist;
}
```

## 執行專案

### 環境需求

- .NET 10.0 或以上版本

### 建構與執行

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run --project leetcode_3650/leetcode_3650.csproj
```
