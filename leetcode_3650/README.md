# LeetCode 3650 - 邊反轉的最小路徑總成本

## 題目描述

給你一個有向加權圖，節點標號為 `0` 到 `n - 1`，`edges` 陣列中 `edges[i] = [ui, vi, wi]` 表示從節點 `ui` 到節點 `vi` 的有向邊，權重（成本）為 `wi`。

每個節點 `ui` 都有一個開關且**最多可使用一次**：當你抵達 `ui` 且尚未使用過其開關時，你可以在其中一條指向 `ui` 的入邊 `vi → ui` 上啟動開關，將該邊反向為 `ui → vi` 並立即沿此邊移動。

> [!NOTE]
> - 該反轉僅對那一次移動有效
> - 使用反轉邊的成本為 `2 * wi`

**目標**：返回從節點 `0` 到節點 `n - 1` 的最小總成本；若無法到達則返回 `-1`。

### 題目連結

- [LeetCode (英文)](https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/)
- [力扣 (中文)](https://leetcode.cn/problems/minimum-cost-path-with-edge-reversals/)

## 解題思路

### 關鍵觀察

本題的關鍵洞察是：**Dijkstra 演算法中每個節點最多只會被處理一次**（第一次出堆即為最短距離），因此我們不需要額外追蹤：

1. 每個節點的開關是否已使用
2. 邊反轉的有效性範圍

### 核心轉換

將問題轉換為標準的單源最短路徑問題：

對於每條原始邊 `[x, y, w]`，在圖中加入兩條邊：

| 邊類型 | 方向 | 成本 | 說明 |
|--------|------|------|------|
| 正向邊 | x → y | w | 正常走此邊 |
| 反向邊 | y → x | 2w | 在 y 點使用開關，反轉邊後走 |

```
原始圖：                    轉換後的圖：
    w                           w
x ────→ y               x ────────→ y
                          ←────────
                            2w
```

這樣，問題就轉化為在新圖上求從節點 `0` 到節點 `n-1` 的最短路徑。

## 演算法流程

### 步驟說明

1. **建圖**：建立鄰接表，對每條邊同時加入正向邊和反向邊
2. **初始化**：設定距離陣列，起點距離為 0，其餘為無限大
3. **Dijkstra**：使用最小堆進行鬆弛操作
4. **返回結果**：到達終點時返回距離，否則返回 -1

### 流程圖

```
┌─────────────────────────────────────────────────────────────────┐
│                         開始                                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 1：建立鄰接表                                              │
│  - 對每條邊 [x,y,w]，加入 x→y (成本w) 和 y→x (成本2w)            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 2：初始化                                                  │
│  - dist[0] = 0，其餘為 ∞                                        │
│  - 將 (0, 0) 加入最小堆                                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 3：取出堆頂元素 (currentDist, x)                           │
└─────────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              ▼                               ▼
     ┌─────────────────┐            ┌─────────────────┐
     │ x == n-1？      │            │ 堆為空？         │
     │ 是 → 返回結果   │            │ 是 → 返回 -1    │
     └─────────────────┘            └─────────────────┘
              │ 否                            │ 否
              ▼                               │
┌─────────────────────────────────────────────────────────────────┐
│  步驟 4：若 x 已訪問則跳過，否則標記為已訪問                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  步驟 5：對 x 的所有鄰居進行鬆弛                                 │
│  - 若 dist[x] + w < dist[y]，更新 dist[y] 並加入堆              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              └─────────────→ 回到步驟 3
```

## 範例演示

### 範例 1：基本情況

**輸入**：`n = 3`, `edges = [[0,1,1], [1,2,2]]`

```
原始圖：
0 ──(1)──→ 1 ──(2)──→ 2

轉換後：
0 ──(1)──→ 1 ──(2)──→ 2
  ←─(2)──   ←─(4)──
```

**執行過程**：

| 步驟 | 處理節點 | 當前距離 | dist 陣列 | 說明 |
|------|---------|---------|-----------|------|
| 1 | 0 | 0 | [0, ∞, ∞] | 起點 |
| 2 | 0 | 0 | [0, 1, ∞] | 更新 dist[1] = 0+1 = 1 |
| 3 | 1 | 1 | [0, 1, 3] | 更新 dist[2] = 1+2 = 3 |
| 4 | 2 | 3 | [0, 1, 3] | 到達終點！ |

**輸出**：`3`

### 範例 2：需要反轉邊

**輸入**：`n = 3`, `edges = [[1,0,5], [1,2,3]]`

```
原始圖：
1 ──(5)──→ 0
1 ──(3)──→ 2

轉換後：
0 ←──(5)── 1 ──(3)──→ 2
  ──(10)─→   ←─(6)──
```

**執行過程**：

| 步驟 | 處理節點 | 當前距離 | dist 陣列 | 說明 |
|------|---------|---------|-----------|------|
| 1 | 0 | 0 | [0, ∞, ∞] | 起點 |
| 2 | 0 | 0 | [0, 10, ∞] | 透過反向邊更新 dist[1] = 0+10 = 10 |
| 3 | 1 | 10 | [0, 10, 13] | 更新 dist[2] = 10+3 = 13 |
| 4 | 2 | 13 | [0, 10, 13] | 到達終點！ |

**輸出**：`13`

## 複雜度分析

| 類型 | 複雜度 | 說明 |
|------|--------|------|
| 時間 | O(m log m) | m 為邊的數量；每條邊最多被處理一次，堆操作為 O(log m) |
| 空間 | O(n + m) | 鄰接表 O(n + m)，距離陣列 O(n)，堆最壞 O(m) |

## 補充：Dijkstra 演算法

### 演算法簡介

**Dijkstra 演算法**是由荷蘭電腦科學家 Edsger W. Dijkstra 於 1956 年提出的經典圖論演算法，用於解決**單源最短路徑問題**（Single Source Shortest Path, SSSP）。

### 適用條件

- 圖可以是有向或無向
- **邊的權重必須為非負數**
- 適用於稠密圖或稀疏圖

> [!WARNING]
> Dijkstra 演算法不適用於含有負權邊的圖。對於負權邊的情況，應使用 Bellman-Ford 演算法。

### 核心思想：貪心策略

Dijkstra 的核心思想是**貪心**：每次選擇當前未訪問節點中距離最小的節點，確定其最短路徑，然後用它來更新其鄰居的距離。

### 正確性證明

**為什麼貪心策略是正確的？**

假設當前從堆中取出距離最小的未訪問節點 `u`，其距離為 `d[u]`。

反證法：假設存在一條更短的路徑從起點到 `u`。
- 這條路徑必然經過某個尚未訪問的中間節點 `v`
- 但根據貪心選擇，`d[v] >= d[u]`
- 又因為邊權非負，所以經過 `v` 再到 `u` 的距離 `>= d[v] >= d[u]`
- 矛盾！

因此，第一次訪問節點時的距離就是最短距離。

### 優化版本比較

| 實作方式 | 時間複雜度 | 適用場景 |
|---------|-----------|---------|
| 樸素版（陣列） | O(n²) | 稠密圖 |
| 最小堆優化 | O(m log n) | 稀疏圖 |
| 斐波那契堆 | O(m + n log n) | 理論最優，實際較少使用 |

### 程式碼模板

```csharp
public int[] Dijkstra(int n, List<(int node, int weight)>[] graph, int start)
{
    int[] dist = new int[n];
    Array.Fill(dist, int.MaxValue);
    dist[start] = 0;
    
    var pq = new PriorityQueue<(int dist, int node), int>();
    pq.Enqueue((0, start), 0);
    
    bool[] visited = new bool[n];
    
    while (pq.Count > 0)
    {
        var (d, u) = pq.Dequeue();
        
        if (visited[u]) continue;
        visited[u] = true;
        
        foreach (var (v, w) in graph[u])
        {
            if (d + w < dist[v])
            {
                dist[v] = d + w;
                pq.Enqueue((dist[v], v), dist[v]);
            }
        }
    }
    
    return dist;
}
```

## 執行專案

### 環境需求

- .NET 10.0 或以上版本

### 建構與執行

```bash
# 建構專案
dotnet build

# 執行程式
dotnet run --project leetcode_3650/leetcode_3650.csproj
```
