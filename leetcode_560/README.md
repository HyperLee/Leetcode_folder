# LeetCode 560 - 和為 K 的子數組

> [LeetCode 560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)

## 題目描述

給定一個整數陣列 `nums` 和一個整數 `k`，回傳總共有多少個連續子陣列的和等於 `k`。

**子陣列**是陣列中元素的連續非空序列。

### 範例

**範例 1:**

```text
輸入: nums = [1,1,1], k = 2
輸出: 2
解釋: 符合條件的子陣列為 [1,1] 和 [1,1]
```

**範例 2:**

```text
輸入: nums = [1,2,3], k = 3
輸出: 2
解釋: 符合條件的子陣列為 [1,2] 和 [3]
```

**範例 3:**

```text
輸入: nums = [1,-1,0], k = 0
輸出: 3
解釋: 符合條件的子陣列為 [1,-1]、[-1,0] 和 [0]
```

### 限制條件

- `1 <= nums.length <= 2 * 10^4`
- `-1000 <= nums[i] <= 1000`
- `-10^7 <= k <= 10^7`

## 解題概念

### 問題核心

這道題目的核心是要找出所有和為 `k` 的**連續子陣列**。關鍵在於「連續」這個條件，這意味著我們需要考慮陣列中所有可能的連續區間。

### 解題出發點

對於任意位置 `i`，我們可以思考：

- 以位置 `i` 為結尾，有多少個子陣列的和等於 `k`？
- 這需要我們找出所有滿足條件的起始位置 `j`，其中 `0 ≤ j ≤ i` 且 `sum[j...i] = k`

## 解法一：枚舉法

### 演算法思路

枚舉法的核心思想是：**考慮以每個位置 i 結尾的所有子陣列**。

1. **外層迴圈**：遍歷每個可能的結尾位置 `start` (0 到 n-1)
2. **內層迴圈**：從當前結尾位置 `start` 反向枚舉起始位置 `end` (從 start 到 0)
3. **累加計算**：在反向枚舉過程中逐步累加元素，得到 `[end, start]` 區間的和
4. **條件判斷**：如果區間和等於 `k`，計數器加 1

### 優化技巧

> [!IMPORTANT]
> 這個方法的關鍵優化在於：如果我們已知 `[j, i]` 的和，可以在 **O(1)** 時間內推出 `[j-1, i]` 的和。

因此，我們不需要對每個子陣列都重新遍歷求和（那樣會是 O(n³)），而是在枚舉起始位置的過程中**逐步累加**，時間複雜度降至 O(n²)。

### 實作程式碼

```csharp
public int SubarraySum(int[] nums, int k)
{
    int count = 0;
    
    // 枚舉每個結尾位置 i
    for(int start = 0; start < nums.Length; start++)
    {
        int sum = 0;
        
        // 從當前位置 start 反向枚舉起始位置 end
        // 這樣可以逐步累加元素，避免重複計算
        for(int end = start; end >= 0; end--)
        {
            // 將當前元素加入總和
            // 此時 sum 代表 [end, start] 區間的和
            sum += nums[end];
            
            // 如果區間和等於目標值 k，計數器加 1
            if(sum == k)
            {
                count++;
            }
        }
    }
    
    return count;
}
```

### 複雜度分析

- **時間複雜度**：O(n²)
  - 外層迴圈遍歷 n 個位置
  - 內層迴圈最多遍歷 n 個位置
  - 總共約 n²/2 次操作
  
- **空間複雜度**：O(1)
  - 只使用固定的額外變數 `count` 和 `sum`
  - 不需要額外的資料結構

### 演示範例

以 `nums = [1, 2, 3]`, `k = 3` 為例：

```text
Step 1: start = 0 (元素 1)
  end = 0: sum = 1, 不等於 3
  
Step 2: start = 1 (元素 2)
  end = 1: sum = 2, 不等於 3
  end = 0: sum = 2 + 1 = 3 ✓ (找到 [1,2])
  count = 1
  
Step 3: start = 2 (元素 3)
  end = 2: sum = 3 ✓ (找到 [3])
  count = 2
  end = 1: sum = 3 + 2 = 5, 不等於 3
  end = 0: sum = 5 + 1 = 6, 不等於 3

最終結果: count = 2
符合的子陣列: [1,2] 和 [3]
```

### 詳細流程圖

```text
nums = [1, 1, 1], k = 2

迭代過程:
┌─────────┬──────────┬─────────┬──────────┬───────┐
│ start   │ end      │ sum     │ sum == k │ count │
├─────────┼──────────┼─────────┼──────────┼───────┤
│ 0       │ 0        │ 1       │ No       │ 0     │
├─────────┼──────────┼─────────┼──────────┼───────┤
│ 1       │ 1        │ 1       │ No       │ 0     │
│         │ 0        │ 2       │ Yes ✓    │ 1     │
├─────────┼──────────┼─────────┼──────────┼───────┤
│ 2       │ 2        │ 1       │ No       │ 1     │
│         │ 1        │ 2       │ Yes ✓    │ 2     │
│         │ 0        │ 3       │ No       │ 2     │
└─────────┴──────────┴─────────┴──────────┴───────┘

找到的子陣列:
- [1, 1] (索引 0-1)
- [1, 1] (索引 1-2)
```

## 執行與測試

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run --project leetcode_560/leetcode_560.csproj
```

### 預期輸出

```text
測試案例 1: nums = [1,1,1], k = 2, 結果 = 2 (預期: 2)
測試案例 2: nums = [1,2,3], k = 3, 結果 = 2 (預期: 2)
測試案例 3: nums = [1,-1,0], k = 0, 結果 = 3 (預期: 3)
```

## 解法二：前綴和 + 雜湊表優化

### 問題分析

方法一的瓶頸在於：對於每個位置 `i`，我們需要枚舉所有的位置 `j` 來判斷 `[j, i]` 區間的和是否等於 `k`。這個過程能否優化呢？答案是可以的。

### 核心思路

#### 前綴和的定義

我們定義 `pre[i]` 為從索引 0 到 i 的所有元素之和，即：

$$
pre[i] = nums[0] + nums[1] + ... + nums[i]
$$

前綴和可以通過遞推計算：

$$
pre[i] = pre[i-1] + nums[i]
$$

#### 條件轉換

對於子陣列 `[j..i]` 的和等於 `k` 這個條件，可以用前綴和表示：

$$
sum[j..i] = pre[i] - pre[j-1] = k
$$

移項後得到：

$$
pre[j-1] = pre[i] - k
$$

這意味著：**當我們處理到位置 i 時，只需要統計有多少個位置 j-1 的前綴和等於 `pre[i] - k`，就能知道有多少個以 i 結尾且和為 k 的子陣列。**

### 雜湊表優化

為了快速查詢某個前綴和出現的次數，我們使用雜湊表（Dictionary）：

- **鍵 (Key)**：前綴和的值
- **值 (Value)**：該前綴和出現的次數

這樣就能在 **O(1)** 時間內查詢 `pre[i] - k` 出現了多少次。

### 為什麼要初始化 `map[0] = 1`？

初始化 `map[0] = 1` 表示前綴和為 0 出現過 1 次，這對應**空陣列**的情況。

考慮這樣的場景：
- 如果從索引 0 到 i 的和正好等於 k，即 `pre[i] = k`
- 此時 `pre[i] - k = 0`
- 如果沒有初始化 `map[0] = 1`，就會漏掉這種情況

### 演算法流程

1. **初始化**：
   - `count = 0`：記錄符合條件的子陣列數量
   - `pre = 0`：當前的前綴和
   - `map`：雜湊表，記錄前綴和出現次數
   - `map[0] = 1`：初始化前綴和為 0 的次數

2. **從左到右遍歷陣列**：
   - 更新前綴和：`pre += nums[i]`
   - 查詢雜湊表：如果 `pre - k` 存在於雜湊表中，說明找到了符合條件的子陣列
   - 累加計數：`count += map[pre - k]`
   - 更新雜湊表：將當前前綴和加入或更新其出現次數

3. **返回結果**：返回 `count`

### 實作程式碼

```csharp
public int SubarraySum2(int[] nums, int k)
{
    int count = 0;
    int pre = 0;

    Dictionary<int, int> map = new Dictionary<int, int>();
    map[0] = 1;  // 初始化：前綴和為 0 出現過 1 次

    for(int i = 0; i < nums.Length; i++)
    {
        // 更新前綴和
        pre += nums[i];
        
        // 查找是否存在前綴和為 (pre - k) 的位置
        if(map.ContainsKey(pre - k))
        {
            count += map[pre - k];
        }

        // 更新雜湊表
        if(map.ContainsKey(pre))
        {
            map[pre]++;
        }
        else
        {
            map[pre] = 1;
        }
    }
    
    return count;
}
```

### 複雜度分析

- **時間複雜度**：O(n)
  - 只需遍歷一次陣列
  - 雜湊表的查詢和插入操作都是 O(1)
  
- **空間複雜度**：O(n)
  - 雜湊表最多存儲 n 個不同的前綴和
  - 相比方法一犧牲了空間換取時間

### 演示範例

以 `nums = [1, 1, 1]`, `k = 2` 為例：

```text
初始狀態:
count = 0, pre = 0, map = {0: 1}

Step 1: i = 0, nums[0] = 1
  pre = 0 + 1 = 1
  查找 pre - k = 1 - 2 = -1 => 不存在於 map
  更新 map: {0: 1, 1: 1}
  count = 0

Step 2: i = 1, nums[1] = 1
  pre = 1 + 1 = 2
  查找 pre - k = 2 - 2 = 0 => 存在於 map，出現 1 次 ✓
  count = 0 + 1 = 1  (找到子陣列 [1,1]，索引 0-1)
  更新 map: {0: 1, 1: 1, 2: 1}

Step 3: i = 2, nums[2] = 1
  pre = 2 + 1 = 3
  查找 pre - k = 3 - 2 = 1 => 存在於 map，出現 1 次 ✓
  count = 1 + 1 = 2  (找到子陣列 [1,1]，索引 1-2)
  更新 map: {0: 1, 1: 1, 2: 1, 3: 1}

最終結果: count = 2
符合的子陣列: [1,1] (索引 0-1) 和 [1,1] (索引 1-2)
```

### 詳細流程圖

```text
nums = [1, 2, 3], k = 3

迭代過程:
┌─────┬────────┬─────────────┬───────────────────────┬─────────────────────────┬───────┐
│  i  │ nums[i]│  pre        │  pre - k              │  map 狀態               │ count │
├─────┼────────┼─────────────┼───────────────────────┼─────────────────────────┼───────┤
│初始 │   -    │  0          │  -                    │ {0: 1}                  │  0    │
├─────┼────────┼─────────────┼───────────────────────┼─────────────────────────┼───────┤
│  0  │   1    │  1          │  1 - 3 = -2 (不存在)  │ {0: 1, 1: 1}            │  0    │
├─────┼────────┼─────────────┼───────────────────────┼─────────────────────────┼───────┤
│  1  │   2    │  3          │  3 - 3 = 0 (存在 1次)✓│ {0: 1, 1: 1, 3: 1}      │  1    │
├─────┼────────┼─────────────┼───────────────────────┼─────────────────────────┼───────┤
│  2  │   3    │  6          │  6 - 3 = 3 (存在 1次)✓│ {0: 1, 1: 1, 3: 1, 6: 1}│  2    │
└─────┴────────┴─────────────┴───────────────────────┴─────────────────────────┴───────┘

找到的子陣列:
- [1, 2] (索引 0-1): pre[1] - pre[-1] = 3 - 0 = 3 ✓
- [3] (索引 2-2): pre[2] - pre[1] = 6 - 3 = 3 ✓
```

### 關鍵理解點

#### 1. 為什麼從左到右邊更新邊計算？

這樣可以確保 `map[pre - k]` 記錄的前綴和索引範圍是 `0 ≤ j ≤ i`，符合題目要求的連續子陣列條件。

#### 2. 為什麼不需要建立 `pre` 陣列？

因為 `pre[i]` 的計算只與 `pre[i-1]` 有關，我們只需要用一個變數 `pre` 記錄當前的前綴和即可，節省空間。

#### 3. 雜湊表為何要記錄出現次數？

同一個前綴和可能在不同位置出現多次。例如：
- `nums = [1, -1, 1]`, `k = 1`
- 索引 0：`pre = 1`
- 索引 1：`pre = 0`
- 索引 2：`pre = 1`（再次出現）

當處理索引 2 時，需要知道前綴和為 1 出現了多少次（這裡是 1 次），才能正確計算符合條件的子陣列數量。

### 方法比較

| 方法 | 時間複雜度 | 空間複雜度 | 優點 | 缺點 |
|------|-----------|-----------|------|------|
| 方法一：枚舉 | O(n²) | O(1) | 實作簡單，空間效率高 | 大資料量下效能差 |
| 方法二：前綴和 + 雜湊表 | O(n) | O(n) | 時間效率高，適合大資料 | 需要額外空間 |

### 什麼時候用哪種方法？

- **資料量小**（n < 1000）：兩種方法效能差異不大，優先選擇**方法一**（程式碼簡潔）
- **資料量大**（n ≥ 10000）：必須使用**方法二**（避免超時）
- **記憶體受限**：使用**方法一**
- **追求最佳效能**：使用**方法二**

## 專案結構

```text
leetcode_560/
├── leetcode_560.sln          # 解決方案檔案
├── README.md                  # 專案說明文件
└── leetcode_560/
    ├── leetcode_560.csproj    # 專案檔案
    └── Program.cs             # 主程式碼
```

## 技術棧

- .NET 10.0
- C# 14

## 參考資源

- [LeetCode 560 - Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)
- [LeetCode CN - 和為K的子數組](https://leetcode.cn/problems/subarray-sum-equals-k/)
