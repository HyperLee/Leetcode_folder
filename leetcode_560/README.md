# LeetCode 560 - 和為 K 的子數組

> [LeetCode 560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)

## 題目描述

給定一個整數陣列 `nums` 和一個整數 `k`，回傳總共有多少個連續子陣列的和等於 `k`。

**子陣列**是陣列中元素的連續非空序列。

### 範例

**範例 1:**

```text
輸入: nums = [1,1,1], k = 2
輸出: 2
解釋: 符合條件的子陣列為 [1,1] 和 [1,1]
```

**範例 2:**

```text
輸入: nums = [1,2,3], k = 3
輸出: 2
解釋: 符合條件的子陣列為 [1,2] 和 [3]
```

**範例 3:**

```text
輸入: nums = [1,-1,0], k = 0
輸出: 3
解釋: 符合條件的子陣列為 [1,-1]、[-1,0] 和 [0]
```

### 限制條件

- `1 <= nums.length <= 2 * 10^4`
- `-1000 <= nums[i] <= 1000`
- `-10^7 <= k <= 10^7`

## 解題概念

### 問題核心

這道題目的核心是要找出所有和為 `k` 的**連續子陣列**。關鍵在於「連續」這個條件，這意味著我們需要考慮陣列中所有可能的連續區間。

### 解題出發點

對於任意位置 `i`，我們可以思考：

- 以位置 `i` 為結尾，有多少個子陣列的和等於 `k`？
- 這需要我們找出所有滿足條件的起始位置 `j`，其中 `0 ≤ j ≤ i` 且 `sum[j...i] = k`

## 解法一：枚舉法

### 演算法思路

枚舉法的核心思想是：**考慮以每個位置 i 結尾的所有子陣列**。

1. **外層迴圈**：遍歷每個可能的結尾位置 `start` (0 到 n-1)
2. **內層迴圈**：從當前結尾位置 `start` 反向枚舉起始位置 `end` (從 start 到 0)
3. **累加計算**：在反向枚舉過程中逐步累加元素，得到 `[end, start]` 區間的和
4. **條件判斷**：如果區間和等於 `k`，計數器加 1

### 優化技巧

> [!IMPORTANT]
> 這個方法的關鍵優化在於：如果我們已知 `[j, i]` 的和，可以在 **O(1)** 時間內推出 `[j-1, i]` 的和。

因此，我們不需要對每個子陣列都重新遍歷求和（那樣會是 O(n³)），而是在枚舉起始位置的過程中**逐步累加**，時間複雜度降至 O(n²)。

### 實作程式碼

```csharp
public int SubarraySum(int[] nums, int k)
{
    int count = 0;
    
    // 枚舉每個結尾位置 i
    for(int start = 0; start < nums.Length; start++)
    {
        int sum = 0;
        
        // 從當前位置 start 反向枚舉起始位置 end
        // 這樣可以逐步累加元素，避免重複計算
        for(int end = start; end >= 0; end--)
        {
            // 將當前元素加入總和
            // 此時 sum 代表 [end, start] 區間的和
            sum += nums[end];
            
            // 如果區間和等於目標值 k，計數器加 1
            if(sum == k)
            {
                count++;
            }
        }
    }
    
    return count;
}
```

### 複雜度分析

- **時間複雜度**：O(n²)
  - 外層迴圈遍歷 n 個位置
  - 內層迴圈最多遍歷 n 個位置
  - 總共約 n²/2 次操作
  
- **空間複雜度**：O(1)
  - 只使用固定的額外變數 `count` 和 `sum`
  - 不需要額外的資料結構

### 演示範例

以 `nums = [1, 2, 3]`, `k = 3` 為例：

```text
Step 1: start = 0 (元素 1)
  end = 0: sum = 1, 不等於 3
  
Step 2: start = 1 (元素 2)
  end = 1: sum = 2, 不等於 3
  end = 0: sum = 2 + 1 = 3 ✓ (找到 [1,2])
  count = 1
  
Step 3: start = 2 (元素 3)
  end = 2: sum = 3 ✓ (找到 [3])
  count = 2
  end = 1: sum = 3 + 2 = 5, 不等於 3
  end = 0: sum = 5 + 1 = 6, 不等於 3

最終結果: count = 2
符合的子陣列: [1,2] 和 [3]
```

### 詳細流程圖

```text
nums = [1, 1, 1], k = 2

迭代過程:
┌─────────┬──────────┬─────────┬──────────┬───────┐
│ start   │ end      │ sum     │ sum == k │ count │
├─────────┼──────────┼─────────┼──────────┼───────┤
│ 0       │ 0        │ 1       │ No       │ 0     │
├─────────┼──────────┼─────────┼──────────┼───────┤
│ 1       │ 1        │ 1       │ No       │ 0     │
│         │ 0        │ 2       │ Yes ✓    │ 1     │
├─────────┼──────────┼─────────┼──────────┼───────┤
│ 2       │ 2        │ 1       │ No       │ 1     │
│         │ 1        │ 2       │ Yes ✓    │ 2     │
│         │ 0        │ 3       │ No       │ 2     │
└─────────┴──────────┴─────────┴──────────┴───────┘

找到的子陣列:
- [1, 1] (索引 0-1)
- [1, 1] (索引 1-2)
```

## 執行與測試

### 建構專案

```bash
dotnet build
```

### 執行程式

```bash
dotnet run --project leetcode_560/leetcode_560.csproj
```

### 預期輸出

```text
測試案例 1: nums = [1,1,1], k = 2, 結果 = 2 (預期: 2)
測試案例 2: nums = [1,2,3], k = 3, 結果 = 2 (預期: 2)
測試案例 3: nums = [1,-1,0], k = 0, 結果 = 3 (預期: 3)
```

## 優化方向

> [!NOTE]
> 枚舉法雖然直觀易懂，但在大資料量下效能較差。可以考慮使用**前綴和 + 雜湊表**的方法，將時間複雜度優化到 O(n)。

### 進階解法提示

使用前綴和的概念：

- 如果 `prefixSum[i] - prefixSum[j] = k`
- 則 `prefixSum[j] = prefixSum[i] - k`
- 可以使用 HashMap 記錄每個前綴和出現的次數，達到 O(n) 的時間複雜度

## 專案結構

```text
leetcode_560/
├── leetcode_560.sln          # 解決方案檔案
├── README.md                  # 專案說明文件
└── leetcode_560/
    ├── leetcode_560.csproj    # 專案檔案
    └── Program.cs             # 主程式碼
```

## 技術棧

- .NET 10.0
- C# 14

## 參考資源

- [LeetCode 560 - Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)
- [LeetCode CN - 和為K的子數組](https://leetcode.cn/problems/subarray-sum-equals-k/)
