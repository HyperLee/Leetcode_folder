# LeetCode 1975 - 最大方陣和 (Maximum Matrix Sum)

C# 實作解決 LeetCode 1975 問題的專案。

## 問題描述

給定一個 `n x n` 的整數矩陣。你可以任意次數執行下列操作：
- 選擇矩陣中任意兩個相鄰元素（僅在共用邊界時視為相鄰），並將它們各自乘以 -1。

**目標**：使矩陣元素的總和最大化。請回傳在允許上述操作下，矩陣元素能達到的最大總和。

### 範例

**範例 1:**
```
輸入: matrix = [[1,-1],[-1,1]]
輸出: 4
解釋: 我們可以執行以下操作使所有元素變為正數：
- 對 matrix[0][0] 和 matrix[0][1] 執行操作
- 對 matrix[1][0] 和 matrix[1][1] 執行操作
最終矩陣變為 [[1,1],[1,1]]，總和為 4
```

**範例 2:**
```
輸入: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
輸出: 16
解釋: 矩陣中有 3 個負數（奇數個），我們可以將其中 2 個變為正數，
剩下 1 個負數，選擇絕對值最小的 -1，最終總和為 1+2+3+1+2+3+1+2+3-1 = 16
```

## 解題思路

### 核心觀察

雖然題目規定我們只能操作**相鄰的元素**，但我們可以通過多次操作，把**任意兩個元素**都乘以 -1。

**關鍵性質**：
1. 每次操作恰好改變**兩個數**的正負號
2. 多次操作恰好改變**偶數個數**的正負號

### 解法分析

基於上述觀察，我們可以進行分類討論：

#### 情況 1：偶數個負數
如果矩陣有偶數個負數，那麼可以把所有數都變成非負數。
- **最大總和** = 所有元素絕對值之和

#### 情況 2：奇數個負數且沒有 0
如果矩陣有奇數個負數且沒有 0，那麼最終必然剩下一個負數。
- 根據貪心策略，選擇矩陣中**絕對值最小**的數給它加上負號
- **最大總和** = 所有元素絕對值之和 - 2 × 絕對值最小的元素

#### 情況 3：奇數個負數且有 0
如果矩陣有奇數個負數且有 0，那麼可以把最終剩下的一個負數和 0 操作一次，從而把所有數都變成非負數。
- **最大總和** = 所有元素絕對值之和

> [!TIP]
> 實作時無需特判是否有 0。如果有 0，程式碼中的 `mn = 0`，對 `total` 無影響（因為 `total - 2 × 0 = total`）。

### 演算法步驟

1. 遍歷矩陣，計算三個值：
   - `total`：所有元素的絕對值總和
   - `negCnt`：負數的個數
   - `mn`：絕對值最小的元素

2. 根據負數個數的奇偶性返回結果：
   - 偶數：返回 `total`
   - 奇數：返回 `total - 2 × mn`

## 程式碼說明

```csharp
public long MaxMatrixSum(int[][] matrix)
{
    long total = 0;      // 所有元素絕對值的總和
    int negCnt = 0;      // 負數的個數
    int mn = int.MaxValue; // 絕對值最小的元素
    int n = matrix.Length;

    // 遍歷矩陣，計算絕對值總和、負數個數和絕對值最小值
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < n; j++)
        {
            int val = matrix[i][j];
            if(val < 0)
            {
                negCnt++;  // 記錄負數個數
                val = -val; // 轉為絕對值
            }
            mn = Math.Min(mn, val);  // 追蹤絕對值最小的元素
            total += val;            // 累加絕對值
        }
    }

    // 如果負數個數是偶數，可以將所有數變為正數
    if(negCnt % 2 == 0)
    {
        return total;
    }
    else
    {
        // 如果負數個數是奇數，最終必有一個負數，選擇絕對值最小的數變負
        return total - 2L * mn;
    }
}
```

## 複雜度分析

- **時間複雜度**：O(n²)，需要遍歷整個 n × n 矩陣
- **空間複雜度**：O(1)，只使用常數額外空間

## 範例演示

### 範例 1：偶數個負數

```
輸入矩陣:
[ 1, -1]
[-1,  1]

初始狀態：
- 負數個數：2（偶數）
- 絕對值總和：1 + 1 + 1 + 1 = 4
- 絕對值最小值：1

結果：negCnt % 2 == 0，返回 total = 4
```

### 範例 2：奇數個負數

```
輸入矩陣:
[ 1,  2,  3]
[-1, -2, -3]
[ 1,  2,  3]

初始狀態：
- 負數個數：3（奇數）
- 絕對值總和：1 + 2 + 3 + 1 + 2 + 3 + 1 + 2 + 3 = 18
- 絕對值最小值：1

結果：negCnt % 2 == 1，返回 total - 2 * mn = 18 - 2 * 1 = 16
```

### 範例 3：包含 0 的情況

```
輸入矩陣:
[-1,  0, -1]
[-2,  1,  3]
[ 3,  2,  2]

初始狀態：
- 負數個數：3（奇數）
- 絕對值總和：1 + 0 + 1 + 2 + 1 + 3 + 3 + 2 + 2 = 15
- 絕對值最小值：0

結果：negCnt % 2 == 1，返回 total - 2 * mn = 15 - 2 * 0 = 15

說明：由於 mn = 0，減去 2 * 0 對結果無影響，
這相當於我們可以將最後剩下的負數與 0 操作，達到所有數變正的效果。
```

## 執行方式

```bash
# 建構專案
dotnet build

# 執行專案
dotnet run --project leetcode_1975/leetcode_1975.csproj
```

### 預期輸出

```
測試案例 1: 4
測試案例 2: 16
測試案例 3: 15
```

## 開發環境

- .NET 10.0
- C# 14

## 相關連結

- [LeetCode 1975 - 英文](https://leetcode.com/problems/maximum-matrix-sum/description/?envType=daily-question&envId=2026-01-05)
- [LeetCode 1975 - 中文](https://leetcode.cn/problems/maximum-matrix-sum/description/?envType=daily-question&envId=2026-01-05)
