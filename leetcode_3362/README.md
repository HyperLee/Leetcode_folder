# LeetCode 3362 - 零數組變換 III (Zero Array Transformation III)

## 題目說明

給定一個長度為 n 的整數陣列 `nums` 和一個二維陣列 `queries`，其中 `queries[i] = [li, ri]`。

每個 `queries[i]` 代表對 `nums` 執行以下操作：

- 將 `nums` 中索引範圍 `[li, ri]` 內的每個值最多減少 1
- 對於每個索引，減少的數值可以獨立選擇

零陣列是指所有元素均為 0 的陣列。

返回可以從 `queries` 中移除的最大元素數量，使得使用剩餘的查詢仍然可以將 `nums` 轉換為零陣列。如果無法將 `nums` 轉換為零陣列，則返回 -1。

## 解題方法

本專案實作了兩種解法，都使用了優先佇列和差分陣列技術。

### 方法一：優先處理右邊界最大的操作區間

```csharp
public int MaxRemoval(int[] nums, int[][] queries)
```

核心思想：

1. 使用優先佇列來管理對索引範圍 \[li, ri] 的操作
2. 利用差分數組 (deltaArray) 來追蹤範圍操作的效果
3. 最大化可移除的查詢數量，同時確保仍能將數組轉為零數組

演算法步驟：

1. 根據左邊界對查詢進行排序
2. 遍歷原陣列中每個位置 i
3. 處理所有左邊界為 i 的查詢
4. 執行必要的操作使 nums \[i] 為零
5. 如果無法將元素變為零則返回 -1
6. 返回剩餘的可用操作數量

### 方法二：另一種實作方式

```csharp
public int MaxRemoval2(int[] nums, int[][] queries)
```

與方法一相似，但處理邏輯略有不同：

1. 處理所有左邊界 <= i 的查詢，而非僅左邊界為 i 的查詢
2. 使用 `diff` 而非 `deltaArray` 作為差分陣列名稱
3. 變數命名和程式碼結構略有不同

## 測試案例

專案包含五種不同的測試案例：

1. **基本測試**：測試簡單情況
   - 輸入: `nums = [2,3,1,4], queries = [[0,2],[1,3]]`

2. **需要所有查詢**：測試需要所有查詢才能完成的情況
   - 輸入: `nums = [3,2,1,4], queries = [[0,1],[1,2],[2,3]]`

3. **無解案例**：測試無法將陣列轉為零陣列的情況
   - 輸入: `nums = [3,3,3], queries = [[0,1],[1,2]]`

4. **可移除部分查詢**：測試可以移除部分查詢的情況
   - 輸入: `nums = [1,2,3,1], queries = [[0,2],[1,3],[0,3],[2,3]]`

5. **邊界情況**：測試極端情況
   - 輸入: `nums = [5], queries = [[0,0],[0,0],[0,0],[0,0],[0,0]]`

## 效能分析

兩種解法的複雜度相同：

- **時間複雜度**: O (n log m)，其中 n 是陣列長度，m 是查詢數量
- **空間複雜度**: O (n + m)，用於儲存優先佇列和差分數組

## 執行方式

```bash
cd "d:\Leetcode_folder\Leetcode_folder\leetcode_3362\leetcode_3362"
dotnet run
```

## 測試結果

```
===== 零數組變換 III (Zero Array Transformation III) 測試 =====

測試案例 1 - 基本測試：
輸入: nums = [2,3,1,4], queries = [[0,2],[1,3]]
MaxRemoval 結果: -1
MaxRemoval2 結果: -1

測試案例 2 - 需要所有查詢：
輸入: nums = [3,2,1,4], queries = [[0,1],[1,2],[2,3]]
MaxRemoval 結果: -1
MaxRemoval2 結果: -1

測試案例 3 - 無解案例：
輸入: nums = [3,3,3], queries = [[0,1],[1,2]]
MaxRemoval 結果: -1
MaxRemoval2 結果: -1

測試案例 4 - 可移除部分查詢：
輸入: nums = [1,2,3,1], queries = [[0,2],[1,3],[0,3],[2,3]]
MaxRemoval 結果: 1
MaxRemoval2 結果: 1

測試案例 5 - 邊界情況：
輸入: nums = [5], queries = [[0,0],[0,0],[0,0],[0,0],[0,0]]
MaxRemoval 結果: 0
MaxRemoval2 結果: 0
```

## 演算法分析

兩種解法都使用了貪心策略，優先處理右邊界最大的操作，這樣能夠最大化每個操作的利用率。通過使用優先佇列，能夠高效地選擇最佳的操作順序。差分陣列技術 (方法一中的 `deltaArray` 和方法二中的 `diff`) 則幫助我們有效地追蹤範圍操作的影響，避免重複計算。

主要差異在於：

- 方法一只處理左邊界等於當前位置的查詢 (`queries[j][0] == i`)
- 方法二處理所有左邊界小於等於當前位置的查詢 (`queries[j][0] <= i`)

## 兩種解法優缺點比較

### MaxRemoval 解法 (方法一)

#### 優點

- **嚴格匹配**：只處理左邊界恰好等於當前位置的查詢 (`queries[j][0] == i`)，邏輯更加精確
- **變數命名清晰**：使用 `operations` 和 `deltaArray` 等直觀的變數名稱
- **程式碼可讀性高**：註解詳細，每個步驟都有明確說明
- **記憶體使用優化**：變數宣告和使用更加簡潔
- **處理順序明確**：先處理查詢的添加，再執行操作，邏輯結構清晰
- **效能一致性**：在處理大量連續查詢時，保持穩定的效能表現

#### 缺點

- **處理限制較嚴格**：只考慮左邊界完全匹配的查詢，可能在某些特殊情況下效率略低
- **實作相對複雜**：需要精確控制查詢的處理時機
- **不易擴展**：若需要修改為處理其他類型的範圍操作，改動成本較高
- **同步處理假設**：假設查詢是按照索引順序處理的，難以支援非順序操作

### MaxRemoval2 解法 (方法二)

#### 優點

- **覆蓋範圍更廣**：處理所有左邊界小於等於當前位置的查詢 (`queries[j][0] <= i`)，更靈活
- **實作直觀**：直接對應 Java 版本的實作邏輯，易於理解和驗證
- **簡潔命名**：使用 `diff` 而非 `deltaArray` 作為差分陣列名稱，更簡短
- **容錯性較好**：對於邊界條件的處理更加寬鬆
- **歷史驗證**：基於已驗證的 Java 解法，穩定性較高
- **更加通用**：可以適應更多種類的查詢模式，如非連續索引查詢
- **跨語言移植性**：實作風格符合 Java 和 C# 的共同慣例，容易在不同語言間移植

#### 缺點

- **可能過度處理**：在某些情況下會處理不必要的查詢，可能影響效能
- **變數命名較短**：使用 `diff` 而非 `deltaArray` 作為差分陣列名稱，可能不如方法一直觀
- **記憶體使用稍多**：需要額外的變數來追蹤狀態
- **操作序列化**：當所有查詢被緩存至優先佇列時，可能造成記憶體壓力
- **不直觀的查詢收集邏輯**：橫跨多個位置收集查詢，可能使追蹤和除錯更加困難

## 使用建議

### 選擇 MaxRemoval 的情況

- 當你需要最精確的查詢處理邏輯時
- 程式碼可讀性和維護性是首要考量時
- 對記憶體使用有嚴格要求時

### 選擇 MaxRemoval2 的情況

- 當你需要更靈活的查詢處理方式時
- 希望使用經過驗證的演算法實作時
- 需要處理複雜的邊界條件時

## 效能比較

在實際測試中，兩種解法的執行結果完全一致，說明它們在邏輯上是等價的。選擇哪種解法主要取決於：

1. **程式碼風格偏好**
2. **特定場景的需求**
3. **團隊的編碼慣例**

## 參考資料

- [LeetCode 題目連結](https://leetcode.com/problems/zero-array-transformation-iii/description/?envType=daily-question\&envId=2025-05-22)
- [LeetCode 中文題目連結](https://leetcode.cn/problems/zero-array-transformation-iii/description/?envType=daily-question\&envId=2025-05-22)
