# LeetCode 3190. 使所有元素都可以被 3 整除的最少操作數

## 題目連結
- [英文題目](https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/description/?envType=daily-question&envId=2025-11-22)
- [中文題目](https://leetcode.cn/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/description/?envType=daily-question&envId=2025-11-22)

## 題目描述

給定一個整數陣列 `nums`。一次操作可以將任一元素加 1 或減 1。

返回使所有元素都可以被 3 整除所需的最少操作次數。

### 範例

**範例 1:**

```text
輸入: nums = [1,2,3,4]
輸出: 3
說明:
- 對 1 減 1 得到 0 (3 的倍數)
- 對 2 加 1 得到 3 (3 的倍數)
- 對 4 減 1 得到 3 (3 的倍數)
總共需要 3 次操作
```

**範例 2:**

```text
輸入: nums = [3,6,9]
輸出: 0
說明: 所有元素已經都是 3 的倍數
```

## 解題思路

### 核心觀察

遍歷 `nums`，按照元素模 3 的餘數分類：

1. **如果 `nums[i] = 3k`** (餘數為 0)
   - 該元素已經是 3 的倍數
   - **無需操作**

2. **如果 `nums[i] = 3k+1`** (餘數為 1)
   - 減 1 即可得到 `3k` (3 的倍數)
   - **需要 1 次操作**

3. **如果 `nums[i] = 3k+2`** (餘數為 2)
   - 加 1 即可得到 `3(k+1)` (3 的倍數)
   - **需要 1 次操作**

### 關鍵結論

由此可見，對於不是 3 的倍數的元素，只需操作一次就可以變成 3 的倍數。

**所以答案為不是 3 的倍數的元素個數。**

## 演算法流程

1. 初始化計數器 `res = 0`
2. 遍歷陣列中的每個元素 `num`
3. 對每個元素執行 `num % 3`:
   - 如果結果不為 0，則 `res++`
4. 返回 `res`

## 程式碼實作

```csharp
public int MinimumOperations(int[] nums)
{
    int res = 0;
    
    // 遍歷陣列中的每個元素
    foreach(int num in nums)
    {
        // 如果元素不能被 3 整除，則需要一次操作
        // num % 3 == 1 時，減 1 變成 3 的倍數
        // num % 3 == 2 時，加 1 變成 3 的倍數
        res += num % 3 != 0 ? 1 : 0;
    }
    
    return res;
}
```

## 複雜度分析

### 時間複雜度
- **O(n)**
  - 其中 n 是陣列長度
  - 只需遍歷陣列一次

### 空間複雜度
- **O(1)**
  - 只使用常數額外空間
  - 只需要一個計數器變數

## 測試案例分析

### 測試案例 1: [1,2,3,4]
```
元素 1: 1 % 3 = 1 (需要操作) ✓
元素 2: 2 % 3 = 2 (需要操作) ✓
元素 3: 3 % 3 = 0 (無需操作) ✗
元素 4: 4 % 3 = 1 (需要操作) ✓

結果: 3 次操作
```

### 測試案例 2: [3,6,9]
```
元素 3: 3 % 3 = 0 (無需操作) ✗
元素 6: 6 % 3 = 0 (無需操作) ✗
元素 9: 9 % 3 = 0 (無需操作) ✗

結果: 0 次操作
```

### 測試案例 3: [1,2,4,5,7,8]
```
元素 1: 1 % 3 = 1 (需要操作) ✓
元素 2: 2 % 3 = 2 (需要操作) ✓
元素 4: 4 % 3 = 1 (需要操作) ✓
元素 5: 5 % 3 = 2 (需要操作) ✓
元素 7: 7 % 3 = 1 (需要操作) ✓
元素 8: 8 % 3 = 2 (需要操作) ✓

結果: 6 次操作
```

## 解法二：遍歷計算最小操作次數

### 思路與演算法

對於任意整數 `x`，要使其被 3 整除，可以有兩種操作方案：

1. **將 x 增加至下一個最近的 3 的倍數**
   - 所需要的操作次數是 `3 - (x % 3)`
   - 例如：x = 7，則 7 % 3 = 1，需要 3 - 1 = 2 次操作（7 → 8 → 9）

2. **將 x 減少至上一個 3 的倍數**
   - 所需要的操作次數是 `x % 3`
   - 例如：x = 7，則 7 % 3 = 1，需要 1 次操作（7 → 6）

選擇操作次數較少的方案作為結果：`Math.Min(x % 3, 3 - (x % 3))`

對於 `nums` 中的每個數，計算最小操作次數並累計，即為所求結果。

### 演算法流程

1. 遍歷陣列中的每個元素 `x`
2. 對每個元素計算：
   - 方案一：`3 - (x % 3)` （增加到 3 的倍數）
   - 方案二：`x % 3` （減少到 3 的倍數）
   - 取兩者中的最小值
3. 將所有元素的最小操作次數累加
4. 返回總和

### 程式碼實作

```csharp
public int MinimumOperations2(int[] nums)
{
    return nums.Select(x =>
    {
        // 計算兩種操作方案的操作次數：
        // x % 3: 減少到 3 的倍數所需次數
        // 3 - (x % 3): 增加到 3 的倍數所需次數
        // 取最小值作為該元素的最少操作次數
        return Math.Min(x % 3, 3 - (x % 3));
    }).Sum(); 
}
```

### 複雜度分析

#### 時間複雜度
- **O(n)**
  - 其中 n 是陣列長度
  - 需要遍歷陣列一次

#### 空間複雜度
- **O(1)**
  - 只使用常數額外空間
  - 使用 LINQ 但不創建額外的資料結構

### 測試案例分析

#### 測試案例 1: [1,2,3,4]
```
元素 1: 
  - 減少: 1 % 3 = 1
  - 增加: 3 - 1 = 2
  - 最小: min(1, 2) = 1 ✓

元素 2:
  - 減少: 2 % 3 = 2
  - 增加: 3 - 2 = 1
  - 最小: min(2, 1) = 1 ✓

元素 3:
  - 減少: 3 % 3 = 0
  - 增加: 3 - 0 = 3
  - 最小: min(0, 3) = 0 ✗

元素 4:
  - 減少: 4 % 3 = 1
  - 增加: 3 - 1 = 2
  - 最小: min(1, 2) = 1 ✓

結果: 1 + 1 + 0 + 1 = 3 次操作
```

#### 測試案例 2: [3,6,9]
```
元素 3: min(0, 3) = 0 ✗
元素 6: min(0, 3) = 0 ✗
元素 9: min(0, 3) = 0 ✗

結果: 0 + 0 + 0 = 0 次操作
```

### 方法對比

| 特性 | 方法一 | 方法二 |
|------|--------|--------|
| 核心思想 | 統計非 3 倍數的元素個數 | 計算每個元素的最小操作次數 |
| 時間複雜度 | O(n) | O(n) |
| 空間複雜度 | O(1) | O(1) |
| 程式碼風格 | 迴圈 | LINQ |
| 可讀性 | 直觀簡潔 | 函數式風格 |
| 執行效率 | 略優 | 略慢（LINQ 開銷）|

### 核心觀察

值得注意的是，`Math.Min(x % 3, 3 - (x % 3))` 對於任何數字的結果實際上等同於：
- 當 `x % 3 == 0` 時，結果為 0
- 當 `x % 3 == 1` 時，min(1, 2) = 1
- 當 `x % 3 == 2` 時，min(2, 1) = 1

因此，這個方法實際上與方法一得到相同的結果，只是從不同的角度思考問題。

## 總結

這是一道簡單的數學題，關鍵在於理解模運算的性質：
- 任何整數模 3 的結果只有 0、1、2 三種可能
- 餘數為 1 或 2 的數字，只需一次加減操作即可變成 3 的倍數
- 因此答案就是統計餘數不為 0 的元素個數

**兩種解法本質相同**，只是表達方式不同：
- **方法一**：直接判斷是否需要操作（非 3 倍數就計數）
- **方法二**：計算具體的最小操作次數（但結果等價）

---

**參考來源:** 
- [靈茶山艾府的題解](https://leetcode.cn/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/solutions/2819079/bian-li-pythonjavacgo-by-endlesscheng-sflg/)
- [力扣官方題解](https://leetcode.cn/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/solutions/3833850/shi-suo-you-yuan-su-du-ke-yi-bei-3-zheng-e8d2/)
