# Leetcode 211 與 208 的差異比較

## 1. 題目需求簡介

### Leetcode 208: Implement Trie (Prefix Tree)
這題要求我們建立一個基本的字典樹(Trie)資料結構，實作以下功能：
- `insert(word)`: 插入一個單字到字典樹中
- `search(word)`: 精確搜尋一個單字是否存在於字典樹中
- `startsWith(prefix)`: 檢查是否有單字以給定前綴開頭

**題目描述**：
建立一個 Trie (前綴樹)，支援插入單字、搜尋單字以及搜尋前綴的操作。
Trie 也稱為「字首樹」或「字典樹」，是一種樹狀資料結構，用於儲存關聯陣列，其中的鍵通常是字串。

### Leetcode 211: Design Add and Search Words Data Structure
這題要求我們建立一個單字搜尋資料結構，實作以下功能：
- `addWord(word)`: 添加單字到資料結構中
- `search(word)`: 搜尋單字，但支援使用萬用字元 `.` 來匹配任意單一字元

**題目描述**：
設計一個資料結構，支援添加新單字和搜尋單字的功能，並且搜尋時可以使用萬用字元 `.` 匹配任何一個字元。

## 2. 差異點比較

### 基本架構差異
- **相同點**：兩題都是使用字典樹(Trie)作為底層資料結構
- **不同點**：211題擴展了208題的功能，加入了萬用字元的處理能力

### 功能差異
1. **萬用字元支援**:
   - 211題引入了萬用字元 `.` 的概念，它可以匹配任意單一字元
   - 208題只支援精確匹配和前綴匹配，沒有萬用字元的概念

2. **API設計**:
   - 208題提供了 `startsWith` 方法用於前綴搜尋
   - 211題沒有明確的前綴搜尋功能，但透過萬用字元可以實現更靈活的模式匹配

### 實作複雜度差異
1. **搜尋演算法**:
   - 208題的搜尋是線性的，沿著一條路徑向下查詢
   - 211題需要使用深度優先搜尋(DFS)，遇到 `.` 時需要探索所有可能的子節點路徑

2. **時間複雜度**:
   - 208題的所有操作都是 O(m)，其中m是單字長度
   - 211題的添加操作是 O(m)，但搜尋操作在最壞情況下可達到 O(26^m)，當整個單字都是萬用字元時

### 應用場景差異
- 208題適用於前綴搜尋和精確匹配，可用於自動完成、拼寫檢查等場景
- 211題適用於模式匹配和萬用字元搜尋，類似簡化版的正則表達式，可用於更複雜的文字搜尋情境

### 程式碼結構的差異
208題中的Trie通常需要實作：
```csharp
class Trie {
    insert(word)
    search(word)
    startsWith(prefix)
}
```

211題中需要實作：
```csharp
class WordDictionary {
    addWord(word)
    search(word)  // 需要處理萬用字元
    DFS(word, index, node)  // 遞迴處理萬用字元的搜尋
}
```

## 總結
兩題都是關於字典樹的實作，但211題進一步擴展了搜尋功能，增加了模式匹配的能力，使其更接近於簡化版的正則表達式搜尋引擎。這個擴展增加了搜尋的複雜度，需要使用遞迴和回溯技術來處理所有的可能性。