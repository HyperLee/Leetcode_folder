# LeetCode 2434 使用機器人列印字典序最小的字串

## 題目描述

給定一個字串 `s` 和一個目前為空字串 `t` 的機器人。重複執行下列操作直到 `s` 和 `t` 都為空：

1. 從 `s` 移除第一個字元並交給機器人，機器人會將此字元加到 `t` 的末尾。
2. 從 `t` 移除最後一個字元並寫到紙上。

請回傳可以寫在紙上的字典序最小的字串。

---

## 方法一：剩餘字元計數 + 堆疊

### 解題流程

1. 預先統計 `s` 中每個字元剩餘出現次數，方便動態取得 `s` 剩下的最小字元。
2. 用堆疊模擬機器人手上的字串 `t`，每次從 `s` 取一個字元 push 進堆疊。
3. 每次 push 後，檢查堆疊頂端字元是否小於等於目前 `s` 剩下的最小字元，若是則 pop 並寫到紙上（加到結果字串）。
4. 反覆執行直到 `s` 和堆疊都處理完。

### 複雜度分析

- **時間複雜度**：O(n*26)，n 為字串長度。每次都要從 a~z 找剩餘最小字元，最壞情況下每次都要掃 26 次。
- **空間複雜度**：O(n)，主要為堆疊與結果字串。

---

## 方法二：後綴最小值優化法

### 解題流程

1. 預處理每個位置之後的最小字元（後綴最小值陣列 `sufMin`），O(n) 完成。
2. 用陣列模擬堆疊，遍歷 `s`，將每個字元 push 進堆疊。
3. 只要堆疊頂端字元小於等於 `sufMin[i+1]`，就 pop 並寫到結果。
4. 直到所有字元處理完畢。

### 複雜度分析

- **時間複雜度**：O(n)，所有操作均為線性。
- **空間複雜度**：O(n)，主要為堆疊、結果字串與後綴最小值陣列。

---

## 兩種方法差異比較

- 方法一每次都要動態尋找剩餘最小字元，理論上最壞 O(n*26)，但實際上因為字母數有限，效能也不差。
- 方法二利用後綴最小值預處理，所有查詢都為 O(1)，整體效能最佳，推薦用於大資料量。
- 兩者邏輯本質一致，都是根據堆疊頂端與剩餘最小字元的比較決定出堆疊時機。
- 方法二更適合面試或競賽，程式碼也較精煉。

---

本專案程式碼已於 `Program.cs` 實作，並附有多組測試資料。

歡迎參考與討論！


這題的主流貪心解法，也是 LeetCode 討論區與各大指南推薦的最佳策略。

簡單說明一致性如下：

- 這題本質就是給一個堆疊的入堆疊序列，要求出堆疊序列字典序最小。
- 每次都要比較堆疊頂端字元 (c) 與目前 s 剩下的最小字元 (minCharacter)。
  - 如果 c < minCharacter，立即出堆疊，因為這樣能讓結果更小。
  - 如果 c > minCharacter，必須繼續入堆疊，等待更小的字元出現。
  - 如果 c == minCharacter，也要出堆疊，因為這樣可以讓結果有更多連續的最小字元。
- 這個貪心策略能保證每次寫到紙上的字元都是當下能取得的最小字元，最終得到字典序最小的結果。

這個思路與你程式碼的 while 判斷條件完全一致，也是這題的標準解法。\
所以，這個解題想法是有一致認同的！
