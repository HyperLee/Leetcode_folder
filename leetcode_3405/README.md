# LeetCode 3405 - Count the Number of Arrays with K Matching Adjacent Elements

## 專案簡介

這是 LeetCode 3405 題目的 C# 解決方案。題目要求計算具有恰好 K 個相鄰相同元素的數組數量。

**題目描述**：
給定三個整數 `n`、`m`、`k`。大小為 `n` 的好數組 `arr` 定義如下：

- `arr` 中的每個元素都在包含範圍 `[1, m]` 內
- 恰好有 `k` 個索引 `i` (其中 `1 <= i < n`) 滿足條件 `arr[i - 1] == arr[i]`

回傳可以形成的好數組的數量。由於答案可能非常大，請回傳答案模 `10^9 + 7` 的結果。

## 解法說明

### 組合數學解法

本解法使用組合數學的方法，核心思想是：

1. **分段思考**：長度為 `n` 的數組有 `n-1` 對相鄰元素，其中 `k` 對相同，`n-1-k` 對不同
2. **隔板原理**：將 `n-1-k` 對不同的相鄰元素視為隔板，將數組分為 `n-k` 段相同元素的子數組
3. **計算方案數**：
   - 選擇隔板位置：`C(n-1, k)` 種方案
   - 第一段可以選任意值：`m` 種選擇
   - 後續每段與前一段不同：每段有 `m-1` 種選擇，共 `n-k-1` 段

**公式**： `m × C(n-1, k) × (m-1)^(n-k-1)`

### 函式作用說明

#### 1. `init()` 函式

- **目的**：預處理組合數學所需的階乘和逆階乘數組
- **作用**：
  - 計算 `fact[i] = i!` (階乘)
  - 計算 `inv_fact[i] = (i!)^(-1)` (階乘的模逆元)
  - 預處理範圍：`0 ≤ i ≤ MX` (MX = 1000001)
- **關鍵技術**：使用費馬小定理計算模逆元
- **時間複雜度**         ：O(MX)
- **為何需要**：組合數 `C(n,m) = n! / (m! × (n-m)!)` 需要階乘和逆階乘

#### 2. `qpow(long x, int n)` 函式

- **目的**：快速冪算法，計算 `x^n % MOD`
- **作用**：
  - 高效計算大數的冪次方
  - 使用二進制分解，將 O (n) 降為 O (log n)
  - 處理 `(m-1)^(n-k-1)` 的計算
- **演算法**：二進制快速冪
- **時間複雜度**         ：O(log n)
- **為何需要**：直接計算 `(m-1)^(n-k-1)` 會超時且可能溢位

#### 3. `comb(int n, int m)` 函式

- **目的**：計算組合數 `C(n,m)`
- **作用**：
  - 利用預處理的階乘數組
  - 公式：`C(n,m) = fact[n] × inv_fact[m] × inv_fact[n-m]`
  - 處理邊界情況：`m > n` 或 `m < 0` 時返回 0
- **時間複雜度**         ：O(1)
- **為何需要**：計算從 `n-1` 個位置中選擇 `k` 個位置的方案數

#### 4. `CountGoodArrays(int n, int m, int k)` 主函式

- **目的**：解決 LeetCode 3405 問題的核心函式
- **作用**：
  - 整合所有子函式的結果
  - 實作組合數學公式：`m × C(n-1, k) × (m-1)^(n-k-1)`
  - 處理邊界情況和異常輸入
- **邊界處理**：
  - `k > n-1`：返回 0 (不可能)
  - `k < 0`：返回 0 (無效)
  - `n = 1`：只有 `k = 0` 時返回 `m`
- **時間複雜度**         ：O(log(n-k-1))

### 整體解法流程詳解

#### 步驟一：問題分析

1. **理解題意**：
   - 數組長度為 `n`，每個元素範圍 `[1, m]`
   - 恰好有 `k` 個相鄰位置的元素相同
   - 求滿足條件的數組總數

2. **數學建模**：
   - 總共有 `n-1` 對相鄰元素
   - 其中 `k` 對相同，`n-1-k` 對不同
   - 將問題轉化為組合數學問題

#### 步驟二：隔板原理應用

1. **分段思維**：
   - `n-1-k` 個不同的相鄰對將數組分為 `n-k` 段
   - 每段內部元素完全相同
   - 相鄰段之間元素不同

2. **範例說明** (n=4, k=1)：

   ```text
   原數組：[a, b, c, d]
   相鄰對：(a,b), (b,c), (c,d) 共3對
   k=1：其中1對相同，2對不同

   可能情況：
   - (a,b)相同：[x, x, y, z] 其中x≠y, y≠z
   - (b,c)相同：[x, y, y, z] 其中x≠y, y≠z  
   - (c,d)相同：[x, y, z, z] 其中x≠y, y≠z
   ```

#### 步驟三：組合數學計算

1. **選擇相同位置**：
   - 從 `n-1` 個相鄰對中選擇 `k` 個為相同
   - 方案數：`C(n-1, k)`

2. **著色方案**：
   - 分為 `n-k` 段連續相同的子數組
   - 第一段：`m` 種顏色選擇
   - 後續每段：`m-1` 種選擇 (不能與前一段相同)
   - 總方案數：`m × (m-1)^(n-k-1)`

3. **最終答案**：
   - 選擇位置 × 著色方案
   - `C(n-1, k) × m × (m-1)^(n-k-1)`

#### 步驟四：演算法實作

1. **預處理階段**：
   - 計算階乘數組 `fact[]`
   - 計算逆階乘數組 `inv_fact[]`
   - 一次預處理，多次查詢

2. **查詢階段**：
   - 使用 `comb()` 計算組合數
   - 使用 `qpow()` 計算冪次方
   - 組合結果並取模

#### 步驟五：複雜度分析

- **時間複雜度**：
  - 預處理：O (MX)
  - 單次查詢：O (log (n-k-1))
  - 總體：O (MX + log (n-k-1))

- **空間複雜度**         ：O(MX)

### 解法優勢

1. **高效率**：相比動態規劃 O (n×m×k)，本解法近似 O (1)
2. **數學優美**：直接使用組合數學公式，邏輯清晰
3. **可擴展**：預處理後可處理多個查詢
4. **數值穩定**：使用模運算避免大數溢位

### 時間複雜度

- **時間複雜度**： O (MX + log (n-k-1))，其中 MX 為預處理數組大小
- **空間複雜度**                 ： O(MX)

## 專案結構

```text
leetcode_3405/
├── README.md                    # 專案說明文件
├── leetcode_3405.sln           # Visual Studio 解決方案檔案
├── leetcode_3405/
│   ├── leetcode_3405.csproj    # 專案檔案
│   ├── Program.cs               # 主要程式碼
│   ├── bin/                     # 建構輸出目錄
│   └── obj/                     # 建構中間檔案
└── .vscode/                     # VS Code 設定檔案
    ├── launch.json              # 偵錯設定
    ├── tasks.json               # 任務設定
    ├── settings.json            # 編輯器設定
    └── extensions.json          # 推薦擴充功能
```

## 如何執行

### 方法一：使用 .NET CLI

```bash
# 還原套件
dotnet restore

# 建構專案
dotnet build

# 執行程式
dotnet run --project leetcode_3405/leetcode_3405.csproj
```

### 方法二：使用 Visual Studio

1. 開啟 `leetcode_3405.sln`
2. 按 `F5` 開始偵錯或 `Ctrl+F5` 執行不偵錯

### 方法三：使用 VS Code

1. 開啟專案資料夾
2. 按 `F5` 開始偵錯
3. 或使用命令面板 (`Ctrl+Shift+P`) 執行：
   - `Tasks: Run Task` → `build` (建構)
   - `Tasks: Run Task` → `watch` (監控模式)

## VS Code 偵錯設定

### 可用的偵錯配置

1. **Launch LeetCode 3405 - Debug**：Debug 模式執行
2. **Launch LeetCode 3405 - Release**：Release 模式執行
3. **Attach to Process**：附加到執行中的程序

### 可用的任務

- `build`：建構專案 (預設任務)
- `build-release`：Release 模式建構
- `watch`：監控模式，檔案變更時自動重建
- `clean`：清理建構輸出
- `restore`：還原 NuGet 套件

## 測試案例

程式包含以下測試案例：

| 測試案例 | 輸入 (n, m, k) | 期望輸出 | 說明                                          |
| ---- | ------------ | ---- | ------------------------------------------- |
| 1    | (3, 2, 1)    | 4    | 基本案例：[1,1,2], [1,2,2], [2,1,1], [2,2,1] |
| 2    | (4, 2, 2)    | 6    | 較複雜案例                                       |
| 3    | (5, 2, 0)    | 2    | 無相鄰相同：[1,2,1,2,1], [2,1,2,1,2]            |
| 4    | (1, 10, 0)   | 10   | 單元素數組                                       |
| 5    | (2, 3, 1)    | 3    | 兩元素相同：[1,1], [2,2], [3,3]                |
| 6    | (3, 1, 2)    | 1    | 所有元素相同                                      |
| 7    | (3, 2, 3)    | 0    | k 超出範圍                                      |

## 核心演算法

### 1. 快速冪算法 (`qpow`)

```csharp
/// <summary>
/// 快速冪算法：計算 x^n % MOD
/// 時間複雜度 O(log n)
/// </summary>
long qpow(long x, int n)
```

### 2. 組合數計算 (`comb`)

```csharp
/// <summary>
/// 計算組合數 C(n,m) = n! / (m! * (n-m)!)
/// 使用預計算的階乘和逆階乘數組，時間複雜度 O(1)
/// </summary>
long comb(int n, int m)
```

### 3. 主要解法 (`CountGoodArrays`)

```csharp
/// <summary>
/// 組合數學解法：計算滿足條件的數組數量
/// 公式：m × C(n-1, k) × (m-1)^(n-k-1)
/// </summary>
public int CountGoodArrays(int n, int m, int k)
```

## 函式詳細說明與作用

### 1. 初始化函式 (`init`)

**作用**：

- 預計算階乘數組 `fac[i] = i! % MOD`
- 預計算逆階乘數組 `ifac[i] = (i!)^(-1) % MOD`
- 為組合數計算提供 O (1) 時間複雜度的查表支援

**為什麼需要預計算**：

- 組合數公式 `C(n,m) = n! / (m! * (n-m)!)` 涉及階乘運算
- 直接計算階乘在大數情況下會超時
- 預計算後可以用 `fac[n] * ifac[m] * ifac[n-m]` 快速求組合數

**實作細節**：

```csharp
// 計算階乘
for (int i = 1; i < MX; i++) {
    fac[i] = fac[i - 1] * i % MOD;
}

// 計算逆階乘(使用費馬小定理)
ifac[MX - 1] = qpow(fac[MX - 1], MOD - 2);
for (int i = MX - 2; i >= 0; i--) {
    ifac[i] = ifac[i + 1] * (i + 1) % MOD;
}
```

### 2. 快速冪函式 (`qpow`)

**作用**：

- 計算 `x^n % MOD`，主要用於計算模逆元
- 時間複雜度 O (log n)，比直接相乘的 O (n) 快得多

**應用場景**：

- 計算 `(m-1)^(n-k-1) % MOD`
- 計算階乘的模逆元 (費馬小定理：`a^(p-1) ≡ 1 (mod p)`，所以 `a^(-1) ≡ a^(p-2) (mod p)`)

**算法原理**：

- 二進制分解：將指數 n 表示為二進制
- 每次將底數平方，指數除以 2
- 當指數為奇數時，將當前底數乘入結果

### 3. 組合數函式 (`comb`)

**作用**：

- 計算組合數 `C(n,m) = n! / (m! * (n-m)!)`
- 利用預計算的階乘和逆階乘數組，達到 O (1) 時間複雜度

**邊界處理**：

- `m > n` 或 `m < 0`：回傳 0 (不合法的組合)
- `m = 0` 或 `m = n`：回傳 1 (邊界情況)

**公式轉換**：

```text
C(n,m) = n! / (m! * (n-m)!)
       = n! * (m!)^(-1) * ((n-m)!)^(-1)
       = fac[n] * ifac[m] * ifac[n-m]
```

### 4. 主要解法函式 (`CountGoodArrays`)

**作用**：

- 實作組合數學解法的核心邏輯
- 處理邊界情況並套用數學公式

**邊界處理邏輯**：

1. `k > n - 1`：不可能有超過 n-1 對相鄰相同元素
2. `n = 1`：單元素數組，只有 k = 0 時有效，回傳 m
3. `k = 0`：無相鄰相同元素，所有相鄰都不同

**公式應用**：

```text
結果 = m × C(n-1, k) × (m-1)^(n-k-1)
```

## 整體解法流程與設計思路

### 第一步：問題分析

1. **理解題意**：找出有恰好 k 對相鄰相同元素的數組
2. **參數範圍**：每個元素值在 [1, m] 範圍內
3. **約束條件**：數組長度為 n，相鄰相同對數恰好為 k

### 第二步：解法選擇

**為什麼選擇組合數學而非動態規劃**：

- **時間效率**：組合數學 O (MX + log (n-k-1)) vs DP O (n×m×k)
- **空間效率**：組合數學 O (MX) vs DP O (n×k) 或更多
- **程式碼簡潔**：組合數學公式直觀，DP 狀態轉移複雜

### 第三步：數學建模

1. **分段思考**：將 n-1 個相鄰位置分為「相同」和「不同」兩類
2. **隔板原理**：n-1-k 個「不同」位置將數組分為 n-k 段連續相同的子數組
3. **計數原理**：先選位置，再選顏色

### 第四步：公式推導

```text
步驟 1：選擇 k 個位置為相同 → C(n-1, k)
步驟 2：第一段選擇顏色 → m 種選擇
步驟 3：後續段選擇顏色 → (m-1)^(n-k-1) 種選擇
總計：m × C(n-1, k) × (m-1)^(n-k-1)
```

### 第五步：演算法實作策略

1. **預處理**：使用 `init()` 預計算階乘，為組合數計算奠定基礎
2. **模運算**：所有計算都在模 10^9+7 下進行，避免整數溢位
3. **快速冪**：用 `qpow()` 高效計算大指數幂運算
4. **組合數**：用 `comb()` O (1) 時間計算組合數
5. **邊界處理**：在主函式中處理各種特殊情況

### 第六步：正確性驗證

**設計思路驗證**：

- **小規模驗證**：手工計算小例子 (n=3, m=2, k=1)
- **邊界測試**：k=0, k=n-1, n=1, m=1 等特殊情況
- **數學驗證**：確保公式在各種參數下都成立

### 第七步：效能最佳化

1. **預計算策略**：一次預處理，多次查詢
2. **模運算最佳化**：避免重複的模運算
3. **記憶體存取最佳化**：連續記憶體存取模式

## 設計模式與程式架構

### 模組化設計

- **資料預處理模組**：`init()`, `fac[]`, `ifac[]`
- **數學運算模組**：`qpow()`, `comb()`
- **業務邏輯模組**：`CountGoodArrays()`
- **測試驗證模組**：`Main()` 中的測試案例

### 函式相依關係

```text
Main()
  └─ CountGoodArrays()
      ├─ comb()
      │   └─ fac[], ifac[] (由 init() 預處理)
      └─ qpow()
          └─ 用於 init() 中計算逆階乘
```

### 資料結構選擇

- **陣列**：用於儲存預計算的階乘值
- **長整數**：避免中間計算溢位
- **常數**：MOD, MX 等全域常數

這種設計確保了程式碼的**可讀性**、**可維護性**和**執行效率**，同時保持了數學解法的**優雅性**和**正確性**。
