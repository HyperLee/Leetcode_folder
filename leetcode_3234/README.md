# LeetCode 3234 - 統計 1 顯著的字串數量

> Count the Number of Substrings With Dominant Ones

這是一個解決 LeetCode 3234 題的 C# 實作專案，目標是計算給定二進位字串中所有「1 顯著」的子字串數量。

## 問題描述

給定一個二進位字串 `s`，計算其中有多少個子字串是「1 顯著」的。

**定義：** 如果一個子字串中 `'1'` 的數量大於等於 `'0'` 的數量的平方，則該子字串被稱為「1 顯著」。

數學表示：`count('1') >= count('0')²`

### 範例

**範例 1：**

```text
輸入：s = "00011"
輸出：5
解釋：以下子字串是 1 顯著的：
- "1" (2 次出現)
- "11"
- "011" 
- "0011"
```

**範例 2：**

```text
輸入：s = "101101"
輸出：16
```

## 解題方法

本題提供兩種解法，都基於相同的核心觀察：由於 1 顯著子字串必須滿足 `cnt1 >= cnt0²`，因此 `cnt0 <= √n`，也就是說 1 顯著子字串最多包含 √n 個 `'0'`。

兩種方法的時間複雜度都是 O(n√n)，但實作細節和優化方向略有不同。

---

### 方法一：枚舉法（使用 pre 陣列）

#### 核心思路

不直接枚舉所有子字串（會導致 O(n²) 或更差的複雜度），而是利用「1 顯著」的特性：`'1'` 的數量 >= `'0'` 的數量的平方。

由於 `count('0')²` 增長很快，我們可以枚舉子字串中 `'0'` 的數量（範圍只需要 0 到 √n），大幅縮小搜索空間。

#### 演算法步驟

1. **預處理階段：** 建立 `pre[]` 陣列
   - `pre[i]` 記錄位置 `i` 之前最近的一個 `'0'` 出現的位置
   - `pre[0] = -1` 作為哨兵，方便處理字串開頭的連續 `'1'`

2. **枚舉階段：** 對每個右邊界 `i` (1 到 n)
   - 枚舉包含的 `'0'` 數量 `cnt0` (從 1 到 √n)
   - 找到第 `cnt0` 個 `'0'` 的位置 `j = pre[j]`
   - 計算從位置 `j` 到位置 `i` 之間 `'1'` 的數量：`cnt1 = (i - pre[j]) - cnt0`

3. **驗證合法性：**
   - 如果 `cnt1 >= cnt0²`，則存在合法的子字串
   - 計算合法的左邊界數量：
     - 受限於第 `cnt0` 個和第 `cnt0+1` 個 `'0'` 之間的距離：`j - pre[j]`（區間長度限制）
     - 受限於保證 `'1'` 數量足夠的條件：`cnt1 - cnt0² + 1`（條件限制）
     - 取兩者的**最小值**，因為必須同時滿足兩個限制條件

4. **累加結果：** 將所有合法的左邊界數量相加

#### 複雜度分析

- **時間複雜度：** O(n√n)
  - 外層循環：O(n) 枚舉右邊界
  - 內層循環：O(√n) 枚舉 `'0'` 的數量
  
- **空間複雜度：** O(n)
  - 需要 `pre[]` 陣列儲存前一個 `'0'` 的位置

#### 關鍵優化點

- 枚舉 `'0'` 的數量而非枚舉所有子字串
- 使用 `pre[]` 陣列快速定位前一個 `'0'` 的位置
- 利用數學性質：`cnt0²` 最大為 n，所以 `cnt0` 最大為 √n

---

### 方法二：優化的枚舉法（記錄 0 的下標）

#### 核心思路

這個方法同樣利用「1 顯著子字串至多有 √n 個 `'0'`」的性質，但採用了更直觀的實作方式。

核心策略是：**枚舉子字串右端點，分別計算恰好有 0, 1, 2, ..., √n 個 `'0'` 的子字串有多少個。**

#### 數學推導

設 `cnt0` 為子字串中 `'0'` 的個數，`cnt1` 為子字串中 `'1'` 的個數。

根據題意，1 顯著子字串必須滿足：

```text
0 ≤ cnt0² ≤ cnt1 ≤ n
```

解得：

```text
0 ≤ cnt0 ≤ √n
```

因此，1 顯著子字串至多有 ⌊√n⌋ 個 `'0'`。對於本題，⌊√n⌋ ≤ 200。

#### 演算法步驟

1. **初始化資料結構**
   - `pos0[]` 陣列：記錄所有 `'0'` 出現的下標
   - `pos0[0] = -1` 作為哨兵，方便處理 `cnt0` 達到最大時的計數
   - `size`：記錄已經遇到的 `'0'` 的個數（包含哨兵，初始值為 1）
   - `total1`：記錄 [0, r] 區間中 `'1'` 的累積個數

2. **枚舉右端點 r**（從 0 到 n-1）
   - 如果 `s[r] == '0'`：
     - 記錄 `'0'` 的下標：`pos0[size++] = r`
   - 如果 `s[r] == '1'`：
     - 累加 `'1'` 的個數：`total1++`
     - **單獨計算不含 `'0'` 的子字串個數**：`ans += r - pos0[size-1]`
       - 這些子字串右端點為 r，左端點可以是 [pos0[size-1]+1, r]，共 `r - pos0[size-1]` 個

3. **枚舉子字串中 `'0'` 的個數**（倒序遍歷 `pos0` 陣列）
   - 設當前枚舉的 `cnt0 = size - i`（i 從 size-1 倒序到 1）
   - 提前終止條件：`cnt0² > total1`（當前累積的 `'1'` 不夠）
   - 設左右兩個 `'0'` 的位置：
     - `p = pos0[i-1]`：更左邊的 `'0'` 的位置（左端點的最小值 = p+1）
     - `q = pos0[i]`：當前枚舉的 `'0'` 的位置（最短子字串的左端點）
   - 計算最短子字串 [q, r] 中 `'1'` 的個數：
     - `cnt1 = (r - q + 1) - cnt0`
   - 計算合法左端點個數：
     - 左端點最小值：`p + 1`
     - 左端點最大值：`q - max(cnt0² - cnt1, 0)`
     - 合法左端點個數：`max(左端點最大值 - p, 0)`

4. **累加結果**
   - 將所有合法的左端點數量相加，即為答案

#### 複雜度分析

- **時間複雜度：** O(n√n)
  - 外層循環：O(n) 枚舉右端點
  - 內層循環：O(√n) 枚舉 `'0'` 的個數
  
- **空間複雜度：** O(n)
  - 需要 `pos0[]` 陣列儲存所有 `'0'` 的下標

#### 關鍵優化點

- **直接記錄 `'0'` 的位置**：使用 `pos0[]` 陣列，避免重複查找
- **倒序遍歷**：倒序遍歷 `pos0` 陣列，可以直接計算 `cnt0 = size - i`
- **提前終止**：當 `cnt0² > total1` 時立即跳出循環
- **單獨處理不含 `'0'` 的子字串**：在遇到 `'1'` 時直接累加，提升效率

#### 演算法視覺化

以字串 `"00011"` 為例：

```text
位置:       0  1  2  3  4
字串:       0  0  0  1  1
pos0:  -1  0  1  2  (待填)
```

**處理過程：**

1. **r = 0, s[0] = '0'**
   - 記錄：`pos0[1] = 0, size = 2`
   - 枚舉 cnt0：無合法子字串（沒有 `'1'`）

2. **r = 1, s[1] = '0'**
   - 記錄：`pos0[2] = 1, size = 3`
   - 枚舉 cnt0：無合法子字串（沒有 `'1'`）

3. **r = 2, s[2] = '0'**
   - 記錄：`pos0[3] = 2, size = 4`
   - 枚舉 cnt0：無合法子字串（沒有 `'1'`）

4. **r = 3, s[3] = '1'**
   - `total1 = 1`
   - 不含 `'0'` 的子字串：`ans += 3 - 2 = 1` → 子字串 "1"
   - 枚舉 cnt0 = 1：[2,3]，cnt1 = 1，1 >= 1 ✅，合法左端點：1 個
   - 枚舉 cnt0 = 2：[1,3]，cnt1 = 1，1 < 4 ❌
   - 枚舉 cnt0 = 3：[0,3]，cnt1 = 1，1 < 9 ❌

5. **r = 4, s[4] = '1'**
   - `total1 = 2`
   - 不含 `'0'` 的子字串：`ans += 4 - 2 = 2` → 子字串 "1", "11"
   - 枚舉 cnt0 = 1：[2,4]，cnt1 = 2，2 >= 1 ✅，合法左端點：1 個 → 子字串 "011"
   - 枚舉 cnt0 = 2：[1,4]，cnt1 = 2，2 < 4 ❌
   - 枚舉 cnt0 = 3：[0,4]，cnt1 = 2，2 < 9 ❌

**最終答案：** 1 + 1 + 2 + 1 = 5

---

### 方法比較

| 比較項目 | 方法一（pre 陣列） | 方法二（記錄 0 的下標） |
|---------|------------------|---------------------|
| **時間複雜度** | O(n√n) | O(n√n) |
| **空間複雜度** | O(n) | O(n) |
| **核心資料結構** | `pre[]` 陣列記錄每個位置前一個 `'0'` 的位置 | `pos0[]` 陣列記錄所有 `'0'` 的下標 |
| **遍歷方向** | 正序枚舉右端點，正序枚舉 `'0'` 的個數 | 正序枚舉右端點，倒序枚舉 `'0'` 的個數 |
| **不含 `'0'` 的子字串處理** | 包含在枚舉過程中（cnt0 = 0） | 單獨處理（遇到 `'1'` 時直接累加） |
| **優化策略** | 使用鏈式結構快速定位前一個 `'0'` | 直接記錄 `'0'` 的位置，避免重複查找 |
| **程式碼複雜度** | 中等，需要理解鏈式查找 | 較低，邏輯更直觀 |
| **適用場景** | 適合需要快速定位前一個元素的場景 | 適合需要記錄所有特定元素位置的場景 |

#### 兩種方法的共同點

1. **核心思想相同**：都是枚舉子字串中 `'0'` 的個數，而非枚舉所有子字串
2. **數學性質利用**：都利用了 `cnt0 <= √n` 的性質，大幅縮小搜索空間
3. **時間和空間複雜度相同**：都是 O(n√n) 時間和 O(n) 空間

#### 兩種方法的差異點

1. **資料結構設計**：
   - 方法一使用 `pre[]` 陣列形成鏈式結構，每次需要跳轉到前一個 `'0'`
   - 方法二使用 `pos0[]` 陣列直接記錄所有 `'0'` 的位置，可以隨機訪問

2. **枚舉方式**：
   - 方法一從當前位置向左跳轉，逐步增加 `'0'` 的個數
   - 方法二倒序遍歷 `pos0` 陣列，直接計算 `cnt0 = size - i`

3. **程式碼可讀性**：
   - 方法一的鏈式查找需要更多理解
   - 方法二的邏輯更加直觀，易於理解和維護

#### 選擇建議

- **學習階段**：建議從方法二開始，邏輯更清晰，易於理解
- **實務應用**：兩種方法效能相近，可根據個人喜好和程式碼風格選擇
- **面試場景**：方法二更易於在白板上實作和講解

## 專案結構

```text
leetcode_3234/
├── leetcode_3234.sln          # Visual Studio 解決方案檔
├── leetcode_3234/
│   ├── Program.cs             # 主程式檔（包含解題邏輯）
│   └── leetcode_3234.csproj   # 專案設定檔
└── README.md                  # 本檔案
```

## 開始使用

### 環境需求

- .NET 8.0 或更高版本
- Visual Studio 2022 / VS Code / Rider（任一 IDE）

### 執行專案

1. **複製專案**

   ```bash
   git clone <repository-url>
   cd leetcode_3234
   ```

2. **建構專案**

   ```bash
   dotnet build
   ```

3. **執行程式**

   ```bash
   dotnet run --project leetcode_3234
   ```

### 測試範例

程式內建了三個測試案例，並分別使用兩種方法進行測試：

```csharp
=== 方法一：枚舉法（使用 pre 陣列） ===

// 測試案例 1
輸入: "00011"
輸出: 5
預期: 5

// 測試案例 2
輸入: "101101"
輸出: 16
預期: 16

// 測試案例 3
輸入: "001101"

========================================

=== 方法二：優化的枚舉法（記錄 0 的下標） ===

// 測試案例 1
輸入: "00011"
輸出: 5
預期: 5

// 測試案例 2
輸入: "101101"
輸出: 16
預期: 16

// 測試案例 3
輸入: "001101"
```

## 程式碼結構

### `NumberOfSubstrings` 方法（方法一）

```csharp
public int NumberOfSubstrings(string s)
```

此方法實作了枚舉演算法（使用 pre 陣列），接收一個二進位字串作為參數，返回「1 顯著」子字串的數量。

**主要組成部分：**

1. **預處理 `pre[]` 陣列**：記錄每個位置前一個 `'0'` 的位置
2. **雙層迴圈**：枚舉右邊界和 `'0'` 的數量
3. **條件判斷**：驗證是否滿足「1 顯著」條件
4. **計數累加**：統計所有合法的子字串數量

### `NumberOfSubstrings_Method2` 方法（方法二）

```csharp
public int NumberOfSubstrings_Method2(string s)
```

此方法實作了優化的枚舉演算法（記錄 0 的下標），接收一個二進位字串作為參數，返回「1 顯著」子字串的數量。

**主要組成部分：**

1. **初始化 `pos0[]` 陣列**：記錄所有 `'0'` 的下標
2. **枚舉右端點**：逐一處理每個位置
3. **單獨處理不含 `'0'` 的子字串**：在遇到 `'1'` 時直接累加
4. **倒序枚舉 `'0'` 的個數**：計算包含不同數量 `'0'` 的子字串
5. **計數累加**：統計所有合法的子字串數量

### 詳細註解

兩個方法都包含完整的中文註解，說明每個步驟的邏輯和目的，方便理解和學習。

## 方法一的演算法視覺化

以字串 `"00011"` 為例：

```text
位置:  0  1  2  3  4
字串:  0  0  0  1  1
pre: -1  0  1  2  2  2
```

**枚舉過程示意：**

- `i=3, cnt0=3`: 檢查子字串包含 3 個 `'0'`
  - 範圍: [0,3)，包含 "000"，cnt1=0，0 < 9 ❌
  
- `i=4, cnt0=3`: 檢查子字串包含 3 個 `'0'`
  - 範圍: [0,4)，包含 "0001"，cnt1=1，1 < 9 ❌
  
- `i=4, cnt0=0`: 檢查子字串不包含 `'0'`
  - 範圍: [3,4)，包含 "1"，cnt1=1，1 >= 0 ✅
  - 合法左邊界: 1 個

（繼續枚舉...）

## 相關連結

- [LeetCode 3234 - English](https://leetcode.com/problems/count-the-number-of-substrings-with-dominant-ones/)
- [LeetCode 3234 - 中文](https://leetcode.cn/problems/count-the-number-of-substrings-with-dominant-ones/)

## 開發者資訊

此專案遵循 C# 開發最佳實踐：

- 使用 C# 13 最新特性
- 遵循 PascalCase 命名規範
- 完整的 XML 文件註解
- 清晰的程式碼結構和註解

## 參考資料

- [LeetCode Daily Challenge](https://leetcode.com/problemset/all/)
- [C# Programming Guide](https://docs.microsoft.com/dotnet/csharp/)
- [演算法時間複雜度分析](https://www.bigocheatsheet.com/)
