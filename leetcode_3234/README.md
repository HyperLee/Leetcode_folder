# LeetCode 3234 - 統計 1 顯著的字串數量

> Count the Number of Substrings With Dominant Ones

這是一個解決 LeetCode 3234 題的 C# 實作專案，目標是計算給定二進位字串中所有「1 顯著」的子字串數量。

## 問題描述

給定一個二進位字串 `s`，計算其中有多少個子字串是「1 顯著」的。

**定義：** 如果一個子字串中 `'1'` 的數量大於等於 `'0'` 的數量的平方，則該子字串被稱為「1 顯著」。

數學表示：`count('1') >= count('0')²`

### 範例

**範例 1：**

```text
輸入：s = "00011"
輸出：5
解釋：以下子字串是 1 顯著的：
- "1" (2 次出現)
- "11"
- "011" 
- "0011"
```

**範例 2：**

```text
輸入：s = "101101"
輸出：16
```

## 解題方法

### 方法一：枚舉法

#### 核心思路

不直接枚舉所有子字串（會導致 O(n²) 或更差的複雜度），而是利用「1 顯著」的特性：`'1'` 的數量 >= `'0'` 的數量的平方。

由於 `count('0')²` 增長很快，我們可以枚舉子字串中 `'0'` 的數量（範圍只需要 0 到 √n），大幅縮小搜索空間。

#### 演算法步驟

1. **預處理階段：** 建立 `pre[]` 陣列
   - `pre[i]` 記錄位置 `i` 之前最近的一個 `'0'` 出現的位置
   - `pre[0] = -1` 作為哨兵，方便處理字串開頭的連續 `'1'`

2. **枚舉階段：** 對每個右邊界 `i` (1 到 n)
   - 枚舉包含的 `'0'` 數量 `cnt0` (從 1 到 √n)
   - 找到第 `cnt0` 個 `'0'` 的位置 `j = pre[j]`
   - 計算從位置 `j` 到位置 `i` 之間 `'1'` 的數量：`cnt1 = (i - pre[j]) - cnt0`

3. **驗證合法性：**
   - 如果 `cnt1 >= cnt0²`，則存在合法的子字串
   - 計算合法的左邊界數量：
     - 受限於第 `cnt0` 個和第 `cnt0+1` 個 `'0'` 之間的距離：`j - pre[j]`（區間長度限制）
     - 受限於保證 `'1'` 數量足夠的條件：`cnt1 - cnt0² + 1`（條件限制）
     - 取兩者的**最小值**，因為必須同時滿足兩個限制條件

4. **累加結果：** 將所有合法的左邊界數量相加

#### 複雜度分析

- **時間複雜度：** O(n√n)
  - 外層循環：O(n) 枚舉右邊界
  - 內層循環：O(√n) 枚舉 `'0'` 的數量
  
- **空間複雜度：** O(n)
  - 需要 `pre[]` 陣列儲存前一個 `'0'` 的位置

#### 關鍵優化點

- 枚舉 `'0'` 的數量而非枚舉所有子字串
- 使用 `pre[]` 陣列快速定位前一個 `'0'` 的位置
- 利用數學性質：`cnt0²` 最大為 n，所以 `cnt0` 最大為 √n

## 專案結構

```text
leetcode_3234/
├── leetcode_3234.sln          # Visual Studio 解決方案檔
├── leetcode_3234/
│   ├── Program.cs             # 主程式檔（包含解題邏輯）
│   └── leetcode_3234.csproj   # 專案設定檔
└── README.md                  # 本檔案
```

## 開始使用

### 環境需求

- .NET 8.0 或更高版本
- Visual Studio 2022 / VS Code / Rider（任一 IDE）

### 執行專案

1. **複製專案**

   ```bash
   git clone <repository-url>
   cd leetcode_3234
   ```

2. **建構專案**

   ```bash
   dotnet build
   ```

3. **執行程式**

   ```bash
   dotnet run --project leetcode_3234
   ```

### 測試範例

程式內建了三個測試案例：

```csharp
// 測試案例 1
輸入: "00011"
輸出: 5
預期: 5

// 測試案例 2
輸入: "101101"
輸出: 16
預期: 16

// 測試案例 3
輸入: "001101"
```

## 程式碼結構

### `NumberOfSubstrings` 方法

```csharp
public int NumberOfSubstrings(string s)
```

此方法實作了枚舉演算法，接收一個二進位字串作為參數，返回「1 顯著」子字串的數量。

**主要組成部分：**

1. **預處理 `pre[]` 陣列**：記錄每個位置前一個 `'0'` 的位置
2. **雙層迴圈**：枚舉右邊界和 `'0'` 的數量
3. **條件判斷**：驗證是否滿足「1 顯著」條件
4. **計數累加**：統計所有合法的子字串數量

### 詳細註解

程式碼包含完整的中文註解，說明每個步驟的邏輯和目的，方便理解和學習。

## 演算法視覺化

以字串 `"00011"` 為例：

```text
位置:  0  1  2  3  4
字串:  0  0  0  1  1
pre: -1  0  1  2  2  2
```

**枚舉過程示意：**

- `i=3, cnt0=3`: 檢查子字串包含 3 個 `'0'`
  - 範圍: [0,3)，包含 "000"，cnt1=0，0 < 9 ❌
  
- `i=4, cnt0=3`: 檢查子字串包含 3 個 `'0'`
  - 範圍: [0,4)，包含 "0001"，cnt1=1，1 < 9 ❌
  
- `i=4, cnt0=0`: 檢查子字串不包含 `'0'`
  - 範圍: [3,4)，包含 "1"，cnt1=1，1 >= 0 ✅
  - 合法左邊界: 1 個

（繼續枚舉...）

## 相關連結

- [LeetCode 3234 - English](https://leetcode.com/problems/count-the-number-of-substrings-with-dominant-ones/)
- [LeetCode 3234 - 中文](https://leetcode.cn/problems/count-the-number-of-substrings-with-dominant-ones/)

## 開發者資訊

此專案遵循 C# 開發最佳實踐：

- 使用 C# 13 最新特性
- 遵循 PascalCase 命名規範
- 完整的 XML 文件註解
- 清晰的程式碼結構和註解

## 參考資料

- [LeetCode Daily Challenge](https://leetcode.com/problemset/all/)
- [C# Programming Guide](https://docs.microsoft.com/dotnet/csharp/)
- [演算法時間複雜度分析](https://www.bigocheatsheet.com/)
