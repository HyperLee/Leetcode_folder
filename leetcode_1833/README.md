# LeetCode 1833. Maximum Ice Cream Bars

🍦 雪糕的最大數量 - 貪心演算法解題

## 📋 題目描述

| 項目 | 內容 |
|------|------|
| 題號 | 1833 |
| 難度 | Medium |
| 標籤 | Array, Greedy, Sorting |
| 連結 | [LeetCode](https://leetcode.com/problems/maximum-ice-cream-bars/) / [力扣](https://leetcode.cn/problems/maximum-ice-cream-bars/) |

### 題目內容

在炎熱的夏日，一位男孩想買一些雪糕棒。店裡有 `n` 支雪糕棒。

給定一個長度為 `n` 的整數陣列 `costs`，其中 `costs[i]` 是第 `i` 支雪糕棒的價格（以硬幣計）。男孩起始有 `coins` 枚硬幣可以花，他想盡可能多買雪糕棒。

> [!NOTE]
> 男孩可以按**任意順序**購買雪糕棒。

**回傳**：男孩使用 `coins` 枚硬幣**最多**能買到的雪糕棒數量。

### 範例

**範例 1：**
```
輸入：costs = [1, 3, 2, 4, 1], coins = 7
輸出：4
解釋：男孩可以購買價格為 1, 1, 2, 3 的雪糕棒，總價為 7。
```

**範例 2：**
```
輸入：costs = [10, 6, 8, 7, 7, 8], coins = 5
輸出：0
解釋：男孩無法購買任何雪糕棒，因為最便宜的也要 6 枚硬幣。
```

**範例 3：**
```
輸入：costs = [1, 6, 3, 1, 2, 5], coins = 20
輸出：6
解釋：男孩可以購買所有雪糕棒，總價為 18 枚硬幣。
```

### 限制條件

- `costs.length == n`
- `1 <= n <= 10^5`
- `1 <= costs[i] <= 10^5`
- `1 <= coins <= 10^8`

---

## 💡 解題思路

### 核心概念：貪心演算法 (Greedy Algorithm)

這道題的關鍵洞察是：

> **要買到最多支雪糕，就要優先買最便宜的！**

這是一個經典的**貪心問題**。貪心演算法的核心思想是：
- 在每一步選擇中，都採取當前狀態下的最優選擇
- 期望通過一系列局部最優選擇，達到全域最優

### 為什麼貪心有效？

假設我們有兩種購買策略：
1. **策略 A**：優先買便宜的雪糕
2. **策略 B**：隨機購買雪糕

假設 `costs = [1, 2, 3, 4]`，`coins = 5`：
- 策略 A：買 `1 + 2 = 3`，還剩 2 元，但 3 元的買不起 → 共 **2 支**
- 策略 A（繼續）：實際上 `1 + 2 = 3`，剩 2 元，還可以...等等，讓我重算
- 策略 A：買 `1`（剩 4）→ 買 `2`（剩 2）→ 買不起 `3` → 共 **2 支**

如果用策略 B 先買 `3`：
- 買 `3`（剩 2）→ 買 `1`（剩 1）→ 買不起 `2` → 共 **2 支**

看起來一樣？讓我們換個例子 `costs = [1, 1, 3, 4]`，`coins = 5`：
- 策略 A：`1 + 1 + 3 = 5` → 共 **3 支** ✅
- 策略 B（先買 4）：`4 + 1 = 5` → 共 **2 支** ❌

**結論**：優先購買便宜的雪糕，能夠用相同的錢買到更多支！

---

## 🔧 解法詳解

### 方法一：排序 + 貪心

#### 演算法步驟

```
1. 對價格陣列進行「升序排序」
2. 從最便宜的雪糕開始遍歷
3. 如果剩餘硬幣 >= 當前價格：
   - 購買這支雪糕（扣除硬幣）
   - 計數器 +1
4. 如果硬幣不足：
   - 停止遍歷（後面的更貴，也買不起）
5. 回傳計數器的值
```

#### 程式碼實作

```csharp
public int MaxIceCream(int[] costs, int coins)
{
    // 步驟 1：升序排序，讓最便宜的雪糕排在前面
    Array.Sort(costs);

    int count = 0;  // 已購買的雪糕數量
    int n = costs.Length;

    // 步驟 2：從最便宜的雪糕開始遍歷
    for (int i = 0; i < n; i++)
    {
        int cost = costs[i];  // 當前雪糕的價格

        // 步驟 3：檢查是否有足夠的硬幣購買
        if (coins >= cost)
        {
            // 購買這支雪糕：扣除硬幣，增加計數
            coins -= cost;
            count++;
        }
        else
        {
            // 步驟 4：硬幣不足，後續雪糕更貴，直接結束
            break;
        }
    }

    return count;
}
```

#### 複雜度分析

| 項目 | 複雜度 | 說明 |
|------|--------|------|
| 時間複雜度 | O(n log n) | 排序需要 O(n log n)，遍歷需要 O(n) |
| 空間複雜度 | O(log n) | 排序所需的遞迴堆疊空間 |

---

## 📊 流程演示

以 `costs = [1, 3, 2, 4, 1]`, `coins = 7` 為例：

### Step 0：排序

```
原始陣列：[1, 3, 2, 4, 1]
排序後：  [1, 1, 2, 3, 4]
         ↑
         從這裡開始
```

### Step 1：購買第一支雪糕

```
價格陣列：[1, 1, 2, 3, 4]
          ↑
目前價格：1
剩餘硬幣：7 >= 1 ✅ 可以買！
購買後硬幣：7 - 1 = 6
已購買數量：1
```

### Step 2：購買第二支雪糕

```
價格陣列：[1, 1, 2, 3, 4]
             ↑
目前價格：1
剩餘硬幣：6 >= 1 ✅ 可以買！
購買後硬幣：6 - 1 = 5
已購買數量：2
```

### Step 3：購買第三支雪糕

```
價格陣列：[1, 1, 2, 3, 4]
                ↑
目前價格：2
剩餘硬幣：5 >= 2 ✅ 可以買！
購買後硬幣：5 - 2 = 3
已購買數量：3
```

### Step 4：購買第四支雪糕

```
價格陣列：[1, 1, 2, 3, 4]
                   ↑
目前價格：3
剩餘硬幣：3 >= 3 ✅ 可以買！
購買後硬幣：3 - 3 = 0
已購買數量：4
```

### Step 5：嘗試購買第五支雪糕

```
價格陣列：[1, 1, 2, 3, 4]
                      ↑
目前價格：4
剩餘硬幣：0 >= 4 ❌ 買不起！
結束遍歷
```

### 最終結果

```
✅ 最多可購買：4 支雪糕
💰 花費明細：1 + 1 + 2 + 3 = 7 枚硬幣
```

---

## 🚀 快速開始

### 環境需求

- .NET 10.0 或更高版本

### 執行方式

```bash
cd leetcode_1833
dotnet run
```

### 預期輸出

```
=== LeetCode 1833. Maximum Ice Cream Bars ===

測試案例 1: costs = [1, 3, 2, 4, 1], coins = 7
結果: 4 (預期: 4)

測試案例 2: costs = [10, 6, 8, 7, 7, 8], coins = 5
結果: 0 (預期: 0)

測試案例 3: costs = [1, 6, 3, 1, 2, 5], coins = 20
結果: 6 (預期: 6)

測試案例 4: costs = [5], coins = 5
結果: 1 (預期: 1)

測試案例 5: costs = [2, 2, 2, 2, 2], coins = 7
結果: 3 (預期: 3)

=== 測試完成 ===
```

---

## 📚 延伸學習

### 相關題目

| 題號 | 題目 | 難度 |
|------|------|------|
| 455 | Assign Cookies | Easy |
| 860 | Lemonade Change | Easy |
| 1029 | Two City Scheduling | Medium |

### 進階挑戰

本題也可以使用**計數排序（Counting Sort）** 來優化時間複雜度至 O(n + m)，其中 m 是價格的最大值。當價格範圍較小時，這種方法會更有效率。
