dotnet build leetcode_1317/leetcode_1317.csproj
dotnet run --project leetcode_1317/leetcode_1317.csproj
# leetcode_1317

LeetCode 1317: Convert Integer to the Sum of Two No-Zero Integers

這是一個簡潔的 .NET 範例專案，展示如何為題目 1317 實作一個清晰且可驗證的解法。專案主要程式位於 `leetcode_1317/Program.cs`，並在 `Main` 中呼叫 `RunTests()` 以示範多組範例輸出。

## 問題描述（繁體中文）

無零整數 (No-Zero integer) 是指其十進位表示中不包含任何數字 `0` 的正整數。

給定一個整數 `n`，回傳一個包含兩個整數 `[a, b]` 的陣列，其中：

- `a` 與 `b` 均為無零整數。
- `a + b == n`。

題目保證至少存在一組有效解；若存在多種有效解，回傳任一組即可。

## 專案檔案

- `leetcode_1317/Program.cs` — 程式主體與一個簡單的 `RunTests()` 範例用來在本機印出結果。

## 詳細解法說明

此專案採用直接且穩健的暴力搜尋（brute-force）策略，重點在於正確性與可讀性。下面分段說明演算法、最佳化、正確性與替代實作。

### 直觀演算法（已實作）

1. 迭代 `a` 從 `1` 到 `n-1`：對每個 `a`，令 `b = n - a`。
2. 檢查 `a` 與 `b` 的十進位表示是否包含字元 `'0'`（本實作使用 `ToString().Contains('0')`）。
3. 若兩者都不包含 `'0'`，立即回傳 `[a, b]`。題目保證至少有一組解，因此演算法在找到第一組解後即可停止。

實作上的重點為簡潔與可讀：以字串檢查為主要手段，方便理解並利於維護。

### 優化（避免字串分配）

為了降低記憶體分配與 GC 負擔，可使用整數逐位檢查來替代字串檢查：透過取模與整除逐位判斷是否存在 `0`：

```csharp
static bool HasZero(int x)
{
    if (x == 0) return true; // 若要視 0 為含 0 的數字
    while (x > 0)
    {
        if (x % 10 == 0) return true;
        x /= 10;
    }
    return false;
}

// 使用方式： if (!HasZero(a) && !HasZero(b)) { return new int[] { a, b }; }
```

此做法避免了每次檢查時建立字串，對較大的輸入或高頻呼叫會比較省成本。

### 更快的策略（可選）

雖然暴力法在最壞情況下需要 O(n) 次檢查，但我們可以做簡單剪枝：

- 只遍歷 `a` 到 `n/2`，因為若 `a` 與 `b` 互換結果相同。找到一組就足夠；這會減少一半的檢查次數。  
- 若要一個真正的線性時間內常數次檢查解法，可嘗試逐位構造 `a` 與 `b` 來避免 0（較繁瑣且邏輯較複雜）。

### 正確性與存在性

題目保證至少有一組解，因此暴力搜尋一定能在有限步數內找到解。若實務上輸入不符題目假設，程式仍保有防守式回傳 `Array.Empty<int>()`。

### 時間與空間複雜度

- 時間複雜度（字串檢查）：O(n * d)，其中 `n` 為輸入值範圍（需要嘗試的 a 數量），`d` 為數字位數（轉字串或逐位檢查的成本，通常 d = O(log n)）。
- 空間複雜度：O(1)（回傳的陣列大小固定）。

使用逐位數字檢查可減少字串分配，但時間階仍受 `n` 與 `d` 影響。

## 範例執行結果

`RunTests()`（在 `Main` 中已被呼叫）會印出：

```
n=2 -> [1, 1]
n=11 -> [2, 9]
n=100 -> [1, 99]
n=1010 -> [11, 999]
n=109 -> [11, 98]
```

## 如何在本機執行

使用 .NET SDK：

```bash
# 在專案根目錄
dotnet build leetcode_1317/leetcode_1317.csproj
dotnet run --project leetcode_1317/leetcode_1317.csproj
```

或直接執行已建置的二進位檔：

```bash
./leetcode_1317/leetcode_1317/bin/Debug/net8.0/leetcode_1317
```

## 建議的後續改進

- 將現有測試轉為單元測試（xUnit / NUnit），以便自動化回歸測試。  
- 若要比較效能：建立 Benchmark（BenchmarkDotNet）來比較字串檢查與逐位檢查的實際差異。  
- 如果需要處理極大數值範圍，考慮逐位構造法以減少迭代次數。

---

若你想，我可以把 README 再加入範例圖示、單元測試或 Benchmark 範例。
